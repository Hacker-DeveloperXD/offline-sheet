{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { deepMap } from '../../utils/collection.js';\nimport { unaryMinusNumber } from '../../plain/number/index.js';\nvar name = 'unaryMinus';\nvar dependencies = ['typed'];\nexport var createUnaryMinus = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Inverse the sign of a value, apply a unary minus operation.\n   *\n   * For matrices, the function is evaluated element wise. Boolean values and\n   * strings will be converted to a number. For complex numbers, both real and\n   * complex value are inverted.\n   *\n   * Syntax:\n   *\n   *    math.unaryMinus(x)\n   *\n   * Examples:\n   *\n   *    math.unaryMinus(3.5)      // returns -3.5\n   *    math.unaryMinus(-4.2)     // returns 4.2\n   *\n   * See also:\n   *\n   *    add, subtract, unaryPlus\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.\n   */\n  return typed(name, {\n    number: unaryMinusNumber,\n    'Complex | BigNumber | Fraction': x => x.neg(),\n    bigint: x => -x,\n    Unit: typed.referToSelf(self => x => {\n      var res = x.clone();\n      res.value = typed.find(self, res.valueType())(x.value);\n      return res;\n    }),\n    // deep map collection, skip zeros since unaryMinus(0) = 0\n    'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self, true))\n\n    // TODO: add support for string\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,mBAAmB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACvE,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;GAsBC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,qKAAA,CAAA,mBAAgB;QACxB,kCAAkC,CAAA,IAAK,EAAE,GAAG;QAC5C,QAAQ,CAAA,IAAK,CAAC;QACd,MAAM,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAA;gBAC9B,IAAI,MAAM,EAAE,KAAK;gBACjB,IAAI,KAAK,GAAG,MAAM,IAAI,CAAC,MAAM,IAAI,SAAS,IAAI,EAAE,KAAK;gBACrD,OAAO;YACT;QACA,0DAA0D;QAC1D,kBAAkB,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAA,IAAK,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,GAAG,MAAM;IAGpE;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { deepMap } from '../../utils/collection.js';\nimport { unaryPlusNumber } from '../../plain/number/index.js';\nimport { safeNumberType } from '../../utils/number.js';\nvar name = 'unaryPlus';\nvar dependencies = ['typed', 'config', 'numeric'];\nexport var createUnaryPlus = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    numeric\n  } = _ref;\n  /**\n   * Unary plus operation.\n   * Boolean values and strings will be converted to a number, numeric values will be returned as is.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.unaryPlus(x)\n   *\n   * Examples:\n   *\n   *    math.unaryPlus(3.5)      // returns 3.5\n   *    math.unaryPlus(1)     // returns 1\n   *\n   * See also:\n   *\n   *    unaryMinus, add, subtract\n   *\n   * @param  {number | BigNumber | bigint | Fraction | string | Complex | Unit | Array | Matrix} x\n   *            Input value\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix}\n   *            Returns the input value when numeric, converts to a number when input is non-numeric.\n   */\n  return typed(name, {\n    number: unaryPlusNumber,\n    Complex: function Complex(x) {\n      return x; // complex numbers are immutable\n    },\n    BigNumber: function BigNumber(x) {\n      return x; // bignumbers are immutable\n    },\n    bigint: function bigint(x) {\n      return x;\n    },\n    Fraction: function Fraction(x) {\n      return x; // fractions are immutable\n    },\n    Unit: function Unit(x) {\n      return x.clone();\n    },\n    // deep map collection, skip zeros since unaryPlus(0) = 0\n    'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self, true)),\n    boolean: function boolean(x) {\n      return numeric(x ? 1 : 0, config.number);\n    },\n    string: function string(x) {\n      return numeric(x, safeNumberType(x, config));\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;CAAU;AAC1C,IAAI,kBAAkB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACtE,IAAI,EACF,KAAK,EACL,MAAM,EACN,OAAO,EACR,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;GAuBC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,qKAAA,CAAA,kBAAe;QACvB,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,GAAG,gCAAgC;QAC5C;QACA,WAAW,SAAS,UAAU,CAAC;YAC7B,OAAO,GAAG,2BAA2B;QACvC;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO;QACT;QACA,UAAU,SAAS,SAAS,CAAC;YAC3B,OAAO,GAAG,0BAA0B;QACtC;QACA,MAAM,SAAS,KAAK,CAAC;YACnB,OAAO,EAAE,KAAK;QAChB;QACA,yDAAyD;QACzD,kBAAkB,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAA,IAAK,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,GAAG,MAAM;QAClE,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,QAAQ,IAAI,IAAI,GAAG,OAAO,MAAM;QACzC;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,QAAQ,GAAG,CAAA,GAAA,uJAAA,CAAA,iBAAc,AAAD,EAAE,GAAG;QACtC;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/abs.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { deepMap } from '../../utils/collection.js';\nimport { absNumber } from '../../plain/number/index.js';\nvar name = 'abs';\nvar dependencies = ['typed'];\nexport var createAbs = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Calculate the absolute value of a number. For matrices, the function is\n   * evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.abs(x)\n   *\n   * Examples:\n   *\n   *    math.abs(3.5)                // returns number 3.5\n   *    math.abs(-4.2)               // returns number 4.2\n   *\n   *    math.abs([3, -5, -1, 0, 2])  // returns Array [3, 5, 1, 0, 2]\n   *\n   * See also:\n   *\n   *    sign\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit} x\n   *            A number or matrix for which to get the absolute value\n   * @return {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit}\n   *            Absolute value of `x`\n   */\n  return typed(name, {\n    number: absNumber,\n    'Complex | BigNumber | Fraction | Unit': x => x.abs(),\n    bigint: x => x < 0n ? -x : x,\n    // deep map collection, skip zeros since abs(0) = 0\n    'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self, true))\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,YAAY,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAChE,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;GAuBC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,qKAAA,CAAA,YAAS;QACjB,yCAAyC,CAAA,IAAK,EAAE,GAAG;QACnD,QAAQ,CAAA,IAAK,IAAI,EAAE,GAAG,CAAC,IAAI;QAC3B,mDAAmD;QACnD,kBAAkB,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAA,IAAK,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,GAAG,MAAM;IACpE;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { addNumber } from '../../plain/number/index.js';\nvar name = 'addScalar';\nvar dependencies = ['typed'];\nexport var createAddScalar = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Add two scalar values, `x + y`.\n   * This function is meant for internal use: it is used by the public function\n   * `add`\n   *\n   * This function does not support collections (Array or Matrix).\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   First value to add\n   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Second value to add\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Sum of `x` and `y`\n   * @private\n   */\n  return typed(name, {\n    'number, number': addNumber,\n    'Complex, Complex': function Complex_Complex(x, y) {\n      return x.add(y);\n    },\n    'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {\n      return x.plus(y);\n    },\n    'bigint, bigint': function bigint_bigint(x, y) {\n      return x + y;\n    },\n    'Fraction, Fraction': function Fraction_Fraction(x, y) {\n      return x.add(y);\n    },\n    'Unit, Unit': typed.referToSelf(self => (x, y) => {\n      if (x.value === null || x.value === undefined) {\n        throw new Error('Parameter x contains a unit with undefined value');\n      }\n      if (y.value === null || y.value === undefined) {\n        throw new Error('Parameter y contains a unit with undefined value');\n      }\n      if (!x.equalBase(y)) throw new Error('Units do not match');\n      var res = x.clone();\n      res.value = typed.find(self, [res.valueType(), y.valueType()])(res.value, y.value);\n      res.fixPrefix = false;\n      return res;\n    })\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,kBAAkB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACtE,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;GAWC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB,qKAAA,CAAA,YAAS;QAC3B,oBAAoB,SAAS,gBAAgB,CAAC,EAAE,CAAC;YAC/C,OAAO,EAAE,GAAG,CAAC;QACf;QACA,wBAAwB,SAAS,oBAAoB,CAAC,EAAE,CAAC;YACvD,OAAO,EAAE,IAAI,CAAC;QAChB;QACA,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,OAAO,IAAI;QACb;QACA,sBAAsB,SAAS,kBAAkB,CAAC,EAAE,CAAC;YACnD,OAAO,EAAE,GAAG,CAAC;QACf;QACA,cAAc,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAC,GAAG;gBAC1C,IAAI,EAAE,KAAK,KAAK,QAAQ,EAAE,KAAK,KAAK,WAAW;oBAC7C,MAAM,IAAI,MAAM;gBAClB;gBACA,IAAI,EAAE,KAAK,KAAK,QAAQ,EAAE,KAAK,KAAK,WAAW;oBAC7C,MAAM,IAAI,MAAM;gBAClB;gBACA,IAAI,CAAC,EAAE,SAAS,CAAC,IAAI,MAAM,IAAI,MAAM;gBACrC,IAAI,MAAM,EAAE,KAAK;gBACjB,IAAI,KAAK,GAAG,MAAM,IAAI,CAAC,MAAM;oBAAC,IAAI,SAAS;oBAAI,EAAE,SAAS;iBAAG,EAAE,IAAI,KAAK,EAAE,EAAE,KAAK;gBACjF,IAAI,SAAS,GAAG;gBAChB,OAAO;YACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/subtractScalar.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { subtractNumber } from '../../plain/number/index.js';\nvar name = 'subtractScalar';\nvar dependencies = ['typed'];\nexport var createSubtractScalar = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Subtract two scalar values, `x - y`.\n   * This function is meant for internal use: it is used by the public function\n   * `subtract`\n   *\n   * This function does not support collections (Array or Matrix).\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   First value\n   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Second value to be subtracted from `x`\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Difference of `x` and `y`\n   * @private\n   */\n  return typed(name, {\n    'number, number': subtractNumber,\n    'Complex, Complex': function Complex_Complex(x, y) {\n      return x.sub(y);\n    },\n    'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {\n      return x.minus(y);\n    },\n    'bigint, bigint': function bigint_bigint(x, y) {\n      return x - y;\n    },\n    'Fraction, Fraction': function Fraction_Fraction(x, y) {\n      return x.sub(y);\n    },\n    'Unit, Unit': typed.referToSelf(self => (x, y) => {\n      if (x.value === null || x.value === undefined) {\n        throw new Error('Parameter x contains a unit with undefined value');\n      }\n      if (y.value === null || y.value === undefined) {\n        throw new Error('Parameter y contains a unit with undefined value');\n      }\n      if (!x.equalBase(y)) throw new Error('Units do not match');\n      var res = x.clone();\n      res.value = typed.find(self, [res.valueType(), y.valueType()])(res.value, y.value);\n      res.fixPrefix = false;\n      return res;\n    })\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,uBAAuB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAC3E,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;GAWC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB,qKAAA,CAAA,iBAAc;QAChC,oBAAoB,SAAS,gBAAgB,CAAC,EAAE,CAAC;YAC/C,OAAO,EAAE,GAAG,CAAC;QACf;QACA,wBAAwB,SAAS,oBAAoB,CAAC,EAAE,CAAC;YACvD,OAAO,EAAE,KAAK,CAAC;QACjB;QACA,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,OAAO,IAAI;QACb;QACA,sBAAsB,SAAS,kBAAkB,CAAC,EAAE,CAAC;YACnD,OAAO,EAAE,GAAG,CAAC;QACf;QACA,cAAc,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAC,GAAG;gBAC1C,IAAI,EAAE,KAAK,KAAK,QAAQ,EAAE,KAAK,KAAK,WAAW;oBAC7C,MAAM,IAAI,MAAM;gBAClB;gBACA,IAAI,EAAE,KAAK,KAAK,QAAQ,EAAE,KAAK,KAAK,WAAW;oBAC7C,MAAM,IAAI,MAAM;gBAClB;gBACA,IAAI,CAAC,EAAE,SAAS,CAAC,IAAI,MAAM,IAAI,MAAM;gBACrC,IAAI,MAAM,EAAE,KAAK;gBACjB,IAAI,KAAK,GAAG,MAAM,IAAI,CAAC,MAAM;oBAAC,IAAI,SAAS;oBAAI,EAAE,SAAS;iBAAG,EAAE,IAAI,KAAK,EAAE,EAAE,KAAK;gBACjF,IAAI,SAAS,GAAG;gBAChB,OAAO;YACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 314, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { isBigNumber, isComplex, isFraction } from '../../utils/is.js';\nimport { cbrtNumber } from '../../plain/number/index.js';\nvar name = 'cbrt';\nvar dependencies = ['config', 'typed', 'isNegative', 'unaryMinus', 'matrix', 'Complex', 'BigNumber', 'Fraction'];\nexport var createCbrt = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    isNegative,\n    unaryMinus,\n    matrix,\n    Complex,\n    BigNumber,\n    Fraction\n  } = _ref;\n  /**\n   * Calculate the cubic root of a value.\n   *\n   * To avoid confusion with the matrix cube root, this function does not\n   * apply to matrices. For a matrix, to take the cube root elementwise,\n   * see the examples.\n   *\n   * Syntax:\n   *\n   *    math.cbrt(x)\n   *    math.cbrt(x, allRoots)\n   *\n   * Examples:\n   *\n   *    math.cbrt(27)                  // returns 3\n   *    math.cube(3)                   // returns 27\n   *    math.cbrt(-64)                 // returns -4\n   *    math.cbrt(math.unit('27 m^3')) // returns Unit 3 m\n   *    math.map([27, 64, 125], x => math.cbrt(x))       // returns [3, 4, 5]\n   *\n   *    const x = math.complex('8i')\n   *    math.cbrt(x)                   // returns Complex 1.7320508075689 + i\n   *    math.cbrt(x, true)             // returns Matrix [\n   *                                    //    1.7320508075689 + i\n   *                                    //   -1.7320508075689 + i\n   *                                    //   -2i\n   *                                    // ]\n   *\n   * See also:\n   *\n   *    square, sqrt, cube\n   *\n   * @param {number | BigNumber | Complex | Unit} x\n   *            Value for which to calculate the cubic root.\n   * @param {boolean} [allRoots]  Optional, false by default. Only applicable\n   *            when `x` is a number or complex number. If true, all complex\n   *            roots are returned, if false (default) the principal root is\n   *            returned.\n   * @return {number | BigNumber | Complex | Unit}\n   *            Returns the cubic root of `x`\n   */\n  return typed(name, {\n    number: cbrtNumber,\n    // note: signature 'number, boolean' is also supported,\n    //       created by typed as it knows how to convert number to Complex\n\n    Complex: _cbrtComplex,\n    'Complex, boolean': _cbrtComplex,\n    BigNumber: function BigNumber(x) {\n      return x.cbrt();\n    },\n    Unit: _cbrtUnit\n  });\n\n  /**\n   * Calculate the cubic root for a complex number\n   * @param {Complex} x\n   * @param {boolean} [allRoots]   If true, the function will return an array\n   *                               with all three roots. If false or undefined,\n   *                               the principal root is returned.\n   * @returns {Complex | Array.<Complex> | Matrix.<Complex>} Returns the cubic root(s) of x\n   * @private\n   */\n  function _cbrtComplex(x, allRoots) {\n    // https://www.wikiwand.com/en/Cube_root#/Complex_numbers\n\n    var arg3 = x.arg() / 3;\n    var abs = x.abs();\n\n    // principal root:\n    var principal = new Complex(cbrtNumber(abs), 0).mul(new Complex(0, arg3).exp());\n    if (allRoots) {\n      var all = [principal, new Complex(cbrtNumber(abs), 0).mul(new Complex(0, arg3 + Math.PI * 2 / 3).exp()), new Complex(cbrtNumber(abs), 0).mul(new Complex(0, arg3 - Math.PI * 2 / 3).exp())];\n      return config.matrix === 'Array' ? all : matrix(all);\n    } else {\n      return principal;\n    }\n  }\n\n  /**\n   * Calculate the cubic root for a Unit\n   * @param {Unit} x\n   * @return {Unit} Returns the cubic root of x\n   * @private\n   */\n  function _cbrtUnit(x) {\n    if (x.value && isComplex(x.value)) {\n      var result = x.clone();\n      result.value = 1.0;\n      result = result.pow(1.0 / 3); // Compute the units\n      result.value = _cbrtComplex(x.value); // Compute the value\n      return result;\n    } else {\n      var negate = isNegative(x.value);\n      if (negate) {\n        x.value = unaryMinus(x.value);\n      }\n\n      // TODO: create a helper function for this\n      var third;\n      if (isBigNumber(x.value)) {\n        third = new BigNumber(1).div(3);\n      } else if (isFraction(x.value)) {\n        third = new Fraction(1, 3);\n      } else {\n        third = 1 / 3;\n      }\n      var _result = x.pow(third);\n      if (negate) {\n        _result.value = unaryMinus(_result.value);\n      }\n      return _result;\n    }\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAU;IAAS;IAAc;IAAc;IAAU;IAAW;IAAa;CAAW;AACzG,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,MAAM,EACN,KAAK,EACL,UAAU,EACV,UAAU,EACV,MAAM,EACN,OAAO,EACP,SAAS,EACT,QAAQ,EACT,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwCC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,qKAAA,CAAA,aAAU;QAClB,uDAAuD;QACvD,sEAAsE;QAEtE,SAAS;QACT,oBAAoB;QACpB,WAAW,SAAS,UAAU,CAAC;YAC7B,OAAO,EAAE,IAAI;QACf;QACA,MAAM;IACR;;IAEA;;;;;;;;GAQC,GACD,SAAS,aAAa,CAAC,EAAE,QAAQ;QAC/B,yDAAyD;QAEzD,IAAI,OAAO,EAAE,GAAG,KAAK;QACrB,IAAI,MAAM,EAAE,GAAG;QAEf,kBAAkB;QAClB,IAAI,YAAY,IAAI,QAAQ,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,MAAM,GAAG,GAAG,CAAC,IAAI,QAAQ,GAAG,MAAM,GAAG;QAC5E,IAAI,UAAU;YACZ,IAAI,MAAM;gBAAC;gBAAW,IAAI,QAAQ,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,MAAM,GAAG,GAAG,CAAC,IAAI,QAAQ,GAAG,OAAO,KAAK,EAAE,GAAG,IAAI,GAAG,GAAG;gBAAK,IAAI,QAAQ,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,MAAM,GAAG,GAAG,CAAC,IAAI,QAAQ,GAAG,OAAO,KAAK,EAAE,GAAG,IAAI,GAAG,GAAG;aAAI;YAC3L,OAAO,OAAO,MAAM,KAAK,UAAU,MAAM,OAAO;QAClD,OAAO;YACL,OAAO;QACT;IACF;IAEA;;;;;GAKC,GACD,SAAS,UAAU,CAAC;QAClB,IAAI,EAAE,KAAK,IAAI,CAAA,GAAA,mJAAA,CAAA,YAAS,AAAD,EAAE,EAAE,KAAK,GAAG;YACjC,IAAI,SAAS,EAAE,KAAK;YACpB,OAAO,KAAK,GAAG;YACf,SAAS,OAAO,GAAG,CAAC,MAAM,IAAI,oBAAoB;YAClD,OAAO,KAAK,GAAG,aAAa,EAAE,KAAK,GAAG,oBAAoB;YAC1D,OAAO;QACT,OAAO;YACL,IAAI,SAAS,WAAW,EAAE,KAAK;YAC/B,IAAI,QAAQ;gBACV,EAAE,KAAK,GAAG,WAAW,EAAE,KAAK;YAC9B;YAEA,0CAA0C;YAC1C,IAAI;YACJ,IAAI,CAAA,GAAA,mJAAA,CAAA,cAAW,AAAD,EAAE,EAAE,KAAK,GAAG;gBACxB,QAAQ,IAAI,UAAU,GAAG,GAAG,CAAC;YAC/B,OAAO,IAAI,CAAA,GAAA,mJAAA,CAAA,aAAU,AAAD,EAAE,EAAE,KAAK,GAAG;gBAC9B,QAAQ,IAAI,SAAS,GAAG;YAC1B,OAAO;gBACL,QAAQ,IAAI;YACd;YACA,IAAI,UAAU,EAAE,GAAG,CAAC;YACpB,IAAI,QAAQ;gBACV,QAAQ,KAAK,GAAG,WAAW,QAAQ,KAAK;YAC1C;YACA,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 453, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/ceil.js"],"sourcesContent":["import Decimal from 'decimal.js';\nimport { factory } from '../../utils/factory.js';\nimport { deepMap } from '../../utils/collection.js';\nimport { nearlyEqual } from '../../utils/number.js';\nimport { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatAlgo12xSfs } from '../../type/matrix/utils/matAlgo12xSfs.js';\nimport { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js';\nvar name = 'ceil';\nvar dependencies = ['typed', 'config', 'round', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix'];\nexport var createCeilNumber = /* #__PURE__ */factory(name, ['typed', 'config', 'round'], _ref => {\n  var {\n    typed,\n    config,\n    round\n  } = _ref;\n  return typed(name, {\n    number: function number(x) {\n      if (nearlyEqual(x, round(x), config.relTol, config.absTol)) {\n        return round(x);\n      } else {\n        return Math.ceil(x);\n      }\n    },\n    'number, number': function number_number(x, n) {\n      if (nearlyEqual(x, round(x, n), config.relTol, config.absTol)) {\n        return round(x, n);\n      } else {\n        var [number, exponent] = \"\".concat(x, \"e\").split('e');\n        var result = Math.ceil(Number(\"\".concat(number, \"e\").concat(Number(exponent) + n)));\n        [number, exponent] = \"\".concat(result, \"e\").split('e');\n        return Number(\"\".concat(number, \"e\").concat(Number(exponent) - n));\n      }\n    }\n  });\n});\nexport var createCeil = /* #__PURE__ */factory(name, dependencies, _ref2 => {\n  var {\n    typed,\n    config,\n    round,\n    matrix,\n    equalScalar,\n    zeros,\n    DenseMatrix\n  } = _ref2;\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matAlgo12xSfs = createMatAlgo12xSfs({\n    typed,\n    DenseMatrix\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n  var ceilNumber = createCeilNumber({\n    typed,\n    config,\n    round\n  });\n  /**\n   * Round a value towards plus infinity\n   * If `x` is complex, both real and imaginary part are rounded towards plus infinity.\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.ceil(x)\n   *    math.ceil(x, n)\n   *\n   * Examples:\n   *\n   *    math.ceil(3.2)               // returns number 4\n   *    math.ceil(3.8)               // returns number 4\n   *    math.ceil(-4.2)              // returns number -4\n   *    math.ceil(-4.7)              // returns number -4\n   *\n   *    math.ceil(3.212, 2)          // returns number 3.22\n   *    math.ceil(3.288, 2)          // returns number 3.29\n   *    math.ceil(-4.212, 2)         // returns number -4.21\n   *    math.ceil(-4.782, 2)         // returns number -4.78\n   *\n   *    const c = math.complex(3.24, -2.71)\n   *    math.ceil(c)                 // returns Complex 4 - 2i\n   *    math.ceil(c, 1)              // returns Complex 3.3 - 2.7i\n   *\n   *    math.ceil([3.2, 3.8, -4.7])  // returns Array [4, 4, -4]\n   *    math.ceil([3.21, 3.82, -4.71], 1)  // returns Array [3.3, 3.9, -4.7]\n   *\n   * See also:\n   *\n   *    floor, fix, round\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded\n   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals\n   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value\n   */\n  return typed('ceil', {\n    number: ceilNumber.signatures.number,\n    'number,number': ceilNumber.signatures['number,number'],\n    Complex: function Complex(x) {\n      return x.ceil();\n    },\n    'Complex, number': function Complex_number(x, n) {\n      return x.ceil(n);\n    },\n    'Complex, BigNumber': function Complex_BigNumber(x, n) {\n      return x.ceil(n.toNumber());\n    },\n    BigNumber: function BigNumber(x) {\n      if (bigNearlyEqual(x, round(x), config.relTol, config.absTol)) {\n        return round(x);\n      } else {\n        return x.ceil();\n      }\n    },\n    'BigNumber, BigNumber': function BigNumber_BigNumber(x, n) {\n      if (bigNearlyEqual(x, round(x, n), config.relTol, config.absTol)) {\n        return round(x, n);\n      } else {\n        return x.toDecimalPlaces(n.toNumber(), Decimal.ROUND_CEIL);\n      }\n    },\n    Fraction: function Fraction(x) {\n      return x.ceil();\n    },\n    'Fraction, number': function Fraction_number(x, n) {\n      return x.ceil(n);\n    },\n    'Fraction, BigNumber': function Fraction_BigNumber(x, n) {\n      return x.ceil(n.toNumber());\n    },\n    'Array | Matrix': typed.referToSelf(self => x => {\n      // deep map collection, skip zeros since ceil(0) = 0\n      return deepMap(x, self, true);\n    }),\n    'Array, number | BigNumber': typed.referToSelf(self => (x, n) => {\n      // deep map collection, skip zeros since ceil(0) = 0\n      return deepMap(x, i => self(i, n), true);\n    }),\n    'SparseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {\n      return matAlgo11xS0s(x, y, self, false);\n    }),\n    'DenseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {\n      return matAlgo14xDs(x, y, self, false);\n    }),\n    'number | Complex | Fraction | BigNumber, Array': typed.referToSelf(self => (x, y) => {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(y), x, self, true).valueOf();\n    }),\n    'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf(self => (x, y) => {\n      if (equalScalar(x, 0)) return zeros(y.size(), y.storage());\n      if (y.storage() === 'dense') {\n        return matAlgo14xDs(y, x, self, true);\n      }\n      return matAlgo12xSfs(y, x, self, true);\n    })\n  });\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 631, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/cube.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { cubeNumber } from '../../plain/number/index.js';\nvar name = 'cube';\nvar dependencies = ['typed'];\nexport var createCube = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Compute the cube of a value, `x * x * x`.\n   * To avoid confusion with `pow(M,3)`, this function does not apply to matrices.\n   * If you wish to cube every entry of a matrix, see the examples.\n   *\n   * Syntax:\n   *\n   *    math.cube(x)\n   *\n   * Examples:\n   *\n   *    math.cube(2)            // returns number 8\n   *    math.pow(2, 3)          // returns number 8\n   *    math.cube(4)            // returns number 64\n   *    4 * 4 * 4               // returns number 64\n   *\n   *    math.map([1, 2, 3, 4], math.cube) // returns Array [1, 8, 27, 64]\n   *\n   * See also:\n   *\n   *    multiply, square, pow, cbrt\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x  Number for which to calculate the cube\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit} Cube of x\n   */\n  return typed(name, {\n    number: cubeNumber,\n    Complex: function Complex(x) {\n      return x.mul(x).mul(x); // Is faster than pow(x, 3)\n    },\n    BigNumber: function BigNumber(x) {\n      return x.times(x).times(x);\n    },\n    bigint: function bigint(x) {\n      return x * x * x;\n    },\n    Fraction: function Fraction(x) {\n      return x.pow(3); // Is faster than mul()mul()mul()\n    },\n    Unit: function Unit(x) {\n      return x.pow(3);\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;GAwBC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,qKAAA,CAAA,aAAU;QAClB,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,2BAA2B;QACrD;QACA,WAAW,SAAS,UAAU,CAAC;YAC7B,OAAO,EAAE,KAAK,CAAC,GAAG,KAAK,CAAC;QAC1B;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,IAAI,IAAI;QACjB;QACA,UAAU,SAAS,SAAS,CAAC;YAC3B,OAAO,EAAE,GAAG,CAAC,IAAI,iCAAiC;QACpD;QACA,MAAM,SAAS,KAAK,CAAC;YACnB,OAAO,EAAE,GAAG,CAAC;QACf;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 693, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/exp.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { expNumber } from '../../plain/number/index.js';\nvar name = 'exp';\nvar dependencies = ['typed'];\nexport var createExp = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Calculate the exponential of a value.\n   * For matrices, if you want the matrix exponential of square matrix, use\n   * the `expm` function; if you want to take the exponential of each element,\n   * see the examples.\n   *\n   * Syntax:\n   *\n   *    math.exp(x)\n   *\n   * Examples:\n   *\n   *    math.exp(2)                  // returns number 7.3890560989306495\n   *    math.pow(math.e, 2)          // returns number 7.3890560989306495\n   *    math.log(math.exp(2))        // returns number 2\n   *\n   *    math.map([1, 2, 3], math.exp)\n   *    // returns Array [\n   *    //   2.718281828459045,\n   *    //   7.3890560989306495,\n   *    //   20.085536923187668\n   *    // ]\n   *\n   * See also:\n   *\n   *    expm1, expm, log, pow\n   *\n   * @param {number | BigNumber | Complex} x  A number to exponentiate\n   * @return {number | BigNumber | Complex} Exponential of `x`\n   */\n  return typed(name, {\n    number: expNumber,\n    Complex: function Complex(x) {\n      return x.exp();\n    },\n    BigNumber: function BigNumber(x) {\n      return x.exp();\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,YAAY,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAChE,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,qKAAA,CAAA,YAAS;QACjB,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,EAAE,GAAG;QACd;QACA,WAAW,SAAS,UAAU,CAAC;YAC7B,OAAO,EAAE,GAAG;QACd;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 751, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/expm1.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { expm1Number } from '../../plain/number/index.js';\nvar name = 'expm1';\nvar dependencies = ['typed', 'Complex'];\nexport var createExpm1 = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    Complex: _Complex\n  } = _ref;\n  /**\n   * Calculate the value of subtracting 1 from the exponential value.\n   * This function is more accurate than `math.exp(x)-1` when `x` is near 0\n   * To avoid ambiguity with the matrix exponential `expm`, this function\n   * does not operate on matrices; if you wish to apply it elementwise, see\n   * the examples.\n   *\n   * Syntax:\n   *\n   *    math.expm1(x)\n   *\n   * Examples:\n   *\n   *    math.expm1(2)                      // returns number 6.38905609893065\n   *    math.pow(math.e, 2) - 1            // returns number 6.3890560989306495\n   *    math.expm1(1e-8)                   // returns number 1.0000000050000001e-8\n   *    math.exp(1e-8) - 1                 // returns number 9.9999999392253e-9\n   *    math.log(math.expm1(2) + 1)        // returns number 2\n   *\n   *    math.map([1, 2, 3], math.expm1)\n   *    // returns Array [\n   *    //   1.718281828459045,\n   *    //   6.3890560989306495,\n   *    //   19.085536923187668\n   *    // ]\n   *\n   * See also:\n   *\n   *    exp, expm, log, pow\n   *\n   * @param {number | BigNumber | Complex} x  The number to exponentiate\n   * @return {number | BigNumber | Complex} Exponential of `x`, minus one\n   */\n  return typed(name, {\n    number: expm1Number,\n    Complex: function Complex(x) {\n      var r = Math.exp(x.re);\n      return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));\n    },\n    BigNumber: function BigNumber(x) {\n      return x.exp().minus(1);\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;CAAU;AAChC,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,KAAK,EACL,SAAS,QAAQ,EAClB,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,qKAAA,CAAA,cAAW;QACnB,SAAS,SAAS,QAAQ,CAAC;YACzB,IAAI,IAAI,KAAK,GAAG,CAAC,EAAE,EAAE;YACrB,OAAO,IAAI,SAAS,IAAI,KAAK,GAAG,CAAC,EAAE,EAAE,IAAI,GAAG,IAAI,KAAK,GAAG,CAAC,EAAE,EAAE;QAC/D;QACA,WAAW,SAAS,UAAU,CAAC;YAC7B,OAAO,EAAE,GAAG,GAAG,KAAK,CAAC;QACvB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 814, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/fix.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { deepMap } from '../../utils/collection.js';\nimport { createMatAlgo12xSfs } from '../../type/matrix/utils/matAlgo12xSfs.js';\nimport { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js';\nvar name = 'fix';\nvar dependencies = ['typed', 'Complex', 'matrix', 'ceil', 'floor', 'equalScalar', 'zeros', 'DenseMatrix'];\nexport var createFixNumber = /* #__PURE__ */factory(name, ['typed', 'ceil', 'floor'], _ref => {\n  var {\n    typed,\n    ceil,\n    floor\n  } = _ref;\n  return typed(name, {\n    number: function number(x) {\n      return x > 0 ? floor(x) : ceil(x);\n    },\n    'number, number': function number_number(x, n) {\n      return x > 0 ? floor(x, n) : ceil(x, n);\n    }\n  });\n});\nexport var createFix = /* #__PURE__ */factory(name, dependencies, _ref2 => {\n  var {\n    typed,\n    Complex: _Complex,\n    matrix,\n    ceil,\n    floor,\n    equalScalar,\n    zeros,\n    DenseMatrix\n  } = _ref2;\n  var matAlgo12xSfs = createMatAlgo12xSfs({\n    typed,\n    DenseMatrix\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n  var fixNumber = createFixNumber({\n    typed,\n    ceil,\n    floor\n  });\n  /**\n   * Round a value towards zero.\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.fix(x)\n   *    math.fix(x,n)\n   *\n   * Examples:\n   *\n   *    math.fix(3.2)                // returns number 3\n   *    math.fix(3.8)                // returns number 3\n   *    math.fix(-4.2)               // returns number -4\n   *    math.fix(-4.7)               // returns number -4\n   *\n   *    math.fix(3.12, 1)                // returns number 3.1\n   *    math.fix(3.18, 1)                // returns number 3.1\n   *    math.fix(-4.12, 1)               // returns number -4.1\n   *    math.fix(-4.17, 1)               // returns number -4.1\n   *\n   *    const c = math.complex(3.22, -2.78)\n   *    math.fix(c)                  // returns Complex 3 - 2i\n   *    math.fix(c, 1)               // returns Complex 3.2 -2.7i\n   *\n   *    math.fix([3.2, 3.8, -4.7])      // returns Array [3, 3, -4]\n   *    math.fix([3.2, 3.8, -4.7], 1)   // returns Array [3.2, 3.8, -4.7]\n   *\n   * See also:\n   *\n   *    ceil, floor, round\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x    Number to be rounded\n   * @param  {number | BigNumber | Array} [n=0]                             Number of decimals\n   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}     Rounded value\n   */\n  return typed('fix', {\n    number: fixNumber.signatures.number,\n    'number, number | BigNumber': fixNumber.signatures['number,number'],\n    Complex: function Complex(x) {\n      return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));\n    },\n    'Complex, number': function Complex_number(x, n) {\n      return new _Complex(x.re > 0 ? floor(x.re, n) : ceil(x.re, n), x.im > 0 ? floor(x.im, n) : ceil(x.im, n));\n    },\n    'Complex, BigNumber': function Complex_BigNumber(x, bn) {\n      var n = bn.toNumber();\n      return new _Complex(x.re > 0 ? floor(x.re, n) : ceil(x.re, n), x.im > 0 ? floor(x.im, n) : ceil(x.im, n));\n    },\n    BigNumber: function BigNumber(x) {\n      return x.isNegative() ? ceil(x) : floor(x);\n    },\n    'BigNumber, number | BigNumber': function BigNumber_number__BigNumber(x, n) {\n      return x.isNegative() ? ceil(x, n) : floor(x, n);\n    },\n    Fraction: function Fraction(x) {\n      return x.s < 0 ? x.ceil() : x.floor();\n    },\n    'Fraction, number | BigNumber': function Fraction_number__BigNumber(x, n) {\n      return x.s < 0 ? ceil(x, n) : floor(x, n);\n    },\n    'Array | Matrix': typed.referToSelf(self => x => {\n      // deep map collection, skip zeros since fix(0) = 0\n      return deepMap(x, self, true);\n    }),\n    'Array | Matrix, number | BigNumber': typed.referToSelf(self => (x, n) => {\n      // deep map collection, skip zeros since fix(0) = 0\n      return deepMap(x, i => self(i, n), true);\n    }),\n    'number | Complex | Fraction | BigNumber, Array': typed.referToSelf(self => (x, y) => {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(y), x, self, true).valueOf();\n    }),\n    'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf(self => (x, y) => {\n      if (equalScalar(x, 0)) return zeros(y.size(), y.storage());\n      if (y.storage() === 'dense') {\n        return matAlgo14xDs(y, x, self, true);\n      }\n      return matAlgo12xSfs(y, x, self, true);\n    })\n  });\n});"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAW;IAAU;IAAQ;IAAS;IAAe;IAAS;CAAc;AAClG,IAAI,kBAAkB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM;IAAC;IAAS;IAAQ;CAAQ,EAAE,CAAA;IACpF,IAAI,EACF,KAAK,EACL,IAAI,EACJ,KAAK,EACN,GAAG;IACJ,OAAO,MAAM,MAAM;QACjB,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,IAAI,IAAI,MAAM,KAAK,KAAK;QACjC;QACA,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,OAAO,IAAI,IAAI,MAAM,GAAG,KAAK,KAAK,GAAG;QACvC;IACF;AACF;AACO,IAAI,YAAY,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAChE,IAAI,EACF,KAAK,EACL,SAAS,QAAQ,EACjB,MAAM,EACN,IAAI,EACJ,KAAK,EACL,WAAW,EACX,KAAK,EACL,WAAW,EACZ,GAAG;IACJ,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,eAAe,CAAA,GAAA,+KAAA,CAAA,qBAAkB,AAAD,EAAE;QACpC;IACF;IACA,IAAI,YAAY,gBAAgB;QAC9B;QACA;QACA;IACF;IACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmCC,GACD,OAAO,MAAM,OAAO;QAClB,QAAQ,UAAU,UAAU,CAAC,MAAM;QACnC,8BAA8B,UAAU,UAAU,CAAC,gBAAgB;QACnE,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,IAAI,SAAS,EAAE,EAAE,GAAG,IAAI,KAAK,KAAK,CAAC,EAAE,EAAE,IAAI,KAAK,IAAI,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,IAAI,KAAK,KAAK,CAAC,EAAE,EAAE,IAAI,KAAK,IAAI,CAAC,EAAE,EAAE;QACjH;QACA,mBAAmB,SAAS,eAAe,CAAC,EAAE,CAAC;YAC7C,OAAO,IAAI,SAAS,EAAE,EAAE,GAAG,IAAI,MAAM,EAAE,EAAE,EAAE,KAAK,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,GAAG,IAAI,MAAM,EAAE,EAAE,EAAE,KAAK,KAAK,EAAE,EAAE,EAAE;QACxG;QACA,sBAAsB,SAAS,kBAAkB,CAAC,EAAE,EAAE;YACpD,IAAI,IAAI,GAAG,QAAQ;YACnB,OAAO,IAAI,SAAS,EAAE,EAAE,GAAG,IAAI,MAAM,EAAE,EAAE,EAAE,KAAK,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,GAAG,IAAI,MAAM,EAAE,EAAE,EAAE,KAAK,KAAK,EAAE,EAAE,EAAE;QACxG;QACA,WAAW,SAAS,UAAU,CAAC;YAC7B,OAAO,EAAE,UAAU,KAAK,KAAK,KAAK,MAAM;QAC1C;QACA,iCAAiC,SAAS,4BAA4B,CAAC,EAAE,CAAC;YACxE,OAAO,EAAE,UAAU,KAAK,KAAK,GAAG,KAAK,MAAM,GAAG;QAChD;QACA,UAAU,SAAS,SAAS,CAAC;YAC3B,OAAO,EAAE,CAAC,GAAG,IAAI,EAAE,IAAI,KAAK,EAAE,KAAK;QACrC;QACA,gCAAgC,SAAS,2BAA2B,CAAC,EAAE,CAAC;YACtE,OAAO,EAAE,CAAC,GAAG,IAAI,KAAK,GAAG,KAAK,MAAM,GAAG;QACzC;QACA,kBAAkB,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAA;gBAC1C,mDAAmD;gBACnD,OAAO,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,GAAG,MAAM;YAC1B;QACA,sCAAsC,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAC,GAAG;gBAClE,mDAAmD;gBACnD,OAAO,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,GAAG,CAAA,IAAK,KAAK,GAAG,IAAI;YACrC;QACA,kDAAkD,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAC,GAAG;gBAC9E,4BAA4B;gBAC5B,OAAO,aAAa,OAAO,IAAI,GAAG,MAAM,MAAM,OAAO;YACvD;QACA,mDAAmD,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAC,GAAG;gBAC/E,IAAI,YAAY,GAAG,IAAI,OAAO,MAAM,EAAE,IAAI,IAAI,EAAE,OAAO;gBACvD,IAAI,EAAE,OAAO,OAAO,SAAS;oBAC3B,OAAO,aAAa,GAAG,GAAG,MAAM;gBAClC;gBACA,OAAO,cAAc,GAAG,GAAG,MAAM;YACnC;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 953, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/floor.js"],"sourcesContent":["import Decimal from 'decimal.js';\nimport { factory } from '../../utils/factory.js';\nimport { deepMap } from '../../utils/collection.js';\nimport { nearlyEqual } from '../../utils/number.js';\nimport { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatAlgo12xSfs } from '../../type/matrix/utils/matAlgo12xSfs.js';\nimport { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js';\nvar name = 'floor';\nvar dependencies = ['typed', 'config', 'round', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix'];\nexport var createFloorNumber = /* #__PURE__ */factory(name, ['typed', 'config', 'round'], _ref => {\n  var {\n    typed,\n    config,\n    round\n  } = _ref;\n  return typed(name, {\n    number: function number(x) {\n      if (nearlyEqual(x, round(x), config.relTol, config.absTol)) {\n        return round(x);\n      } else {\n        return Math.floor(x);\n      }\n    },\n    'number, number': function number_number(x, n) {\n      if (nearlyEqual(x, round(x, n), config.relTol, config.absTol)) {\n        return round(x, n);\n      } else {\n        var [number, exponent] = \"\".concat(x, \"e\").split('e');\n        var result = Math.floor(Number(\"\".concat(number, \"e\").concat(Number(exponent) + n)));\n        [number, exponent] = \"\".concat(result, \"e\").split('e');\n        return Number(\"\".concat(number, \"e\").concat(Number(exponent) - n));\n      }\n    }\n  });\n});\nexport var createFloor = /* #__PURE__ */factory(name, dependencies, _ref2 => {\n  var {\n    typed,\n    config,\n    round,\n    matrix,\n    equalScalar,\n    zeros,\n    DenseMatrix\n  } = _ref2;\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matAlgo12xSfs = createMatAlgo12xSfs({\n    typed,\n    DenseMatrix\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n  var floorNumber = createFloorNumber({\n    typed,\n    config,\n    round\n  });\n  /**\n   * Round a value towards minus infinity.\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.floor(x)\n   *    math.floor(x, n)\n   *\n   * Examples:\n   *\n   *    math.floor(3.2)              // returns number 3\n   *    math.floor(3.8)              // returns number 3\n   *    math.floor(-4.2)             // returns number -5\n   *    math.floor(-4.7)             // returns number -5\n   *\n   *    math.floor(3.212, 2)          // returns number 3.21\n   *    math.floor(3.288, 2)          // returns number 3.28\n   *    math.floor(-4.212, 2)         // returns number -4.22\n   *    math.floor(-4.782, 2)         // returns number -4.79\n   *\n   *    const c = math.complex(3.24, -2.71)\n   *    math.floor(c)                 // returns Complex 3 - 3i\n   *    math.floor(c, 1)              // returns Complex 3.2 -2.8i\n   *\n   *    math.floor([3.2, 3.8, -4.7])       // returns Array [3, 3, -5]\n   *    math.floor([3.21, 3.82, -4.71], 1)  // returns Array [3.2, 3.8, -4.8]\n   *\n   *    math.floor(math.tau, [2, 3])  // returns Array [6.28, 6.283]\n   *\n   *    // Note that floor(array, array) currently not implemented.\n   *\n   * See also:\n   *\n   *    ceil, fix, round\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded\n   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals\n   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value\n   */\n  return typed('floor', {\n    number: floorNumber.signatures.number,\n    'number,number': floorNumber.signatures['number,number'],\n    Complex: function Complex(x) {\n      return x.floor();\n    },\n    'Complex, number': function Complex_number(x, n) {\n      return x.floor(n);\n    },\n    'Complex, BigNumber': function Complex_BigNumber(x, n) {\n      return x.floor(n.toNumber());\n    },\n    BigNumber: function BigNumber(x) {\n      if (bigNearlyEqual(x, round(x), config.relTol, config.absTol)) {\n        return round(x);\n      } else {\n        return x.floor();\n      }\n    },\n    'BigNumber, BigNumber': function BigNumber_BigNumber(x, n) {\n      if (bigNearlyEqual(x, round(x, n), config.relTol, config.absTol)) {\n        return round(x, n);\n      } else {\n        return x.toDecimalPlaces(n.toNumber(), Decimal.ROUND_FLOOR);\n      }\n    },\n    Fraction: function Fraction(x) {\n      return x.floor();\n    },\n    'Fraction, number': function Fraction_number(x, n) {\n      return x.floor(n);\n    },\n    'Fraction, BigNumber': function Fraction_BigNumber(x, n) {\n      return x.floor(n.toNumber());\n    },\n    'Array | Matrix': typed.referToSelf(self => x => {\n      // deep map collection, skip zeros since floor(0) = 0\n      return deepMap(x, self, true);\n    }),\n    'Array, number | BigNumber': typed.referToSelf(self => (x, n) => {\n      // deep map collection, skip zeros since ceil(0) = 0\n      return deepMap(x, i => self(i, n), true);\n    }),\n    'SparseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {\n      return matAlgo11xS0s(x, y, self, false);\n    }),\n    'DenseMatrix, number | BigNumber': typed.referToSelf(self => (x, y) => {\n      return matAlgo14xDs(x, y, self, false);\n    }),\n    'number | Complex | Fraction | BigNumber, Array': typed.referToSelf(self => (x, y) => {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(y), x, self, true).valueOf();\n    }),\n    'number | Complex | Fraction | BigNumber, Matrix': typed.referToSelf(self => (x, y) => {\n      if (equalScalar(x, 0)) return zeros(y.size(), y.storage());\n      if (y.storage() === 'dense') {\n        return matAlgo14xDs(y, x, self, true);\n      }\n      return matAlgo12xSfs(y, x, self, true);\n    })\n  });\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1134, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/mod.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { createFloor } from './floor.js';\nimport { createMatAlgo02xDS0 } from '../../type/matrix/utils/matAlgo02xDS0.js';\nimport { createMatAlgo03xDSf } from '../../type/matrix/utils/matAlgo03xDSf.js';\nimport { createMatAlgo05xSfSf } from '../../type/matrix/utils/matAlgo05xSfSf.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatAlgo12xSfs } from '../../type/matrix/utils/matAlgo12xSfs.js';\nimport { createMatrixAlgorithmSuite } from '../../type/matrix/utils/matrixAlgorithmSuite.js';\nvar name = 'mod';\nvar dependencies = ['typed', 'config', 'round', 'matrix', 'equalScalar', 'zeros', 'DenseMatrix', 'concat'];\nexport var createMod = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    round,\n    matrix,\n    equalScalar,\n    zeros,\n    DenseMatrix,\n    concat\n  } = _ref;\n  var floor = createFloor({\n    typed,\n    config,\n    round,\n    matrix,\n    equalScalar,\n    zeros,\n    DenseMatrix\n  });\n  var matAlgo02xDS0 = createMatAlgo02xDS0({\n    typed,\n    equalScalar\n  });\n  var matAlgo03xDSf = createMatAlgo03xDSf({\n    typed\n  });\n  var matAlgo05xSfSf = createMatAlgo05xSfSf({\n    typed,\n    equalScalar\n  });\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matAlgo12xSfs = createMatAlgo12xSfs({\n    typed,\n    DenseMatrix\n  });\n  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({\n    typed,\n    matrix,\n    concat\n  });\n\n  /**\n   * Calculates the modulus, the remainder of an integer division.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * The modulus is defined as:\n   *\n   *     x - y * floor(x / y)\n   *\n   * See https://en.wikipedia.org/wiki/Modulo_operation.\n   *\n   * Syntax:\n   *\n   *    math.mod(x, y)\n   *\n   * Examples:\n   *\n   *    math.mod(8, 3)                // returns 2\n   *    math.mod(11, 2)               // returns 1\n   *\n   *    function isOdd(x) {\n   *      return math.mod(x, 2) != 0\n   *    }\n   *\n   *    isOdd(2)                      // returns false\n   *    isOdd(3)                      // returns true\n   *\n   * See also:\n   *\n   *    divide\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Array | Matrix} x Dividend\n   * @param  {number | BigNumber | bigint | Fraction | Array | Matrix} y Divisor\n   * @return {number | BigNumber | bigint | Fraction | Array | Matrix} Returns the remainder of `x` divided by `y`.\n   */\n  return typed(name, {\n    'number, number': _modNumber,\n    'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {\n      return y.isZero() ? x : x.sub(y.mul(floor(x.div(y))));\n    },\n    'bigint, bigint': function bigint_bigint(x, y) {\n      if (y === 0n) {\n        return x;\n      }\n      if (x < 0) {\n        var m = x % y;\n        return m === 0n ? m : m + y;\n      }\n      return x % y;\n    },\n    'Fraction, Fraction': function Fraction_Fraction(x, y) {\n      return y.equals(0) ? x : x.sub(y.mul(floor(x.div(y))));\n    }\n  }, matrixAlgorithmSuite({\n    SS: matAlgo05xSfSf,\n    DS: matAlgo03xDSf,\n    SD: matAlgo02xDS0,\n    Ss: matAlgo11xS0s,\n    sS: matAlgo12xSfs\n  }));\n\n  /**\n  * Calculate the modulus of two numbers\n  * @param {number} x\n  * @param {number} y\n  * @returns {number} res\n  * @private\n  */\n  function _modNumber(x, y) {\n    // We don't use JavaScript's % operator here as this doesn't work\n    // correctly for x < 0 and x === 0\n    // see https://en.wikipedia.org/wiki/Modulo_operation\n\n    // We use mathjs floor to handle errors associated with\n    // precision float approximation\n    return y === 0 ? x : x - y * floor(x / y);\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAS;IAAU;IAAe;IAAS;IAAe;CAAS;AACnG,IAAI,YAAY,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAChE,IAAI,EACF,KAAK,EACL,MAAM,EACN,KAAK,EACL,MAAM,EACN,WAAW,EACX,KAAK,EACL,WAAW,EACX,MAAM,EACP,GAAG;IACJ,IAAI,QAAQ,CAAA,GAAA,uKAAA,CAAA,cAAW,AAAD,EAAE;QACtB;QACA;QACA;QACA;QACA;QACA;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;IACF;IACA,IAAI,iBAAiB,CAAA,GAAA,iLAAA,CAAA,uBAAoB,AAAD,EAAE;QACxC;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,uBAAuB,CAAA,GAAA,uLAAA,CAAA,6BAA0B,AAAD,EAAE;QACpD;QACA;QACA;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkCC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB;QAClB,wBAAwB,SAAS,oBAAoB,CAAC,EAAE,CAAC;YACvD,OAAO,EAAE,MAAM,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC;QAClD;QACA,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,IAAI,MAAM,EAAE,EAAE;gBACZ,OAAO;YACT;YACA,IAAI,IAAI,GAAG;gBACT,IAAI,IAAI,IAAI;gBACZ,OAAO,MAAM,EAAE,GAAG,IAAI,IAAI;YAC5B;YACA,OAAO,IAAI;QACb;QACA,sBAAsB,SAAS,kBAAkB,CAAC,EAAE,CAAC;YACnD,OAAO,EAAE,MAAM,CAAC,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC;QACnD;IACF,GAAG,qBAAqB;QACtB,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;IACN;;IAEA;;;;;;EAMA,GACA,SAAS,WAAW,CAAC,EAAE,CAAC;QACtB,iEAAiE;QACjE,kCAAkC;QAClC,qDAAqD;QAErD,uDAAuD;QACvD,gCAAgC;QAChC,OAAO,MAAM,IAAI,IAAI,IAAI,IAAI,MAAM,IAAI;IACzC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1280, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/gcd.js"],"sourcesContent":["import { isInteger } from '../../utils/number.js';\nimport { factory } from '../../utils/factory.js';\nimport { createMod } from './mod.js';\nimport { createMatAlgo01xDSid } from '../../type/matrix/utils/matAlgo01xDSid.js';\nimport { createMatAlgo04xSidSid } from '../../type/matrix/utils/matAlgo04xSidSid.js';\nimport { createMatAlgo10xSids } from '../../type/matrix/utils/matAlgo10xSids.js';\nimport { createMatrixAlgorithmSuite } from '../../type/matrix/utils/matrixAlgorithmSuite.js';\nimport { ArgumentsError } from '../../error/ArgumentsError.js';\nvar name = 'gcd';\nvar dependencies = ['typed', 'config', 'round', 'matrix', 'equalScalar', 'zeros', 'BigNumber', 'DenseMatrix', 'concat'];\nvar gcdTypes = 'number | BigNumber | Fraction | Matrix | Array';\nvar gcdManyTypesSignature = \"\".concat(gcdTypes, \", \").concat(gcdTypes, \", ...\").concat(gcdTypes);\nfunction is1d(array) {\n  return !array.some(element => Array.isArray(element));\n}\nexport var createGcd = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    config,\n    round,\n    equalScalar,\n    zeros,\n    BigNumber,\n    DenseMatrix,\n    concat\n  } = _ref;\n  var mod = createMod({\n    typed,\n    config,\n    round,\n    matrix,\n    equalScalar,\n    zeros,\n    DenseMatrix,\n    concat\n  });\n  var matAlgo01xDSid = createMatAlgo01xDSid({\n    typed\n  });\n  var matAlgo04xSidSid = createMatAlgo04xSidSid({\n    typed,\n    equalScalar\n  });\n  var matAlgo10xSids = createMatAlgo10xSids({\n    typed,\n    DenseMatrix\n  });\n  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({\n    typed,\n    matrix,\n    concat\n  });\n\n  /**\n   * Calculate the greatest common divisor for two or more values or arrays.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.gcd(a, b)\n   *    math.gcd(a, b, c, ...)\n   *\n   * Examples:\n   *\n   *    math.gcd(8, 12)              // returns 4\n   *    math.gcd(-4, 6)              // returns 2\n   *    math.gcd(25, 15, -10)        // returns 5\n   *\n   *    math.gcd([8, -4], [12, 6])   // returns [4, 2]\n   *\n   * See also:\n   *\n   *    lcm, xgcd\n   *\n   * @param {... number | BigNumber | Fraction | Array | Matrix} args  Two or more integer numbers\n   * @return {number | BigNumber | Fraction | Array | Matrix}                           The greatest common divisor\n   */\n  return typed(name, {\n    'number, number': _gcdNumber,\n    'BigNumber, BigNumber': _gcdBigNumber,\n    'Fraction, Fraction': (x, y) => x.gcd(y)\n  }, matrixAlgorithmSuite({\n    SS: matAlgo04xSidSid,\n    DS: matAlgo01xDSid,\n    Ss: matAlgo10xSids\n  }), {\n    [gcdManyTypesSignature]: typed.referToSelf(self => (a, b, args) => {\n      var res = self(a, b);\n      for (var i = 0; i < args.length; i++) {\n        res = self(res, args[i]);\n      }\n      return res;\n    }),\n    Array: typed.referToSelf(self => array => {\n      if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {\n        return self(...array[0]);\n      }\n      if (is1d(array)) {\n        return self(...array);\n      }\n      throw new ArgumentsError('gcd() supports only 1d matrices!');\n    }),\n    Matrix: typed.referToSelf(self => matrix => {\n      return self(matrix.toArray());\n    })\n  });\n\n  /**\n  * Calculate gcd for numbers\n  * @param {number} a\n  * @param {number} b\n  * @returns {number} Returns the greatest common denominator of a and b\n  * @private\n  */\n  function _gcdNumber(a, b) {\n    if (!isInteger(a) || !isInteger(b)) {\n      throw new Error('Parameters in function gcd must be integer numbers');\n    }\n\n    // https://en.wikipedia.org/wiki/Euclidean_algorithm\n    var r;\n    while (b !== 0) {\n      r = mod(a, b);\n      a = b;\n      b = r;\n    }\n    return a < 0 ? -a : a;\n  }\n\n  /**\n   * Calculate gcd for BigNumbers\n   * @param {BigNumber} a\n   * @param {BigNumber} b\n   * @returns {BigNumber} Returns greatest common denominator of a and b\n   * @private\n   */\n  function _gcdBigNumber(a, b) {\n    if (!a.isInt() || !b.isInt()) {\n      throw new Error('Parameters in function gcd must be integer numbers');\n    }\n\n    // https://en.wikipedia.org/wiki/Euclidean_algorithm\n    var zero = new BigNumber(0);\n    while (!b.isZero()) {\n      var r = mod(a, b);\n      a = b;\n      b = r;\n    }\n    return a.lt(zero) ? a.neg() : a;\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1443, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/lcm.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { createMatAlgo02xDS0 } from '../../type/matrix/utils/matAlgo02xDS0.js';\nimport { createMatAlgo06xS0S0 } from '../../type/matrix/utils/matAlgo06xS0S0.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatrixAlgorithmSuite } from '../../type/matrix/utils/matrixAlgorithmSuite.js';\nimport { lcmNumber } from '../../plain/number/index.js';\nvar name = 'lcm';\nvar dependencies = ['typed', 'matrix', 'equalScalar', 'concat'];\nexport var createLcm = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    equalScalar,\n    concat\n  } = _ref;\n  var matAlgo02xDS0 = createMatAlgo02xDS0({\n    typed,\n    equalScalar\n  });\n  var matAlgo06xS0S0 = createMatAlgo06xS0S0({\n    typed,\n    equalScalar\n  });\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({\n    typed,\n    matrix,\n    concat\n  });\n  var lcmTypes = 'number | BigNumber | Fraction | Matrix | Array';\n  var lcmManySignature = {};\n  lcmManySignature[\"\".concat(lcmTypes, \", \").concat(lcmTypes, \", ...\").concat(lcmTypes)] = typed.referToSelf(self => (a, b, args) => {\n    var res = self(a, b);\n    for (var i = 0; i < args.length; i++) {\n      res = self(res, args[i]);\n    }\n    return res;\n  });\n\n  /**\n   * Calculate the least common multiple for two or more values or arrays.\n   *\n   * lcm is defined as:\n   *\n   *     lcm(a, b) = abs(a * b) / gcd(a, b)\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.lcm(a, b)\n   *    math.lcm(a, b, c, ...)\n   *\n   * Examples:\n   *\n   *    math.lcm(4, 6)               // returns 12\n   *    math.lcm(6, 21)              // returns 42\n   *    math.lcm(6, 21, 5)           // returns 210\n   *\n   *    math.lcm([4, 6], [6, 21])    // returns [12, 42]\n   *\n   * See also:\n   *\n   *    gcd, xgcd\n   *\n   * @param {... number | BigNumber | Array | Matrix} args  Two or more integer numbers\n   * @return {number | BigNumber | Array | Matrix}                           The least common multiple\n   */\n  return typed(name, {\n    'number, number': lcmNumber,\n    'BigNumber, BigNumber': _lcmBigNumber,\n    'Fraction, Fraction': (x, y) => x.lcm(y)\n  }, matrixAlgorithmSuite({\n    SS: matAlgo06xS0S0,\n    DS: matAlgo02xDS0,\n    Ss: matAlgo11xS0s\n  }), lcmManySignature);\n\n  /**\n   * Calculate lcm for two BigNumbers\n   * @param {BigNumber} a\n   * @param {BigNumber} b\n   * @returns {BigNumber} Returns the least common multiple of a and b\n   * @private\n   */\n  function _lcmBigNumber(a, b) {\n    if (!a.isInt() || !b.isInt()) {\n      throw new Error('Parameters in function lcm must be integer numbers');\n    }\n    if (a.isZero()) {\n      return a;\n    }\n    if (b.isZero()) {\n      return b;\n    }\n\n    // https://en.wikipedia.org/wiki/Euclidean_algorithm\n    // evaluate lcm here inline to reduce overhead\n    var prod = a.times(b);\n    while (!b.isZero()) {\n      var t = b;\n      b = a.mod(t);\n      a = t;\n    }\n    return prod.div(a).abs();\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAe;CAAS;AACxD,IAAI,YAAY,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAChE,IAAI,EACF,KAAK,EACL,MAAM,EACN,WAAW,EACX,MAAM,EACP,GAAG;IACJ,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,iBAAiB,CAAA,GAAA,iLAAA,CAAA,uBAAoB,AAAD,EAAE;QACxC;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,uBAAuB,CAAA,GAAA,uLAAA,CAAA,6BAA0B,AAAD,EAAE;QACpD;QACA;QACA;IACF;IACA,IAAI,WAAW;IACf,IAAI,mBAAmB,CAAC;IACxB,gBAAgB,CAAC,GAAG,MAAM,CAAC,UAAU,MAAM,MAAM,CAAC,UAAU,SAAS,MAAM,CAAC,UAAU,GAAG,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAC,GAAG,GAAG;YACxH,IAAI,MAAM,KAAK,GAAG;YAClB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;gBACpC,MAAM,KAAK,KAAK,IAAI,CAAC,EAAE;YACzB;YACA,OAAO;QACT;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB,qKAAA,CAAA,YAAS;QAC3B,wBAAwB;QACxB,sBAAsB,CAAC,GAAG,IAAM,EAAE,GAAG,CAAC;IACxC,GAAG,qBAAqB;QACtB,IAAI;QACJ,IAAI;QACJ,IAAI;IACN,IAAI;;IAEJ;;;;;;GAMC,GACD,SAAS,cAAc,CAAC,EAAE,CAAC;QACzB,IAAI,CAAC,EAAE,KAAK,MAAM,CAAC,EAAE,KAAK,IAAI;YAC5B,MAAM,IAAI,MAAM;QAClB;QACA,IAAI,EAAE,MAAM,IAAI;YACd,OAAO;QACT;QACA,IAAI,EAAE,MAAM,IAAI;YACd,OAAO;QACT;QAEA,oDAAoD;QACpD,8CAA8C;QAC9C,IAAI,OAAO,EAAE,KAAK,CAAC;QACnB,MAAO,CAAC,EAAE,MAAM,GAAI;YAClB,IAAI,IAAI;YACR,IAAI,EAAE,GAAG,CAAC;YACV,IAAI;QACN;QACA,OAAO,KAAK,GAAG,CAAC,GAAG,GAAG;IACxB;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1564, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/log10.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { deepMap } from '../../utils/collection.js';\nimport { log10Number } from '../../plain/number/index.js';\nvar name = 'log10';\nvar dependencies = ['typed', 'config', 'Complex'];\nexport var createLog10 = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    Complex: _Complex\n  } = _ref;\n  /**\n   * Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.log10(x)\n   *\n   * Examples:\n   *\n   *    math.log10(0.00001)            // returns -5\n   *    math.log10(10000)              // returns 4\n   *    math.log(10000) / math.log(10) // returns 4\n   *    math.pow(10, 4)                // returns 10000\n   *\n   * See also:\n   *\n   *    exp, log, log1p, log2\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x\n   *            Value for which to calculate the logarithm.\n   * @return {number | BigNumber | Complex | Array | Matrix}\n   *            Returns the 10-base logarithm of `x`\n   */\n  return typed(name, {\n    number: function number(x) {\n      if (x >= 0 || config.predictable) {\n        return log10Number(x);\n      } else {\n        // negative value -> complex value computation\n        return new _Complex(x, 0).log().div(Math.LN10);\n      }\n    },\n    Complex: function Complex(x) {\n      return new _Complex(x).log().div(Math.LN10);\n    },\n    BigNumber: function BigNumber(x) {\n      if (!x.isNegative() || config.predictable) {\n        return x.log();\n      } else {\n        // downgrade to number, return Complex valued result\n        return new _Complex(x.toNumber(), 0).log().div(Math.LN10);\n      }\n    },\n    'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;CAAU;AAC1C,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,KAAK,EACL,MAAM,EACN,SAAS,QAAQ,EAClB,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;GAwBC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,SAAS,OAAO,CAAC;YACvB,IAAI,KAAK,KAAK,OAAO,WAAW,EAAE;gBAChC,OAAO,CAAA,GAAA,qKAAA,CAAA,cAAW,AAAD,EAAE;YACrB,OAAO;gBACL,8CAA8C;gBAC9C,OAAO,IAAI,SAAS,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,KAAK,IAAI;YAC/C;QACF;QACA,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,IAAI,SAAS,GAAG,GAAG,GAAG,GAAG,CAAC,KAAK,IAAI;QAC5C;QACA,WAAW,SAAS,UAAU,CAAC;YAC7B,IAAI,CAAC,EAAE,UAAU,MAAM,OAAO,WAAW,EAAE;gBACzC,OAAO,EAAE,GAAG;YACd,OAAO;gBACL,oDAAoD;gBACpD,OAAO,IAAI,SAAS,EAAE,QAAQ,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC,KAAK,IAAI;YAC1D;QACF;QACA,kBAAkB,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAA,IAAK,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,GAAG;IAC9D;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1634, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/log2.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { deepMap } from '../../utils/collection.js';\nimport { log2Number } from '../../plain/number/index.js';\nvar name = 'log2';\nvar dependencies = ['typed', 'config', 'Complex'];\nexport var createLog2 = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    Complex\n  } = _ref;\n  /**\n   * Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.log2(x)\n   *\n   * Examples:\n   *\n   *    math.log2(0.03125)           // returns -5\n   *    math.log2(16)                // returns 4\n   *    math.log2(16) / math.log2(2) // returns 4\n   *    math.pow(2, 4)               // returns 16\n   *\n   * See also:\n   *\n   *    exp, log, log1p, log10\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x\n   *            Value for which to calculate the logarithm.\n   * @return {number | BigNumber | Complex | Array | Matrix}\n   *            Returns the 2-base logarithm of `x`\n   */\n  return typed(name, {\n    number: function number(x) {\n      if (x >= 0 || config.predictable) {\n        return log2Number(x);\n      } else {\n        // negative value -> complex value computation\n        return _log2Complex(new Complex(x, 0));\n      }\n    },\n    Complex: _log2Complex,\n    BigNumber: function BigNumber(x) {\n      if (!x.isNegative() || config.predictable) {\n        return x.log(2);\n      } else {\n        // downgrade to number, return Complex valued result\n        return _log2Complex(new Complex(x.toNumber(), 0));\n      }\n    },\n    'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self))\n  });\n\n  /**\n   * Calculate log2 for a complex value\n   * @param {Complex} x\n   * @returns {Complex}\n   * @private\n   */\n  function _log2Complex(x) {\n    var newX = Math.sqrt(x.re * x.re + x.im * x.im);\n    return new Complex(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;CAAU;AAC1C,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACL,MAAM,EACN,OAAO,EACR,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;GAwBC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,SAAS,OAAO,CAAC;YACvB,IAAI,KAAK,KAAK,OAAO,WAAW,EAAE;gBAChC,OAAO,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE;YACpB,OAAO;gBACL,8CAA8C;gBAC9C,OAAO,aAAa,IAAI,QAAQ,GAAG;YACrC;QACF;QACA,SAAS;QACT,WAAW,SAAS,UAAU,CAAC;YAC7B,IAAI,CAAC,EAAE,UAAU,MAAM,OAAO,WAAW,EAAE;gBACzC,OAAO,EAAE,GAAG,CAAC;YACf,OAAO;gBACL,oDAAoD;gBACpD,OAAO,aAAa,IAAI,QAAQ,EAAE,QAAQ,IAAI;YAChD;QACF;QACA,kBAAkB,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAA,IAAK,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,GAAG;IAC9D;;IAEA;;;;;GAKC,GACD,SAAS,aAAa,CAAC;QACrB,IAAI,OAAO,KAAK,IAAI,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE;QAC9C,OAAO,IAAI,QAAQ,KAAK,IAAI,GAAG,KAAK,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,QAAQ,KAAK,GAAG,EAAE,KAAK,KAAK,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,KAAK,GAAG;IAC/G;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1712, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { multiplyNumber } from '../../plain/number/index.js';\nvar name = 'multiplyScalar';\nvar dependencies = ['typed'];\nexport var createMultiplyScalar = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Multiply two scalar values, `x * y`.\n   * This function is meant for internal use: it is used by the public function\n   * `multiply`\n   *\n   * This function does not support collections (Array or Matrix).\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   First value to multiply\n   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Second value to multiply\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Multiplication of `x` and `y`\n   * @private\n   */\n  return typed('multiplyScalar', {\n    'number, number': multiplyNumber,\n    'Complex, Complex': function Complex_Complex(x, y) {\n      return x.mul(y);\n    },\n    'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {\n      return x.times(y);\n    },\n    'bigint, bigint': function bigint_bigint(x, y) {\n      return x * y;\n    },\n    'Fraction, Fraction': function Fraction_Fraction(x, y) {\n      return x.mul(y);\n    },\n    'number | Fraction | BigNumber | Complex, Unit': (x, y) => y.multiply(x),\n    'Unit, number | Fraction | BigNumber | Complex | Unit': (x, y) => x.multiply(y)\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,uBAAuB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAC3E,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;GAWC,GACD,OAAO,MAAM,kBAAkB;QAC7B,kBAAkB,qKAAA,CAAA,iBAAc;QAChC,oBAAoB,SAAS,gBAAgB,CAAC,EAAE,CAAC;YAC/C,OAAO,EAAE,GAAG,CAAC;QACf;QACA,wBAAwB,SAAS,oBAAoB,CAAC,EAAE,CAAC;YACvD,OAAO,EAAE,KAAK,CAAC;QACjB;QACA,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,OAAO,IAAI;QACb;QACA,sBAAsB,SAAS,kBAAkB,CAAC,EAAE,CAAC;YACnD,OAAO,EAAE,GAAG,CAAC;QACf;QACA,iDAAiD,CAAC,GAAG,IAAM,EAAE,QAAQ,CAAC;QACtE,wDAAwD,CAAC,GAAG,IAAM,EAAE,QAAQ,CAAC;IAC/E;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1760, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/multiply.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { isMatrix } from '../../utils/is.js';\nimport { arraySize } from '../../utils/array.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js';\nvar name = 'multiply';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];\nexport var createMultiply = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    addScalar,\n    multiplyScalar,\n    equalScalar,\n    dot\n  } = _ref;\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n  function _validateMatrixDimensions(size1, size2) {\n    // check left operand dimensions\n    switch (size1.length) {\n      case 1:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Vector x Vector\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');\n            }\n            break;\n          case 2:\n            // Vector x Matrix\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');\n            }\n            break;\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n        break;\n      case 2:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Matrix x Vector\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');\n            }\n            break;\n          case 2:\n            // Matrix x Matrix\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');\n            }\n            break;\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n        break;\n      default:\n        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');\n    }\n  }\n\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (N)\n   * @param {Matrix} b            Dense Vector   (N)\n   *\n   * @return {number}             Scalar value\n   */\n  function _multiplyVectorVector(a, b, n) {\n    // check empty vector\n    if (n === 0) {\n      throw new Error('Cannot multiply two empty vectors');\n    }\n    return dot(a, b);\n  }\n\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (M)\n   * @param {Matrix} b            Matrix         (MxN)\n   *\n   * @return {Matrix}             Dense Vector   (N)\n   */\n  function _multiplyVectorMatrix(a, b) {\n    // process storage\n    if (b.storage() !== 'dense') {\n      throw new Error('Support for SparseMatrix not implemented');\n    }\n    return _multiplyVectorDenseMatrix(a, b);\n  }\n\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Dense Vector   (M)\n   * @param {Matrix} b            Dense Matrix   (MxN)\n   *\n   * @return {Matrix}             Dense Vector   (N)\n   */\n  function _multiplyVectorDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype || a.getDataType();\n    // b dense\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype || b.getDataType();\n    // rows & columns\n    var alength = asize[0];\n    var bcolumns = bsize[1];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    }\n\n    // result\n    var c = [];\n\n    // loop matrix columns\n    for (var j = 0; j < bcolumns; j++) {\n      // sum (do not initialize it with zero)\n      var sum = mf(adata[0], bdata[0][j]);\n      // loop vector\n      for (var i = 1; i < alength; i++) {\n        // multiply & accumulate\n        sum = af(sum, mf(adata[i], bdata[i][j]));\n      }\n      c[j] = sum;\n    }\n\n    // return matrix\n    return a.createDenseMatrix({\n      data: c,\n      size: [bcolumns],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n  }\n\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Matrix         (MxN)\n   * @param {Matrix} b            Dense Vector   (N)\n   *\n   * @return {Matrix}             Dense Vector   (M)\n   */\n  var _multiplyMatrixVector = typed('_multiplyMatrixVector', {\n    'DenseMatrix, any': _multiplyDenseMatrixVector,\n    'SparseMatrix, any': _multiplySparseMatrixVector\n  });\n\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            Matrix         (MxN)\n   * @param {Matrix} b            Matrix         (NxC)\n   *\n   * @return {Matrix}             Matrix         (MxC)\n   */\n  var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {\n    'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,\n    'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,\n    'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,\n    'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix\n  });\n\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix  (MxN)\n   * @param {Matrix} b            Dense Vector (N)\n   *\n   * @return {Matrix}             Dense Vector (M)\n   */\n  function _multiplyDenseMatrixVector(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype || a.getDataType();\n    // b dense\n    var bdata = b._data;\n    var bdt = b._datatype || b.getDataType();\n    // rows & columns\n    var arows = asize[0];\n    var acolumns = asize[1];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    }\n\n    // result\n    var c = [];\n\n    // loop matrix a rows\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i];\n      // sum (do not initialize it with zero)\n      var sum = mf(row[0], bdata[0]);\n      // loop matrix a columns\n      for (var j = 1; j < acolumns; j++) {\n        // multiply & accumulate\n        sum = af(sum, mf(row[j], bdata[j]));\n      }\n      c[i] = sum;\n    }\n\n    // return matrix\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n  }\n\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix    (MxN)\n   * @param {Matrix} b            DenseMatrix    (NxC)\n   *\n   * @return {Matrix}             DenseMatrix    (MxC)\n   */\n  function _multiplyDenseMatrixDenseMatrix(a, b) {\n    // getDataType()\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype || a.getDataType();\n    // b dense\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype || b.getDataType();\n    // rows & columns\n    var arows = asize[0];\n    var acolumns = asize[1];\n    var bcolumns = bsize[1];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    }\n\n    // result\n    var c = [];\n\n    // loop matrix a rows\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i];\n      // initialize row array\n      c[i] = [];\n      // loop matrix b columns\n      for (var j = 0; j < bcolumns; j++) {\n        // sum (avoid initializing sum to zero)\n        var sum = mf(row[0], bdata[0][j]);\n        // loop matrix a columns\n        for (var x = 1; x < acolumns; x++) {\n          // multiply & accumulate\n          sum = af(sum, mf(row[x], bdata[x][j]));\n        }\n        c[i][j] = sum;\n      }\n    }\n\n    // return matrix\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows, bcolumns],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n  }\n\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            DenseMatrix    (MxN)\n   * @param {Matrix} b            SparseMatrix   (NxC)\n   *\n   * @return {Matrix}             SparseMatrix   (MxC)\n   */\n  function _multiplyDenseMatrixSparseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype || a.getDataType();\n    // b sparse\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bsize = b._size;\n    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();\n    // validate b matrix\n    if (!bvalues) {\n      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');\n    }\n    // rows & columns\n    var arows = asize[0];\n    var bcolumns = bsize[1];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n    // equalScalar signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]);\n      // convert 0 to the same datatype\n      zero = typed.convert(0, dt);\n    }\n\n    // result\n    var cvalues = [];\n    var cindex = [];\n    var cptr = [];\n    // c matrix\n    var c = b.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n\n    // loop b columns\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length;\n      // indeces in column jb\n      var kb0 = bptr[jb];\n      var kb1 = bptr[jb + 1];\n      // do not process column jb if no data exists\n      if (kb1 > kb0) {\n        // last row mark processed\n        var last = 0;\n        // loop a rows\n        for (var i = 0; i < arows; i++) {\n          // column mark\n          var mark = i + 1;\n          // C[i, jb]\n          var cij = void 0;\n          // values in b column j\n          for (var kb = kb0; kb < kb1; kb++) {\n            // row\n            var ib = bindex[kb];\n            // check value has been initialized\n            if (last !== mark) {\n              // first value in column jb\n              cij = mf(adata[i][ib], bvalues[kb]);\n              // update mark\n              last = mark;\n            } else {\n              // accumulate value\n              cij = af(cij, mf(adata[i][ib], bvalues[kb]));\n            }\n          }\n          // check column has been processed and value != 0\n          if (last === mark && !eq(cij, zero)) {\n            // push row & value\n            cindex.push(i);\n            cvalues.push(cij);\n          }\n        }\n      }\n    }\n    // update ptr\n    cptr[bcolumns] = cindex.length;\n\n    // return sparse matrix\n    return c;\n  }\n\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix    (MxN)\n   * @param {Matrix} b            Dense Vector (N)\n   *\n   * @return {Matrix}             SparseMatrix    (M, 1)\n   */\n  function _multiplySparseMatrixVector(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();\n    // validate a matrix\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    }\n    // b dense\n    var bdata = b._data;\n    var bdt = b._datatype || b.getDataType();\n    // rows & columns\n    var arows = a._size[0];\n    var brows = b._size[0];\n    // result\n    var cvalues = [];\n    var cindex = [];\n    var cptr = [];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n    // equalScalar signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]);\n      // convert 0 to the same datatype\n      zero = typed.convert(0, dt);\n    }\n\n    // workspace\n    var x = [];\n    // vector with marks indicating a value x[i] exists in a given column\n    var w = [];\n\n    // update ptr\n    cptr[0] = 0;\n    // rows in b\n    for (var ib = 0; ib < brows; ib++) {\n      // b[ib]\n      var vbi = bdata[ib];\n      // check b[ib] != 0, avoid loops\n      if (!eq(vbi, zero)) {\n        // A values & index in ib column\n        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n          // a row\n          var ia = aindex[ka];\n          // check value exists in current j\n          if (!w[ia]) {\n            // ia is new entry in j\n            w[ia] = true;\n            // add i to pattern of C\n            cindex.push(ia);\n            // x(ia) = A\n            x[ia] = mf(vbi, avalues[ka]);\n          } else {\n            // i exists in C already\n            x[ia] = af(x[ia], mf(vbi, avalues[ka]));\n          }\n        }\n      }\n    }\n    // copy values from x to column jb of c\n    for (var p1 = cindex.length, p = 0; p < p1; p++) {\n      // row\n      var ic = cindex[p];\n      // copy value\n      cvalues[p] = x[ic];\n    }\n    // update ptr\n    cptr[1] = cindex.length;\n\n    // matrix to return\n    return a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, 1],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n  }\n\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix      (MxN)\n   * @param {Matrix} b            DenseMatrix       (NxC)\n   *\n   * @return {Matrix}             SparseMatrix      (MxC)\n   */\n  function _multiplySparseMatrixDenseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();\n    // validate a matrix\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    }\n    // b dense\n    var bdata = b._data;\n    var bdt = b._datatype || b.getDataType();\n    // rows & columns\n    var arows = a._size[0];\n    var brows = b._size[0];\n    var bcolumns = b._size[1];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n    // equalScalar signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]);\n      // convert 0 to the same datatype\n      zero = typed.convert(0, dt);\n    }\n\n    // result\n    var cvalues = [];\n    var cindex = [];\n    var cptr = [];\n    // c matrix\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n\n    // workspace\n    var x = [];\n    // vector with marks indicating a value x[i] exists in a given column\n    var w = [];\n\n    // loop b columns\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length;\n      // mark in workspace for current column\n      var mark = jb + 1;\n      // rows in jb\n      for (var ib = 0; ib < brows; ib++) {\n        // b[ib, jb]\n        var vbij = bdata[ib][jb];\n        // check b[ib, jb] != 0, avoid loops\n        if (!eq(vbij, zero)) {\n          // A values & index in ib column\n          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // a row\n            var ia = aindex[ka];\n            // check value exists in current j\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark;\n              // add i to pattern of C\n              cindex.push(ia);\n              // x(ia) = A\n              x[ia] = mf(vbij, avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(vbij, avalues[ka]));\n            }\n          }\n        }\n      }\n      // copy values from x to column jb of c\n      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n        // row\n        var ic = cindex[p];\n        // copy value\n        cvalues[p] = x[ic];\n      }\n    }\n    // update ptr\n    cptr[bcolumns] = cindex.length;\n\n    // return sparse matrix\n    return c;\n  }\n\n  /**\n   * C = A * B\n   *\n   * @param {Matrix} a            SparseMatrix      (MxN)\n   * @param {Matrix} b            SparseMatrix      (NxC)\n   *\n   * @return {Matrix}             SparseMatrix      (MxC)\n   */\n  function _multiplySparseMatrixSparseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();\n    // b sparse\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();\n\n    // rows & columns\n    var arows = a._size[0];\n    var bcolumns = b._size[1];\n    // flag indicating both matrices (a & b) contain data\n    var values = avalues && bvalues;\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    }\n\n    // result\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = [];\n    // c matrix\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n\n    // workspace\n    var x = values ? [] : undefined;\n    // vector with marks indicating a value x[i] exists in a given column\n    var w = [];\n    // variables\n    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;\n    // loop b columns\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length;\n      // mark in workspace for current column\n      var mark = jb + 1;\n      // B values & index in j\n      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {\n        // b row\n        ib = bindex[kb];\n        // check we need to process values\n        if (values) {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka];\n            // check value exists in current j\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark;\n              // add i to pattern of C\n              cindex.push(ia);\n              // x(ia) = A\n              x[ia] = mf(bvalues[kb], avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));\n            }\n          }\n        } else {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka];\n            // check value exists in current j\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark;\n              // add i to pattern of C\n              cindex.push(ia);\n            }\n          }\n        }\n      }\n      // check we need to process matrix values (pattern matrix)\n      if (values) {\n        // copy values from x to column jb of c\n        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n          // row\n          var ic = cindex[p];\n          // copy value\n          cvalues[p] = x[ic];\n        }\n      }\n    }\n    // update ptr\n    cptr[bcolumns] = cindex.length;\n\n    // return sparse matrix\n    return c;\n  }\n\n  /**\n   * Multiply two or more values, `x * y`.\n   * For matrices, the matrix product is calculated.\n   *\n   * Syntax:\n   *\n   *    math.multiply(x, y)\n   *    math.multiply(x, y, z, ...)\n   *\n   * Examples:\n   *\n   *    math.multiply(4, 5.2)        // returns number 20.8\n   *    math.multiply(2, 3, 4)       // returns number 24\n   *\n   *    const a = math.complex(2, 3)\n   *    const b = math.complex(4, 1)\n   *    math.multiply(a, b)          // returns Complex 5 + 14i\n   *\n   *    const c = [[1, 2], [4, 3]]\n   *    const d = [[1, 2, 3], [3, -4, 7]]\n   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]\n   *\n   *    const e = math.unit('2.1 km')\n   *    math.multiply(3, e)          // returns Unit 6.3 km\n   *\n   * See also:\n   *\n   *    divide, prod, cross, dot\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x First value to multiply\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`\n   */\n  return typed(name, multiplyScalar, {\n    // we extend the signatures of multiplyScalar with signatures dealing with matrices\n\n    'Array, Array': typed.referTo('Matrix, Matrix', selfMM => (x, y) => {\n      // check dimensions\n      _validateMatrixDimensions(arraySize(x), arraySize(y));\n\n      // use dense matrix implementation\n      var m = selfMM(matrix(x), matrix(y));\n      // return array or scalar\n      return isMatrix(m) ? m.valueOf() : m;\n    }),\n    'Matrix, Matrix': function Matrix_Matrix(x, y) {\n      // dimensions\n      var xsize = x.size();\n      var ysize = y.size();\n\n      // check dimensions\n      _validateMatrixDimensions(xsize, ysize);\n\n      // process dimensions\n      if (xsize.length === 1) {\n        // process y dimensions\n        if (ysize.length === 1) {\n          // Vector * Vector\n          return _multiplyVectorVector(x, y, xsize[0]);\n        }\n        // Vector * Matrix\n        return _multiplyVectorMatrix(x, y);\n      }\n      // process y dimensions\n      if (ysize.length === 1) {\n        // Matrix * Vector\n        return _multiplyMatrixVector(x, y);\n      }\n      // Matrix * Matrix\n      return _multiplyMatrixMatrix(x, y);\n    },\n    'Matrix, Array': typed.referTo('Matrix,Matrix', selfMM => (x, y) => selfMM(x, matrix(y))),\n    'Array, Matrix': typed.referToSelf(self => (x, y) => {\n      // use Matrix * Matrix implementation\n      return self(matrix(x, y.storage()), y);\n    }),\n    'SparseMatrix, any': function SparseMatrix_any(x, y) {\n      return matAlgo11xS0s(x, y, multiplyScalar, false);\n    },\n    'DenseMatrix, any': function DenseMatrix_any(x, y) {\n      return matAlgo14xDs(x, y, multiplyScalar, false);\n    },\n    'any, SparseMatrix': function any_SparseMatrix(x, y) {\n      return matAlgo11xS0s(y, x, multiplyScalar, true);\n    },\n    'any, DenseMatrix': function any_DenseMatrix(x, y) {\n      return matAlgo14xDs(y, x, multiplyScalar, true);\n    },\n    'Array, any': function Array_any(x, y) {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(x), y, multiplyScalar, false).valueOf();\n    },\n    'any, Array': function any_Array(x, y) {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(y), x, multiplyScalar, true).valueOf();\n    },\n    'any, any': multiplyScalar,\n    'any, any, ...any': typed.referToSelf(self => (x, y, rest) => {\n      var result = self(x, y);\n      for (var i = 0; i < rest.length; i++) {\n        result = self(result, rest[i]);\n      }\n      return result;\n    })\n  });\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2659, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { createMatAlgo01xDSid } from '../../type/matrix/utils/matAlgo01xDSid.js';\nimport { createMatAlgo02xDS0 } from '../../type/matrix/utils/matAlgo02xDS0.js';\nimport { createMatAlgo06xS0S0 } from '../../type/matrix/utils/matAlgo06xS0S0.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatrixAlgorithmSuite } from '../../type/matrix/utils/matrixAlgorithmSuite.js';\nimport { nthRootNumber } from '../../plain/number/index.js';\nvar name = 'nthRoot';\nvar dependencies = ['typed', 'matrix', 'equalScalar', 'BigNumber', 'concat'];\nexport var createNthRoot = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    equalScalar,\n    BigNumber: _BigNumber,\n    concat\n  } = _ref;\n  var matAlgo01xDSid = createMatAlgo01xDSid({\n    typed\n  });\n  var matAlgo02xDS0 = createMatAlgo02xDS0({\n    typed,\n    equalScalar\n  });\n  var matAlgo06xS0S0 = createMatAlgo06xS0S0({\n    typed,\n    equalScalar\n  });\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({\n    typed,\n    matrix,\n    concat\n  });\n\n  /**\n   * Calculate the nth root of a value.\n   * The principal nth root of a positive real number A, is the positive real\n   * solution of the equation\n   *\n   *     x^root = A\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *     math.nthRoot(a)\n   *     math.nthRoot(a, root)\n   *\n   * Examples:\n   *\n   *     math.nthRoot(9, 2)    // returns 3 (since 3^2 == 9)\n   *     math.sqrt(9)          // returns 3 (since 3^2 == 9)\n   *     math.nthRoot(64, 3)   // returns 4 (since 4^3 == 64)\n   *\n   * See also:\n   *\n   *     sqrt, pow\n   *\n   * @param {number | BigNumber | Array | Matrix | Complex} a\n   *              Value for which to calculate the nth root\n   * @param {number | BigNumber} [root=2]    The root.\n   * @return {number | Complex | Array | Matrix} Returns the nth root of `a`\n   */\n  function complexErr() {\n    throw new Error('Complex number not supported in function nthRoot. Use nthRoots instead.');\n  }\n  return typed(name, {\n    number: nthRootNumber,\n    'number, number': nthRootNumber,\n    BigNumber: x => _bigNthRoot(x, new _BigNumber(2)),\n    'BigNumber, BigNumber': _bigNthRoot,\n    Complex: complexErr,\n    'Complex, number': complexErr,\n    Array: typed.referTo('DenseMatrix,number', selfDn => x => selfDn(matrix(x), 2).valueOf()),\n    DenseMatrix: typed.referTo('DenseMatrix,number', selfDn => x => selfDn(x, 2)),\n    SparseMatrix: typed.referTo('SparseMatrix,number', selfSn => x => selfSn(x, 2)),\n    'SparseMatrix, SparseMatrix': typed.referToSelf(self => (x, y) => {\n      // density must be one (no zeros in matrix)\n      if (y.density() === 1) {\n        // sparse + sparse\n        return matAlgo06xS0S0(x, y, self);\n      } else {\n        // throw exception\n        throw new Error('Root must be non-zero');\n      }\n    }),\n    'DenseMatrix, SparseMatrix': typed.referToSelf(self => (x, y) => {\n      // density must be one (no zeros in matrix)\n      if (y.density() === 1) {\n        // dense + sparse\n        return matAlgo01xDSid(x, y, self, false);\n      } else {\n        // throw exception\n        throw new Error('Root must be non-zero');\n      }\n    }),\n    'Array, SparseMatrix': typed.referTo('DenseMatrix,SparseMatrix', selfDS => (x, y) => selfDS(matrix(x), y)),\n    'number | BigNumber, SparseMatrix': typed.referToSelf(self => (x, y) => {\n      // density must be one (no zeros in matrix)\n      if (y.density() === 1) {\n        // sparse - scalar\n        return matAlgo11xS0s(y, x, self, true);\n      } else {\n        // throw exception\n        throw new Error('Root must be non-zero');\n      }\n    })\n  }, matrixAlgorithmSuite({\n    scalar: 'number | BigNumber',\n    SD: matAlgo02xDS0,\n    Ss: matAlgo11xS0s,\n    sS: false\n  }));\n\n  /**\n   * Calculate the nth root of a for BigNumbers, solve x^root == a\n   * https://rosettacode.org/wiki/Nth_root#JavaScript\n   * @param {BigNumber} a\n   * @param {BigNumber} root\n   * @private\n   */\n  function _bigNthRoot(a, root) {\n    var precision = _BigNumber.precision;\n    var Big = _BigNumber.clone({\n      precision: precision + 2\n    });\n    var zero = new _BigNumber(0);\n    var one = new Big(1);\n    var inv = root.isNegative();\n    if (inv) {\n      root = root.neg();\n    }\n    if (root.isZero()) {\n      throw new Error('Root must be non-zero');\n    }\n    if (a.isNegative() && !root.abs().mod(2).equals(1)) {\n      throw new Error('Root must be odd when a is negative.');\n    }\n\n    // edge cases zero and infinity\n    if (a.isZero()) {\n      return inv ? new Big(Infinity) : 0;\n    }\n    if (!a.isFinite()) {\n      return inv ? zero : a;\n    }\n    var x = a.abs().pow(one.div(root));\n    // If a < 0, we require that root is an odd integer,\n    // so (-1) ^ (1/root) = -1\n    x = a.isNeg() ? x.neg() : x;\n    return new _BigNumber((inv ? one.div(x) : x).toPrecision(precision));\n  }\n});\nexport var createNthRootNumber = /* #__PURE__ */factory(name, ['typed'], _ref2 => {\n  var {\n    typed\n  } = _ref2;\n  return typed(name, {\n    number: nthRootNumber,\n    'number, number': nthRootNumber\n  });\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2838, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/sign.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { deepMap } from '../../utils/collection.js';\nimport { signNumber } from '../../plain/number/index.js';\nvar name = 'sign';\nvar dependencies = ['typed', 'BigNumber', 'Fraction', 'complex'];\nexport var createSign = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    BigNumber: _BigNumber,\n    complex,\n    Fraction: _Fraction\n  } = _ref;\n  /**\n   * Compute the sign of a value. The sign of a value x is:\n   *\n   * -  1 when x > 0\n   * - -1 when x < 0\n   * -  0 when x == 0\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.sign(x)\n   *\n   * Examples:\n   *\n   *    math.sign(3.5)               // returns 1\n   *    math.sign(-4.2)              // returns -1\n   *    math.sign(0)                 // returns 0\n   *\n   *    math.sign([3, 5, -2, 0, 2])  // returns [1, 1, -1, 0, 1]\n   *\n   * See also:\n   *\n   *    abs\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit} x\n   *            The number for which to determine the sign\n   * @return {number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit}\n   *            The sign of `x`\n   */\n  return typed(name, {\n    number: signNumber,\n    Complex: function Complex(x) {\n      return x.im === 0 ? complex(signNumber(x.re)) : x.sign();\n    },\n    BigNumber: function BigNumber(x) {\n      return new _BigNumber(x.cmp(0));\n    },\n    bigint: function bigint(x) {\n      return x > 0n ? 1n : x < 0n ? -1n : 0n;\n    },\n    Fraction: function Fraction(x) {\n      return new _Fraction(x.s, 1);\n    },\n    // deep map collection, skip zeros since sign(0) = 0\n    'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self, true)),\n    Unit: typed.referToSelf(self => x => {\n      if (!x._isDerived() && x.units[0].unit.offset !== 0) {\n        throw new TypeError('sign is ambiguous for units with offset');\n      }\n      return typed.find(self, x.valueType())(x.value);\n    })\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAa;IAAY;CAAU;AACzD,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACL,WAAW,UAAU,EACrB,OAAO,EACP,UAAU,SAAS,EACpB,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,qKAAA,CAAA,aAAU;QAClB,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,EAAE,EAAE,KAAK,IAAI,QAAQ,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,EAAE,EAAE,KAAK,EAAE,IAAI;QACxD;QACA,WAAW,SAAS,UAAU,CAAC;YAC7B,OAAO,IAAI,WAAW,EAAE,GAAG,CAAC;QAC9B;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,IAAI,EAAE,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,CAAC,EAAE,GAAG,EAAE;QACxC;QACA,UAAU,SAAS,SAAS,CAAC;YAC3B,OAAO,IAAI,UAAU,EAAE,CAAC,EAAE;QAC5B;QACA,oDAAoD;QACpD,kBAAkB,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAA,IAAK,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,GAAG,MAAM;QAClE,MAAM,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAA;gBAC9B,IAAI,CAAC,EAAE,UAAU,MAAM,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,KAAK,GAAG;oBACnD,MAAM,IAAI,UAAU;gBACtB;gBACA,OAAO,MAAM,IAAI,CAAC,MAAM,EAAE,SAAS,IAAI,EAAE,KAAK;YAChD;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2915, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'sqrt';\nvar dependencies = ['config', 'typed', 'Complex'];\nexport var createSqrt = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    Complex\n  } = _ref;\n  /**\n   * Calculate the square root of a value.\n   *\n   * For matrices, if you want the matrix square root of a square matrix,\n   * use the `sqrtm` function. If you wish to apply `sqrt` elementwise to\n   * a matrix M, use `math.map(M, math.sqrt)`.\n   *\n   * Syntax:\n   *\n   *    math.sqrt(x)\n   *\n   * Examples:\n   *\n   *    math.sqrt(25)                // returns 5\n   *    math.square(5)               // returns 25\n   *    math.sqrt(-4)                // returns Complex 2i\n   *\n   * See also:\n   *\n   *    square, multiply, cube, cbrt, sqrtm\n   *\n   * @param {number | BigNumber | Complex | Unit} x\n   *            Value for which to calculate the square root.\n   * @return {number | BigNumber | Complex | Unit}\n   *            Returns the square root of `x`\n   */\n  return typed('sqrt', {\n    number: _sqrtNumber,\n    Complex: function Complex(x) {\n      return x.sqrt();\n    },\n    BigNumber: function BigNumber(x) {\n      if (!x.isNegative() || config.predictable) {\n        return x.sqrt();\n      } else {\n        // negative value -> downgrade to number to do complex value computation\n        return _sqrtNumber(x.toNumber());\n      }\n    },\n    Unit: function Unit(x) {\n      // Someday will work for complex units when they are implemented\n      return x.pow(0.5);\n    }\n  });\n\n  /**\n   * Calculate sqrt for a number\n   * @param {number} x\n   * @returns {number | Complex} Returns the square root of x\n   * @private\n   */\n  function _sqrtNumber(x) {\n    if (isNaN(x)) {\n      return NaN;\n    } else if (x >= 0 || config.predictable) {\n      return Math.sqrt(x);\n    } else {\n      return new Complex(x, 0).sqrt();\n    }\n  }\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAU;IAAS;CAAU;AAC1C,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,MAAM,EACN,KAAK,EACL,OAAO,EACR,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;GAyBC,GACD,OAAO,MAAM,QAAQ;QACnB,QAAQ;QACR,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,EAAE,IAAI;QACf;QACA,WAAW,SAAS,UAAU,CAAC;YAC7B,IAAI,CAAC,EAAE,UAAU,MAAM,OAAO,WAAW,EAAE;gBACzC,OAAO,EAAE,IAAI;YACf,OAAO;gBACL,wEAAwE;gBACxE,OAAO,YAAY,EAAE,QAAQ;YAC/B;QACF;QACA,MAAM,SAAS,KAAK,CAAC;YACnB,gEAAgE;YAChE,OAAO,EAAE,GAAG,CAAC;QACf;IACF;;IAEA;;;;;GAKC,GACD,SAAS,YAAY,CAAC;QACpB,IAAI,MAAM,IAAI;YACZ,OAAO;QACT,OAAO,IAAI,KAAK,KAAK,OAAO,WAAW,EAAE;YACvC,OAAO,KAAK,IAAI,CAAC;QACnB,OAAO;YACL,OAAO,IAAI,QAAQ,GAAG,GAAG,IAAI;QAC/B;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2993, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/square.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { squareNumber } from '../../plain/number/index.js';\nvar name = 'square';\nvar dependencies = ['typed'];\nexport var createSquare = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Compute the square of a value, `x * x`.\n   * To avoid confusion with multiplying a square matrix by itself,\n   * this function does not apply to matrices. If you wish to square\n   * every element of a matrix, see the examples.\n   *\n   * Syntax:\n   *\n   *    math.square(x)\n   *\n   * Examples:\n   *\n   *    math.square(2)           // returns number 4\n   *    math.square(3)           // returns number 9\n   *    math.pow(3, 2)           // returns number 9\n   *    math.multiply(3, 3)      // returns number 9\n   *\n   *    math.map([1, 2, 3, 4], math.square)  // returns Array [1, 4, 9, 16]\n   *\n   * See also:\n   *\n   *    multiply, cube, sqrt, pow\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x\n   *            Number for which to calculate the square\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}\n   *            Squared value\n   */\n  return typed(name, {\n    number: squareNumber,\n    Complex: function Complex(x) {\n      return x.mul(x);\n    },\n    BigNumber: function BigNumber(x) {\n      return x.times(x);\n    },\n    bigint: function bigint(x) {\n      return x * x;\n    },\n    Fraction: function Fraction(x) {\n      return x.mul(x);\n    },\n    Unit: function Unit(x) {\n      return x.pow(2);\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,eAAe,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACnE,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,qKAAA,CAAA,eAAY;QACpB,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,EAAE,GAAG,CAAC;QACf;QACA,WAAW,SAAS,UAAU,CAAC;YAC7B,OAAO,EAAE,KAAK,CAAC;QACjB;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,IAAI;QACb;QACA,UAAU,SAAS,SAAS,CAAC;YAC3B,OAAO,EAAE,GAAG,CAAC;QACf;QACA,MAAM,SAAS,KAAK,CAAC;YACnB,OAAO,EAAE,GAAG,CAAC;QACf;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3058, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/subtract.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { createMatAlgo01xDSid } from '../../type/matrix/utils/matAlgo01xDSid.js';\nimport { createMatAlgo03xDSf } from '../../type/matrix/utils/matAlgo03xDSf.js';\nimport { createMatAlgo05xSfSf } from '../../type/matrix/utils/matAlgo05xSfSf.js';\nimport { createMatAlgo10xSids } from '../../type/matrix/utils/matAlgo10xSids.js';\nimport { createMatAlgo12xSfs } from '../../type/matrix/utils/matAlgo12xSfs.js';\nimport { createMatrixAlgorithmSuite } from '../../type/matrix/utils/matrixAlgorithmSuite.js';\nvar name = 'subtract';\nvar dependencies = ['typed', 'matrix', 'equalScalar', 'subtractScalar', 'unaryMinus', 'DenseMatrix', 'concat'];\nexport var createSubtract = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    equalScalar,\n    subtractScalar,\n    unaryMinus,\n    DenseMatrix,\n    concat\n  } = _ref;\n  // TODO: split function subtract in two: subtract and subtractScalar\n\n  var matAlgo01xDSid = createMatAlgo01xDSid({\n    typed\n  });\n  var matAlgo03xDSf = createMatAlgo03xDSf({\n    typed\n  });\n  var matAlgo05xSfSf = createMatAlgo05xSfSf({\n    typed,\n    equalScalar\n  });\n  var matAlgo10xSids = createMatAlgo10xSids({\n    typed,\n    DenseMatrix\n  });\n  var matAlgo12xSfs = createMatAlgo12xSfs({\n    typed,\n    DenseMatrix\n  });\n  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({\n    typed,\n    matrix,\n    concat\n  });\n\n  /**\n   * Subtract two values, `x - y`.\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.subtract(x, y)\n   *\n   * Examples:\n   *\n   *    math.subtract(5.3, 2)        // returns number 3.3\n   *\n   *    const a = math.complex(2, 3)\n   *    const b = math.complex(4, 1)\n   *    math.subtract(a, b)          // returns Complex -2 + 2i\n   *\n   *    math.subtract([5, 7, 4], 4)  // returns Array [1, 3, 0]\n   *\n   *    const c = math.unit('2.1 km')\n   *    const d = math.unit('500m')\n   *    math.subtract(c, d)          // returns Unit 1.6 km\n   *\n   * See also:\n   *\n   *    add\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x Initial value\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} y Value to subtract from `x`\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Subtraction of `x` and `y`\n   */\n  return typed(name, {\n    'any, any': subtractScalar\n  }, matrixAlgorithmSuite({\n    elop: subtractScalar,\n    SS: matAlgo05xSfSf,\n    DS: matAlgo01xDSid,\n    SD: matAlgo03xDSf,\n    Ss: matAlgo12xSfs,\n    sS: matAlgo10xSids\n  }));\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAe;IAAkB;IAAc;IAAe;CAAS;AACvG,IAAI,iBAAiB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACrE,IAAI,EACF,KAAK,EACL,MAAM,EACN,WAAW,EACX,cAAc,EACd,UAAU,EACV,WAAW,EACX,MAAM,EACP,GAAG;IACJ,oEAAoE;IAEpE,IAAI,iBAAiB,CAAA,GAAA,iLAAA,CAAA,uBAAoB,AAAD,EAAE;QACxC;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;IACF;IACA,IAAI,iBAAiB,CAAA,GAAA,iLAAA,CAAA,uBAAoB,AAAD,EAAE;QACxC;QACA;IACF;IACA,IAAI,iBAAiB,CAAA,GAAA,iLAAA,CAAA,uBAAoB,AAAD,EAAE;QACxC;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,uBAAuB,CAAA,GAAA,uLAAA,CAAA,6BAA0B,AAAD,EAAE;QACpD;QACA;QACA;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BC,GACD,OAAO,MAAM,MAAM;QACjB,YAAY;IACd,GAAG,qBAAqB;QACtB,MAAM;QACN,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;IACN;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3157, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { xgcdNumber } from '../../plain/number/index.js';\nvar name = 'xgcd';\nvar dependencies = ['typed', 'config', 'matrix', 'BigNumber'];\nexport var createXgcd = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    matrix,\n    BigNumber\n  } = _ref;\n  /**\n   * Calculate the extended greatest common divisor for two values.\n   * See https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.\n   *\n   * Syntax:\n   *\n   *    math.xgcd(a, b)\n   *\n   * Examples:\n   *\n   *    math.xgcd(8, 12)             // returns [4, -1, 1]\n   *    math.gcd(8, 12)              // returns 4\n   *    math.xgcd(36163, 21199)      // returns [1247, -7, 12]\n   *\n   * See also:\n   *\n   *    gcd, lcm\n   *\n   * @param {number | BigNumber} a  An integer number\n   * @param {number | BigNumber} b  An integer number\n   * @return {Array}              Returns an array containing 3 integers `[div, m, n]`\n   *                              where `div = gcd(a, b)` and `a*m + b*n = div`\n   */\n  return typed(name, {\n    'number, number': function number_number(a, b) {\n      var res = xgcdNumber(a, b);\n      return config.matrix === 'Array' ? res : matrix(res);\n    },\n    'BigNumber, BigNumber': _xgcdBigNumber\n    // TODO: implement support for Fraction\n  });\n\n  /**\n   * Calculate xgcd for two BigNumbers\n   * @param {BigNumber} a\n   * @param {BigNumber} b\n   * @return {BigNumber[]} result\n   * @private\n   */\n  function _xgcdBigNumber(a, b) {\n    // source: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n    var\n    // used to swap two variables\n    t;\n    var\n    // quotient\n    q;\n    var\n    // remainder\n    r;\n    var zero = new BigNumber(0);\n    var one = new BigNumber(1);\n    var x = zero;\n    var lastx = one;\n    var y = one;\n    var lasty = zero;\n    if (!a.isInt() || !b.isInt()) {\n      throw new Error('Parameters in function xgcd must be integer numbers');\n    }\n    while (!b.isZero()) {\n      q = a.div(b).floor();\n      r = a.mod(b);\n      t = x;\n      x = lastx.minus(q.times(x));\n      lastx = t;\n      t = y;\n      y = lasty.minus(q.times(y));\n      lasty = t;\n      a = b;\n      b = r;\n    }\n    var res;\n    if (a.lt(zero)) {\n      res = [a.neg(), lastx.neg(), lasty.neg()];\n    } else {\n      res = [a, !a.isZero() ? lastx : 0, lasty];\n    }\n    return config.matrix === 'Array' ? res : matrix(res);\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAU;CAAY;AACtD,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACL,MAAM,EACN,MAAM,EACN,SAAS,EACV,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;GAsBC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,IAAI,MAAM,CAAA,GAAA,qKAAA,CAAA,aAAU,AAAD,EAAE,GAAG;YACxB,OAAO,OAAO,MAAM,KAAK,UAAU,MAAM,OAAO;QAClD;QACA,wBAAwB;IAE1B;;IAEA;;;;;;GAMC,GACD,SAAS,eAAe,CAAC,EAAE,CAAC;QAC1B,qEAAqE;QACrE,IACA,6BAA6B;QAC7B;QACA,IACA,WAAW;QACX;QACA,IACA,YAAY;QACZ;QACA,IAAI,OAAO,IAAI,UAAU;QACzB,IAAI,MAAM,IAAI,UAAU;QACxB,IAAI,IAAI;QACR,IAAI,QAAQ;QACZ,IAAI,IAAI;QACR,IAAI,QAAQ;QACZ,IAAI,CAAC,EAAE,KAAK,MAAM,CAAC,EAAE,KAAK,IAAI;YAC5B,MAAM,IAAI,MAAM;QAClB;QACA,MAAO,CAAC,EAAE,MAAM,GAAI;YAClB,IAAI,EAAE,GAAG,CAAC,GAAG,KAAK;YAClB,IAAI,EAAE,GAAG,CAAC;YACV,IAAI;YACJ,IAAI,MAAM,KAAK,CAAC,EAAE,KAAK,CAAC;YACxB,QAAQ;YACR,IAAI;YACJ,IAAI,MAAM,KAAK,CAAC,EAAE,KAAK,CAAC;YACxB,QAAQ;YACR,IAAI;YACJ,IAAI;QACN;QACA,IAAI;QACJ,IAAI,EAAE,EAAE,CAAC,OAAO;YACd,MAAM;gBAAC,EAAE,GAAG;gBAAI,MAAM,GAAG;gBAAI,MAAM,GAAG;aAAG;QAC3C,OAAO;YACL,MAAM;gBAAC;gBAAG,CAAC,EAAE,MAAM,KAAK,QAAQ;gBAAG;aAAM;QAC3C;QACA,OAAO,OAAO,MAAM,KAAK,UAAU,MAAM,OAAO;IAClD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3261, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/invmod.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'invmod';\nvar dependencies = ['typed', 'config', 'BigNumber', 'xgcd', 'equal', 'smaller', 'mod', 'add', 'isInteger'];\nexport var createInvmod = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    BigNumber,\n    xgcd,\n    equal,\n    smaller,\n    mod,\n    add,\n    isInteger\n  } = _ref;\n  /**\n   * Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation `ax ≣ 1 (mod b)`\n   * See https://en.wikipedia.org/wiki/Modular_multiplicative_inverse.\n   *\n   * Syntax:\n   *\n   *    math.invmod(a, b)\n   *\n   * Examples:\n   *\n   *    math.invmod(8, 12)             // returns NaN\n   *    math.invmod(7, 13)             // returns 2\n   *    math.invmod(15151, 15122)      // returns 10429\n   *\n   * See also:\n   *\n   *    gcd, xgcd\n   *\n   * @param {number | BigNumber} a  An integer number\n   * @param {number | BigNumber} b  An integer number\n   * @return {number | BigNumber }  Returns an integer number\n   *                              where `invmod(a,b)*a ≣ 1 (mod b)`\n   */\n  return typed(name, {\n    'number, number': invmod,\n    'BigNumber, BigNumber': invmod\n  });\n  function invmod(a, b) {\n    if (!isInteger(a) || !isInteger(b)) throw new Error('Parameters in function invmod must be integer numbers');\n    a = mod(a, b);\n    if (equal(b, 0)) throw new Error('Divisor must be non zero');\n    var res = xgcd(a, b);\n    res = res.valueOf();\n    var [gcd, inv] = res;\n    if (!equal(gcd, BigNumber(1))) return NaN;\n    inv = mod(inv, b);\n    if (smaller(inv, BigNumber(0))) inv = add(inv, b);\n    return inv;\n  }\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAa;IAAQ;IAAS;IAAW;IAAO;IAAO;CAAY;AACnG,IAAI,eAAe,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACnE,IAAI,EACF,KAAK,EACL,MAAM,EACN,SAAS,EACT,IAAI,EACJ,KAAK,EACL,OAAO,EACP,GAAG,EACH,GAAG,EACH,SAAS,EACV,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;GAsBC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB;QAClB,wBAAwB;IAC1B;;IACA,SAAS,OAAO,CAAC,EAAE,CAAC;QAClB,IAAI,CAAC,UAAU,MAAM,CAAC,UAAU,IAAI,MAAM,IAAI,MAAM;QACpD,IAAI,IAAI,GAAG;QACX,IAAI,MAAM,GAAG,IAAI,MAAM,IAAI,MAAM;QACjC,IAAI,MAAM,KAAK,GAAG;QAClB,MAAM,IAAI,OAAO;QACjB,IAAI,CAAC,KAAK,IAAI,GAAG;QACjB,IAAI,CAAC,MAAM,KAAK,UAAU,KAAK,OAAO;QACtC,MAAM,IAAI,KAAK;QACf,IAAI,QAAQ,KAAK,UAAU,KAAK,MAAM,IAAI,KAAK;QAC/C,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3326, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { createMatAlgo02xDS0 } from '../../type/matrix/utils/matAlgo02xDS0.js';\nimport { createMatAlgo09xS0Sf } from '../../type/matrix/utils/matAlgo09xS0Sf.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatrixAlgorithmSuite } from '../../type/matrix/utils/matrixAlgorithmSuite.js';\nvar name = 'dotMultiply';\nvar dependencies = ['typed', 'matrix', 'equalScalar', 'multiplyScalar', 'concat'];\nexport var createDotMultiply = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    equalScalar,\n    multiplyScalar,\n    concat\n  } = _ref;\n  var matAlgo02xDS0 = createMatAlgo02xDS0({\n    typed,\n    equalScalar\n  });\n  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({\n    typed,\n    equalScalar\n  });\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({\n    typed,\n    matrix,\n    concat\n  });\n\n  /**\n   * Multiply two matrices element wise. The function accepts both matrices and\n   * scalar values.\n   *\n   * Syntax:\n   *\n   *    math.dotMultiply(x, y)\n   *\n   * Examples:\n   *\n   *    math.dotMultiply(2, 4) // returns 8\n   *\n   *    a = [[9, 5], [6, 1]]\n   *    b = [[3, 2], [5, 2]]\n   *\n   *    math.dotMultiply(a, b) // returns [[27, 10], [30, 2]]\n   *    math.multiply(a, b)    // returns [[52, 28], [23, 14]]\n   *\n   * See also:\n   *\n   *    multiply, divide, dotDivide\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Left hand value\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Right hand value\n   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Multiplication of `x` and `y`\n   */\n  return typed(name, matrixAlgorithmSuite({\n    elop: multiplyScalar,\n    SS: matAlgo09xS0Sf,\n    DS: matAlgo02xDS0,\n    Ss: matAlgo11xS0s\n  }));\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAe;IAAkB;CAAS;AAC1E,IAAI,oBAAoB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACxE,IAAI,EACF,KAAK,EACL,MAAM,EACN,WAAW,EACX,cAAc,EACd,MAAM,EACP,GAAG;IACJ,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,iBAAiB,CAAA,GAAA,iLAAA,CAAA,uBAAoB,AAAD,EAAE;QACxC;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,uBAAuB,CAAA,GAAA,uLAAA,CAAA,6BAA0B,AAAD,EAAE;QACpD;QACA;QACA;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;GAyBC,GACD,OAAO,MAAM,MAAM,qBAAqB;QACtC,MAAM;QACN,IAAI;QACJ,IAAI;QACJ,IAAI;IACN;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3404, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'divideScalar';\nvar dependencies = ['typed', 'numeric'];\nexport var createDivideScalar = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    numeric\n  } = _ref;\n  /**\n   * Divide two scalar values, `x / y`.\n   * This function is meant for internal use: it is used by the public functions\n   * `divide` and `inv`.\n   *\n   * This function does not support collections (Array or Matrix).\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit} x   Numerator\n   * @param  {number | BigNumber | bigint | Fraction | Complex} y          Denominator\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit}     Quotient, `x / y`\n   * @private\n   */\n  return typed(name, {\n    'number, number': function number_number(x, y) {\n      return x / y;\n    },\n    'Complex, Complex': function Complex_Complex(x, y) {\n      return x.div(y);\n    },\n    'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {\n      return x.div(y);\n    },\n    'bigint, bigint': function bigint_bigint(x, y) {\n      return x / y;\n    },\n    'Fraction, Fraction': function Fraction_Fraction(x, y) {\n      return x.div(y);\n    },\n    'Unit, number | Complex | Fraction | BigNumber | Unit': (x, y) => x.divide(y),\n    'number | Fraction | Complex | BigNumber, Unit': (x, y) => y.divideInto(x)\n  });\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;CAAU;AAChC,IAAI,qBAAqB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACzE,IAAI,EACF,KAAK,EACL,OAAO,EACR,GAAG;IACJ;;;;;;;;;;;GAWC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,OAAO,IAAI;QACb;QACA,oBAAoB,SAAS,gBAAgB,CAAC,EAAE,CAAC;YAC/C,OAAO,EAAE,GAAG,CAAC;QACf;QACA,wBAAwB,SAAS,oBAAoB,CAAC,EAAE,CAAC;YACvD,OAAO,EAAE,GAAG,CAAC;QACf;QACA,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,OAAO,IAAI;QACb;QACA,sBAAsB,SAAS,kBAAkB,CAAC,EAAE,CAAC;YACnD,OAAO,EAAE,GAAG,CAAC;QACf;QACA,wDAAwD,CAAC,GAAG,IAAM,EAAE,MAAM,CAAC;QAC3E,iDAAiD,CAAC,GAAG,IAAM,EAAE,UAAU,CAAC;IAC1E;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3453, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/pow.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { isInteger } from '../../utils/number.js';\nimport { arraySize as size } from '../../utils/array.js';\nimport { powNumber } from '../../plain/number/index.js';\nvar name = 'pow';\nvar dependencies = ['typed', 'config', 'identity', 'multiply', 'matrix', 'inv', 'fraction', 'number', 'Complex'];\nexport var createPow = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    identity,\n    multiply,\n    matrix,\n    inv,\n    number,\n    fraction,\n    Complex\n  } = _ref;\n  /**\n   * Calculates the power of x to y, `x ^ y`.\n   *\n   * Matrix exponentiation is supported for square matrices `x` and integers `y`:\n   * when `y` is nonnegative, `x` may be any square matrix; and when `y` is\n   * negative, `x` must be invertible, and then this function returns\n   * inv(x)^(-y).\n   *\n   * For cubic roots of negative numbers, the function returns the principal\n   * root by default. In order to let the function return the real root,\n   * math.js can be configured with `math.config({predictable: true})`.\n   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.\n   *\n   * Syntax:\n   *\n   *    math.pow(x, y)\n   *\n   * Examples:\n   *\n   *    math.pow(2, 3)               // returns number 8\n   *\n   *    const a = math.complex(2, 3)\n   *    math.pow(a, 2)                // returns Complex -5 + 12i\n   *\n   *    const b = [[1, 2], [4, 3]]\n   *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]\n   *\n   *    const c = [[1, 2], [4, 3]]\n   *    math.pow(c, -1)               // returns Array [[-0.6, 0.4], [0.8, -0.2]]\n   *\n   * See also:\n   *\n   *    multiply, sqrt, cbrt, nthRoot\n   *\n   * @param  {number | BigNumber | bigint | Complex | Unit | Array | Matrix} x  The base\n   * @param  {number | BigNumber | bigint | Complex} y                          The exponent\n   * @return {number | BigNumber | bigint | Complex | Array | Matrix} The value of `x` to the power `y`\n   */\n  return typed(name, {\n    'number, number': _pow,\n    'Complex, Complex': function Complex_Complex(x, y) {\n      return x.pow(y);\n    },\n    'BigNumber, BigNumber': function BigNumber_BigNumber(x, y) {\n      if (y.isInteger() || x >= 0 || config.predictable) {\n        return x.pow(y);\n      } else {\n        return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);\n      }\n    },\n    'bigint, bigint': (x, y) => x ** y,\n    'Fraction, Fraction': function Fraction_Fraction(x, y) {\n      var result = x.pow(y);\n      if (result != null) {\n        return result;\n      }\n      if (config.predictable) {\n        throw new Error('Result of pow is non-rational and cannot be expressed as a fraction');\n      } else {\n        return _pow(x.valueOf(), y.valueOf());\n      }\n    },\n    'Array, number': _powArray,\n    'Array, BigNumber': function Array_BigNumber(x, y) {\n      return _powArray(x, y.toNumber());\n    },\n    'Matrix, number': _powMatrix,\n    'Matrix, BigNumber': function Matrix_BigNumber(x, y) {\n      return _powMatrix(x, y.toNumber());\n    },\n    'Unit, number | BigNumber': function Unit_number__BigNumber(x, y) {\n      return x.pow(y);\n    }\n  });\n\n  /**\n   * Calculates the power of x to y, x^y, for two numbers.\n   * @param {number} x\n   * @param {number} y\n   * @return {number | Complex} res\n   * @private\n   */\n  function _pow(x, y) {\n    // Alternatively could define a 'realmode' config option or something, but\n    // 'predictable' will work for now\n    if (config.predictable && !isInteger(y) && x < 0) {\n      // Check to see if y can be represented as a fraction\n      try {\n        var yFrac = fraction(y);\n        var yNum = number(yFrac);\n        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {\n          if (yFrac.d % 2 === 1) {\n            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);\n          }\n        }\n      } catch (ex) {\n        // fraction() throws an error if y is Infinity, etc.\n      }\n\n      // Unable to express y as a fraction, so continue on\n    }\n\n    // **for predictable mode** x^Infinity === NaN if x < -1\n    // N.B. this behavour is different from `Math.pow` which gives\n    // (-2)^Infinity === Infinity\n    if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {\n      return NaN;\n    }\n    if (isInteger(y) || x >= 0 || config.predictable) {\n      return powNumber(x, y);\n    } else {\n      // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow\n\n      // x^Infinity === 0 if -1 < x < 1\n      // A real number 0 is returned instead of complex(0)\n      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {\n        return 0;\n      }\n      return new Complex(x, 0).pow(y, 0);\n    }\n  }\n\n  /**\n   * Calculate the power of a 2d array\n   * @param {Array} x     must be a 2 dimensional, square matrix\n   * @param {number} y    a integer value (positive if `x` is not invertible)\n   * @returns {Array}\n   * @private\n   */\n  function _powArray(x, y) {\n    if (!isInteger(y)) {\n      throw new TypeError('For A^b, b must be an integer (value is ' + y + ')');\n    }\n    // verify that A is a 2 dimensional square matrix\n    var s = size(x);\n    if (s.length !== 2) {\n      throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');\n    }\n    if (s[0] !== s[1]) {\n      throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');\n    }\n    if (y < 0) {\n      try {\n        return _powArray(inv(x), -y);\n      } catch (error) {\n        if (error.message === 'Cannot calculate inverse, determinant is zero') {\n          throw new TypeError('For A^b, when A is not invertible, b must be a positive integer (value is ' + y + ')');\n        }\n        throw error;\n      }\n    }\n    var res = identity(s[0]).valueOf();\n    var px = x;\n    while (y >= 1) {\n      if ((y & 1) === 1) {\n        res = multiply(px, res);\n      }\n      y >>= 1;\n      px = multiply(px, px);\n    }\n    return res;\n  }\n\n  /**\n   * Calculate the power of a 2d matrix\n   * @param {Matrix} x     must be a 2 dimensional, square matrix\n   * @param {number} y    a positive, integer value\n   * @returns {Matrix}\n   * @private\n   */\n  function _powMatrix(x, y) {\n    return matrix(_powArray(x.valueOf(), y));\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3649, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/round.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { deepMap } from '../../utils/collection.js';\nimport { nearlyEqual, splitNumber } from '../../utils/number.js';\nimport { nearlyEqual as bigNearlyEqual } from '../../utils/bignumber/nearlyEqual.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatAlgo12xSfs } from '../../type/matrix/utils/matAlgo12xSfs.js';\nimport { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js';\nimport { roundNumber } from '../../plain/number/index.js';\nvar NO_INT = 'Number of decimals in function round must be an integer';\nvar name = 'round';\nvar dependencies = ['typed', 'config', 'matrix', 'equalScalar', 'zeros', 'BigNumber', 'DenseMatrix'];\nexport var createRound = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    matrix,\n    equalScalar,\n    zeros,\n    BigNumber: _BigNumber,\n    DenseMatrix\n  } = _ref;\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matAlgo12xSfs = createMatAlgo12xSfs({\n    typed,\n    DenseMatrix\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n  function toExponent(epsilon) {\n    return Math.abs(splitNumber(epsilon).exponent);\n  }\n\n  /**\n   * Round a value towards the nearest rounded value.\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.round(x)\n   *    math.round(x, n)\n   *    math.round(unit, valuelessUnit)\n   *    math.round(unit, n, valuelessUnit)\n   *\n   * Examples:\n   *\n   *    math.round(3.22)             // returns number 3\n   *    math.round(3.82)             // returns number 4\n   *    math.round(-4.2)             // returns number -4\n   *    math.round(-4.7)             // returns number -5\n   *    math.round(3.22, 1)          // returns number 3.2\n   *    math.round(3.88, 1)          // returns number 3.9\n   *    math.round(-4.21, 1)         // returns number -4.2\n   *    math.round(-4.71, 1)         // returns number -4.7\n   *    math.round(math.pi, 3)       // returns number 3.142\n   *    math.round(123.45678, 2)     // returns number 123.46\n   *\n   *    const c = math.complex(3.2, -2.7)\n   *    math.round(c)                // returns Complex 3 - 3i\n   *\n   *    const unit = math.unit('3.241 cm')\n   *    const cm = math.unit('cm')\n   *    const mm = math.unit('mm')\n   *    math.round(unit, 1, cm)      // returns Unit 3.2 cm\n   *    math.round(unit, 1, mm)      // returns Unit 32.4 mm\n   *\n   *    math.round([3.2, 3.8, -4.7]) // returns Array [3, 4, -5]\n   *\n   * See also:\n   *\n   *    ceil, fix, floor\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x  Value to be rounded\n   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals\n   * @param  {Unit} [valuelessUnit]                                        A valueless unit\n   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value\n   */\n  return typed(name, {\n    number: function number(x) {\n      // Handle round off errors by first rounding to relTol precision\n      var xEpsilon = roundNumber(x, toExponent(config.relTol));\n      var xSelected = nearlyEqual(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;\n      return roundNumber(xSelected);\n    },\n    'number, number': function number_number(x, n) {\n      // Same as number: unless user specifies more decimals than relTol\n      var epsilonExponent = toExponent(config.relTol);\n      if (n >= epsilonExponent) {\n        return roundNumber(x, n);\n      }\n      var xEpsilon = roundNumber(x, epsilonExponent);\n      var xSelected = nearlyEqual(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;\n      return roundNumber(xSelected, n);\n    },\n    'number, BigNumber': function number_BigNumber(x, n) {\n      if (!n.isInteger()) {\n        throw new TypeError(NO_INT);\n      }\n      return new _BigNumber(x).toDecimalPlaces(n.toNumber());\n    },\n    Complex: function Complex(x) {\n      return x.round();\n    },\n    'Complex, number': function Complex_number(x, n) {\n      if (n % 1) {\n        throw new TypeError(NO_INT);\n      }\n      return x.round(n);\n    },\n    'Complex, BigNumber': function Complex_BigNumber(x, n) {\n      if (!n.isInteger()) {\n        throw new TypeError(NO_INT);\n      }\n      var _n = n.toNumber();\n      return x.round(_n);\n    },\n    BigNumber: function BigNumber(x) {\n      // Handle round off errors by first rounding to relTol precision\n      var xEpsilon = new _BigNumber(x).toDecimalPlaces(toExponent(config.relTol));\n      var xSelected = bigNearlyEqual(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;\n      return xSelected.toDecimalPlaces(0);\n    },\n    'BigNumber, BigNumber': function BigNumber_BigNumber(x, n) {\n      if (!n.isInteger()) {\n        throw new TypeError(NO_INT);\n      }\n\n      // Same as BigNumber: unless user specifies more decimals than relTol\n      var epsilonExponent = toExponent(config.relTol);\n      if (n >= epsilonExponent) {\n        return x.toDecimalPlaces(n.toNumber());\n      }\n      var xEpsilon = x.toDecimalPlaces(epsilonExponent);\n      var xSelected = bigNearlyEqual(x, xEpsilon, config.relTol, config.absTol) ? xEpsilon : x;\n      return xSelected.toDecimalPlaces(n.toNumber());\n    },\n    Fraction: function Fraction(x) {\n      return x.round();\n    },\n    'Fraction, number': function Fraction_number(x, n) {\n      if (n % 1) {\n        throw new TypeError(NO_INT);\n      }\n      return x.round(n);\n    },\n    'Fraction, BigNumber': function Fraction_BigNumber(x, n) {\n      if (!n.isInteger()) {\n        throw new TypeError(NO_INT);\n      }\n      return x.round(n.toNumber());\n    },\n    'Unit, number, Unit': typed.referToSelf(self => function (x, n, unit) {\n      var valueless = x.toNumeric(unit);\n      return unit.multiply(self(valueless, n));\n    }),\n    'Unit, BigNumber, Unit': typed.referToSelf(self => (x, n, unit) => self(x, n.toNumber(), unit)),\n    'Unit, Unit': typed.referToSelf(self => (x, unit) => self(x, 0, unit)),\n    'Array | Matrix, number, Unit': typed.referToSelf(self => (x, n, unit) => {\n      // deep map collection, skip zeros since round(0) = 0\n      return deepMap(x, value => self(value, n, unit), true);\n    }),\n    'Array | Matrix, BigNumber, Unit': typed.referToSelf(self => (x, n, unit) => self(x, n.toNumber(), unit)),\n    'Array | Matrix, Unit': typed.referToSelf(self => (x, unit) => self(x, 0, unit)),\n    'Array | Matrix': typed.referToSelf(self => x => {\n      // deep map collection, skip zeros since round(0) = 0\n      return deepMap(x, self, true);\n    }),\n    'SparseMatrix, number | BigNumber': typed.referToSelf(self => (x, n) => {\n      return matAlgo11xS0s(x, n, self, false);\n    }),\n    'DenseMatrix, number | BigNumber': typed.referToSelf(self => (x, n) => {\n      return matAlgo14xDs(x, n, self, false);\n    }),\n    'Array, number | BigNumber': typed.referToSelf(self => (x, n) => {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(x), n, self, false).valueOf();\n    }),\n    'number | Complex | BigNumber | Fraction, SparseMatrix': typed.referToSelf(self => (x, n) => {\n      // check scalar is zero\n      if (equalScalar(x, 0)) {\n        // do not execute algorithm, result will be a zero matrix\n        return zeros(n.size(), n.storage());\n      }\n      return matAlgo12xSfs(n, x, self, true);\n    }),\n    'number | Complex | BigNumber | Fraction, DenseMatrix': typed.referToSelf(self => (x, n) => {\n      // check scalar is zero\n      if (equalScalar(x, 0)) {\n        // do not execute algorithm, result will be a zero matrix\n        return zeros(n.size(), n.storage());\n      }\n      return matAlgo14xDs(n, x, self, true);\n    }),\n    'number | Complex | BigNumber | Fraction, Array': typed.referToSelf(self => (x, n) => {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(n), x, self, true).valueOf();\n    })\n  });\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3865, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/log.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { logNumber } from '../../plain/number/index.js';\nvar name = 'log';\nvar dependencies = ['config', 'typed', 'divideScalar', 'Complex'];\nexport var createLog = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    divideScalar,\n    Complex\n  } = _ref;\n  /**\n   * Calculate the logarithm of a value.\n   *\n   * To avoid confusion with the matrix logarithm, this function does not\n   * apply to matrices.\n   *\n   * Syntax:\n   *\n   *    math.log(x)\n   *    math.log(x, base)\n   *\n   * Examples:\n   *\n   *    math.log(3.5)                  // returns 1.252762968495368\n   *    math.exp(math.log(2.4))        // returns 2.4\n   *\n   *    math.pow(10, 4)                // returns 10000\n   *    math.log(10000, 10)            // returns 4\n   *    math.log(10000) / math.log(10) // returns 4\n   *\n   *    math.log(1024, 2)              // returns 10\n   *    math.pow(2, 10)                // returns 1024\n   *\n   * See also:\n   *\n   *    exp, log2, log10, log1p\n   *\n   * @param {number | BigNumber | Complex} x\n   *            Value for which to calculate the logarithm.\n   * @param {number | BigNumber | Complex} [base=e]\n   *            Optional base for the logarithm. If not provided, the natural\n   *            logarithm of `x` is calculated.\n   * @return {number | BigNumber | Complex}\n   *            Returns the logarithm of `x`\n   */\n  return typed(name, {\n    number: function number(x) {\n      if (x >= 0 || config.predictable) {\n        return logNumber(x);\n      } else {\n        // negative value -> complex value computation\n        return new Complex(x, 0).log();\n      }\n    },\n    Complex: function Complex(x) {\n      return x.log();\n    },\n    BigNumber: function BigNumber(x) {\n      if (!x.isNegative() || config.predictable) {\n        return x.ln();\n      } else {\n        // downgrade to number, return Complex valued result\n        return new Complex(x.toNumber(), 0).log();\n      }\n    },\n    'any, any': typed.referToSelf(self => (x, base) => {\n      // calculate logarithm for a specified base, log(x, base)\n      return divideScalar(self(x), self(base));\n    })\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAU;IAAS;IAAgB;CAAU;AAC1D,IAAI,YAAY,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAChE,IAAI,EACF,KAAK,EACL,MAAM,EACN,YAAY,EACZ,OAAO,EACR,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkCC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,SAAS,OAAO,CAAC;YACvB,IAAI,KAAK,KAAK,OAAO,WAAW,EAAE;gBAChC,OAAO,CAAA,GAAA,qKAAA,CAAA,YAAS,AAAD,EAAE;YACnB,OAAO;gBACL,8CAA8C;gBAC9C,OAAO,IAAI,QAAQ,GAAG,GAAG,GAAG;YAC9B;QACF;QACA,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,EAAE,GAAG;QACd;QACA,WAAW,SAAS,UAAU,CAAC;YAC7B,IAAI,CAAC,EAAE,UAAU,MAAM,OAAO,WAAW,EAAE;gBACzC,OAAO,EAAE,EAAE;YACb,OAAO;gBACL,oDAAoD;gBACpD,OAAO,IAAI,QAAQ,EAAE,QAAQ,IAAI,GAAG,GAAG;YACzC;QACF;QACA,YAAY,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAC,GAAG;gBACxC,yDAAyD;gBACzD,OAAO,aAAa,KAAK,IAAI,KAAK;YACpC;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3947, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/log1p.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { deepMap } from '../../utils/collection.js';\nimport { log1p as _log1p } from '../../utils/number.js';\nvar name = 'log1p';\nvar dependencies = ['typed', 'config', 'divideScalar', 'log', 'Complex'];\nexport var createLog1p = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    divideScalar,\n    log,\n    Complex\n  } = _ref;\n  /**\n   * Calculate the logarithm of a `value+1`.\n   *\n   * For matrices, the function is evaluated element wise.\n   *\n   * Syntax:\n   *\n   *    math.log1p(x)\n   *    math.log1p(x, base)\n   *\n   * Examples:\n   *\n   *    math.log1p(2.5)                 // returns 1.252762968495368\n   *    math.exp(math.log1p(1.4))       // returns 2.4\n   *\n   *    math.pow(10, 4)                 // returns 10000\n   *    math.log1p(9999, 10)            // returns 4\n   *    math.log1p(9999) / math.log(10) // returns 4\n   *\n   * See also:\n   *\n   *    exp, log, log2, log10\n   *\n   * @param {number | BigNumber | Complex | Array | Matrix} x\n   *            Value for which to calculate the logarithm of `x+1`.\n   * @param {number | BigNumber | Complex} [base=e]\n   *            Optional base for the logarithm. If not provided, the natural\n   *            logarithm of `x+1` is calculated.\n   * @return {number | BigNumber | Complex | Array | Matrix}\n   *            Returns the logarithm of `x+1`\n   */\n  return typed(name, {\n    number: function number(x) {\n      if (x >= -1 || config.predictable) {\n        return _log1p(x);\n      } else {\n        // negative value -> complex value computation\n        return _log1pComplex(new Complex(x, 0));\n      }\n    },\n    Complex: _log1pComplex,\n    BigNumber: function BigNumber(x) {\n      var y = x.plus(1);\n      if (!y.isNegative() || config.predictable) {\n        return y.ln();\n      } else {\n        // downgrade to number, return Complex valued result\n        return _log1pComplex(new Complex(x.toNumber(), 0));\n      }\n    },\n    'Array | Matrix': typed.referToSelf(self => x => deepMap(x, self)),\n    'any, any': typed.referToSelf(self => (x, base) => {\n      // calculate logarithm for a specified base, log1p(x, base)\n      return divideScalar(self(x), log(base));\n    })\n  });\n\n  /**\n   * Calculate the natural logarithm of a complex number + 1\n   * @param {Complex} x\n   * @returns {Complex}\n   * @private\n   */\n  function _log1pComplex(x) {\n    var xRe1p = x.re + 1;\n    return new Complex(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAgB;IAAO;CAAU;AACjE,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,KAAK,EACL,MAAM,EACN,YAAY,EACZ,GAAG,EACH,OAAO,EACR,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8BC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,SAAS,OAAO,CAAC;YACvB,IAAI,KAAK,CAAC,KAAK,OAAO,WAAW,EAAE;gBACjC,OAAO,CAAA,GAAA,uJAAA,CAAA,QAAM,AAAD,EAAE;YAChB,OAAO;gBACL,8CAA8C;gBAC9C,OAAO,cAAc,IAAI,QAAQ,GAAG;YACtC;QACF;QACA,SAAS;QACT,WAAW,SAAS,UAAU,CAAC;YAC7B,IAAI,IAAI,EAAE,IAAI,CAAC;YACf,IAAI,CAAC,EAAE,UAAU,MAAM,OAAO,WAAW,EAAE;gBACzC,OAAO,EAAE,EAAE;YACb,OAAO;gBACL,oDAAoD;gBACpD,OAAO,cAAc,IAAI,QAAQ,EAAE,QAAQ,IAAI;YACjD;QACF;QACA,kBAAkB,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAA,IAAK,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,GAAG;QAC5D,YAAY,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAC,GAAG;gBACxC,2DAA2D;gBAC3D,OAAO,aAAa,KAAK,IAAI,IAAI;YACnC;IACF;;IAEA;;;;;GAKC,GACD,SAAS,cAAc,CAAC;QACtB,IAAI,QAAQ,EAAE,EAAE,GAAG;QACnB,OAAO,IAAI,QAAQ,KAAK,GAAG,CAAC,KAAK,IAAI,CAAC,QAAQ,QAAQ,EAAE,EAAE,GAAG,EAAE,EAAE,IAAI,KAAK,KAAK,CAAC,EAAE,EAAE,EAAE;IACxF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4038, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'nthRoots';\nvar dependencies = ['config', 'typed', 'divideScalar', 'Complex'];\nexport var createNthRoots = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    divideScalar,\n    Complex\n  } = _ref;\n  /**\n   * Each function here returns a real multiple of i as a Complex value.\n   * @param  {number} val\n   * @return {Complex} val, i*val, -val or -i*val for index 0, 1, 2, 3\n   */\n  // This is used to fix float artifacts for zero-valued components.\n  var _calculateExactResult = [function realPos(val) {\n    return new Complex(val, 0);\n  }, function imagPos(val) {\n    return new Complex(0, val);\n  }, function realNeg(val) {\n    return new Complex(-val, 0);\n  }, function imagNeg(val) {\n    return new Complex(0, -val);\n  }];\n\n  /**\n   * Calculate the nth root of a Complex Number a using De Movire's Theorem.\n   * @param  {Complex} a\n   * @param  {number} root\n   * @return {Array} array of n Complex Roots\n   */\n  function _nthComplexRoots(a, root) {\n    if (root < 0) throw new Error('Root must be greater than zero');\n    if (root === 0) throw new Error('Root must be non-zero');\n    if (root % 1 !== 0) throw new Error('Root must be an integer');\n    if (a === 0 || a.abs() === 0) return [new Complex(0, 0)];\n    var aIsNumeric = typeof a === 'number';\n    var offset;\n    // determine the offset (argument of a)/(pi/2)\n    if (aIsNumeric || a.re === 0 || a.im === 0) {\n      if (aIsNumeric) {\n        offset = 2 * +(a < 0); // numeric value on the real axis\n      } else if (a.im === 0) {\n        offset = 2 * +(a.re < 0); // complex value on the real axis\n      } else {\n        offset = 2 * +(a.im < 0) + 1; // complex value on the imaginary axis\n      }\n    }\n    var arg = a.arg();\n    var abs = a.abs();\n    var roots = [];\n    var r = Math.pow(abs, 1 / root);\n    for (var k = 0; k < root; k++) {\n      var halfPiFactor = (offset + 4 * k) / root;\n      /**\n       * If (offset + 4*k)/root is an integral multiple of pi/2\n       * then we can produce a more exact result.\n       */\n      if (halfPiFactor === Math.round(halfPiFactor)) {\n        roots.push(_calculateExactResult[halfPiFactor % 4](r));\n        continue;\n      }\n      roots.push(new Complex({\n        r,\n        phi: (arg + 2 * Math.PI * k) / root\n      }));\n    }\n    return roots;\n  }\n\n  /**\n   * Calculate the nth roots of a value.\n   * An nth root of a positive real number A,\n   * is a positive real solution of the equation \"x^root = A\".\n   * This function returns an array of complex values.\n   *\n   * Syntax:\n   *\n   *    math.nthRoots(x)\n   *    math.nthRoots(x, root)\n   *\n   * Examples:\n   *\n   *    math.nthRoots(1)\n   *    // returns [\n   *    //   {re: 1, im: 0},\n   *    //   {re: -1, im: 0}\n   *    // ]\n   *    math.nthRoots(1, 3)\n   *    // returns [\n   *    //   { re: 1, im: 0 },\n   *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },\n   *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }\n   *    // ]\n   *\n   * See also:\n   *\n   *    nthRoot, pow, sqrt\n   *\n   * @param {number | BigNumber | Fraction | Complex} x Number to be rounded\n   * @param {number} [root=2] Optional root, default value is 2\n   * @return {number | BigNumber | Fraction | Complex} Returns the nth roots\n   */\n  return typed(name, {\n    Complex: function Complex(x) {\n      return _nthComplexRoots(x, 2);\n    },\n    'Complex, number': _nthComplexRoots\n  });\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAU;IAAS;IAAgB;CAAU;AAC1D,IAAI,iBAAiB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACrE,IAAI,EACF,KAAK,EACL,MAAM,EACN,YAAY,EACZ,OAAO,EACR,GAAG;IACJ;;;;GAIC,GACD,kEAAkE;IAClE,IAAI,wBAAwB;QAAC,SAAS,QAAQ,GAAG;YAC/C,OAAO,IAAI,QAAQ,KAAK;QAC1B;QAAG,SAAS,QAAQ,GAAG;YACrB,OAAO,IAAI,QAAQ,GAAG;QACxB;QAAG,SAAS,QAAQ,GAAG;YACrB,OAAO,IAAI,QAAQ,CAAC,KAAK;QAC3B;QAAG,SAAS,QAAQ,GAAG;YACrB,OAAO,IAAI,QAAQ,GAAG,CAAC;QACzB;KAAE;IAEF;;;;;GAKC,GACD,SAAS,iBAAiB,CAAC,EAAE,IAAI;QAC/B,IAAI,OAAO,GAAG,MAAM,IAAI,MAAM;QAC9B,IAAI,SAAS,GAAG,MAAM,IAAI,MAAM;QAChC,IAAI,OAAO,MAAM,GAAG,MAAM,IAAI,MAAM;QACpC,IAAI,MAAM,KAAK,EAAE,GAAG,OAAO,GAAG,OAAO;YAAC,IAAI,QAAQ,GAAG;SAAG;QACxD,IAAI,aAAa,OAAO,MAAM;QAC9B,IAAI;QACJ,8CAA8C;QAC9C,IAAI,cAAc,EAAE,EAAE,KAAK,KAAK,EAAE,EAAE,KAAK,GAAG;YAC1C,IAAI,YAAY;gBACd,SAAS,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,iCAAiC;YAC1D,OAAO,IAAI,EAAE,EAAE,KAAK,GAAG;gBACrB,SAAS,IAAI,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,GAAG,iCAAiC;YAC7D,OAAO;gBACL,SAAS,IAAI,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,IAAI,GAAG,sCAAsC;YACtE;QACF;QACA,IAAI,MAAM,EAAE,GAAG;QACf,IAAI,MAAM,EAAE,GAAG;QACf,IAAI,QAAQ,EAAE;QACd,IAAI,IAAI,KAAK,GAAG,CAAC,KAAK,IAAI;QAC1B,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,IAAK;YAC7B,IAAI,eAAe,CAAC,SAAS,IAAI,CAAC,IAAI;YACtC;;;OAGC,GACD,IAAI,iBAAiB,KAAK,KAAK,CAAC,eAAe;gBAC7C,MAAM,IAAI,CAAC,qBAAqB,CAAC,eAAe,EAAE,CAAC;gBACnD;YACF;YACA,MAAM,IAAI,CAAC,IAAI,QAAQ;gBACrB;gBACA,KAAK,CAAC,MAAM,IAAI,KAAK,EAAE,GAAG,CAAC,IAAI;YACjC;QACF;QACA,OAAO;IACT;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCC,GACD,OAAO,MAAM,MAAM;QACjB,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,iBAAiB,GAAG;QAC7B;QACA,mBAAmB;IACrB;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4160, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { createMatAlgo03xDSf } from '../../type/matrix/utils/matAlgo03xDSf.js';\nimport { createMatAlgo07xSSf } from '../../type/matrix/utils/matAlgo07xSSf.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatAlgo12xSfs } from '../../type/matrix/utils/matAlgo12xSfs.js';\nimport { createMatrixAlgorithmSuite } from '../../type/matrix/utils/matrixAlgorithmSuite.js';\nvar name = 'dotPow';\nvar dependencies = ['typed', 'equalScalar', 'matrix', 'pow', 'DenseMatrix', 'concat'];\nexport var createDotPow = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    equalScalar,\n    matrix,\n    pow,\n    DenseMatrix,\n    concat\n  } = _ref;\n  var matAlgo03xDSf = createMatAlgo03xDSf({\n    typed\n  });\n  var matAlgo07xSSf = createMatAlgo07xSSf({\n    typed,\n    DenseMatrix\n  });\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matAlgo12xSfs = createMatAlgo12xSfs({\n    typed,\n    DenseMatrix\n  });\n  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({\n    typed,\n    matrix,\n    concat\n  });\n  var powScalarSignatures = {};\n  for (var signature in pow.signatures) {\n    if (Object.prototype.hasOwnProperty.call(pow.signatures, signature)) {\n      if (!signature.includes('Matrix') && !signature.includes('Array')) {\n        powScalarSignatures[signature] = pow.signatures[signature];\n      }\n    }\n  }\n  var powScalar = typed(powScalarSignatures);\n\n  /**\n   * Calculates the power of x to y element wise.\n   *\n   * Syntax:\n   *\n   *    math.dotPow(x, y)\n   *\n   * Examples:\n   *\n   *    math.dotPow(2, 3)            // returns number 8\n   *\n   *    const a = [[1, 2], [4, 3]]\n   *    math.dotPow(a, 2)            // returns Array [[1, 4], [16, 9]]\n   *    math.pow(a, 2)               // returns Array [[9, 8], [16, 17]]\n   *\n   * See also:\n   *\n   *    pow, sqrt, multiply\n   *\n   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base\n   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y  The exponent\n   * @return {number | BigNumber | Complex | Unit | Array | Matrix}                     The value of `x` to the power `y`\n   */\n  return typed(name, matrixAlgorithmSuite({\n    elop: powScalar,\n    SS: matAlgo07xSSf,\n    DS: matAlgo03xDSf,\n    Ss: matAlgo11xS0s,\n    sS: matAlgo12xSfs\n  }));\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAe;IAAU;IAAO;IAAe;CAAS;AAC9E,IAAI,eAAe,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACnE,IAAI,EACF,KAAK,EACL,WAAW,EACX,MAAM,EACN,GAAG,EACH,WAAW,EACX,MAAM,EACP,GAAG;IACJ,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,uBAAuB,CAAA,GAAA,uLAAA,CAAA,6BAA0B,AAAD,EAAE;QACpD;QACA;QACA;IACF;IACA,IAAI,sBAAsB,CAAC;IAC3B,IAAK,IAAI,aAAa,IAAI,UAAU,CAAE;QACpC,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,UAAU,EAAE,YAAY;YACnE,IAAI,CAAC,UAAU,QAAQ,CAAC,aAAa,CAAC,UAAU,QAAQ,CAAC,UAAU;gBACjE,mBAAmB,CAAC,UAAU,GAAG,IAAI,UAAU,CAAC,UAAU;YAC5D;QACF;IACF;IACA,IAAI,YAAY,MAAM;IAEtB;;;;;;;;;;;;;;;;;;;;;;GAsBC,GACD,OAAO,MAAM,MAAM,qBAAqB;QACtC,MAAM;QACN,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;IACN;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4251, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { createMatAlgo02xDS0 } from '../../type/matrix/utils/matAlgo02xDS0.js';\nimport { createMatAlgo03xDSf } from '../../type/matrix/utils/matAlgo03xDSf.js';\nimport { createMatAlgo07xSSf } from '../../type/matrix/utils/matAlgo07xSSf.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatAlgo12xSfs } from '../../type/matrix/utils/matAlgo12xSfs.js';\nimport { createMatrixAlgorithmSuite } from '../../type/matrix/utils/matrixAlgorithmSuite.js';\nvar name = 'dotDivide';\nvar dependencies = ['typed', 'matrix', 'equalScalar', 'divideScalar', 'DenseMatrix', 'concat'];\nexport var createDotDivide = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    equalScalar,\n    divideScalar,\n    DenseMatrix,\n    concat\n  } = _ref;\n  var matAlgo02xDS0 = createMatAlgo02xDS0({\n    typed,\n    equalScalar\n  });\n  var matAlgo03xDSf = createMatAlgo03xDSf({\n    typed\n  });\n  var matAlgo07xSSf = createMatAlgo07xSSf({\n    typed,\n    DenseMatrix\n  });\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matAlgo12xSfs = createMatAlgo12xSfs({\n    typed,\n    DenseMatrix\n  });\n  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({\n    typed,\n    matrix,\n    concat\n  });\n\n  /**\n   * Divide two matrices element wise. The function accepts both matrices and\n   * scalar values.\n   *\n   * Syntax:\n   *\n   *    math.dotDivide(x, y)\n   *\n   * Examples:\n   *\n   *    math.dotDivide(2, 4)   // returns 0.5\n   *\n   *    a = [[9, 5], [6, 1]]\n   *    b = [[3, 2], [5, 2]]\n   *\n   *    math.dotDivide(a, b)   // returns [[3, 2.5], [1.2, 0.5]]\n   *    math.divide(a, b)      // returns [[1.75, 0.75], [-1.75, 2.25]]\n   *\n   * See also:\n   *\n   *    divide, multiply, dotMultiply\n   *\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Numerator\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Denominator\n   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Quotient, `x ./ y`\n   */\n  return typed(name, matrixAlgorithmSuite({\n    elop: divideScalar,\n    SS: matAlgo07xSSf,\n    DS: matAlgo03xDSf,\n    SD: matAlgo02xDS0,\n    Ss: matAlgo11xS0s,\n    sS: matAlgo12xSfs\n  }));\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAe;IAAgB;IAAe;CAAS;AACvF,IAAI,kBAAkB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACtE,IAAI,EACF,KAAK,EACL,MAAM,EACN,WAAW,EACX,YAAY,EACZ,WAAW,EACX,MAAM,EACP,GAAG;IACJ,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,uBAAuB,CAAA,GAAA,uLAAA,CAAA,6BAA0B,AAAD,EAAE;QACpD;QACA;QACA;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;GAyBC,GACD,OAAO,MAAM,MAAM,qBAAqB;QACtC,MAAM;QACN,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;IACN;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4343, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/add.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { createMatAlgo01xDSid } from '../../type/matrix/utils/matAlgo01xDSid.js';\nimport { createMatAlgo04xSidSid } from '../../type/matrix/utils/matAlgo04xSidSid.js';\nimport { createMatAlgo10xSids } from '../../type/matrix/utils/matAlgo10xSids.js';\nimport { createMatrixAlgorithmSuite } from '../../type/matrix/utils/matrixAlgorithmSuite.js';\nvar name = 'add';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'equalScalar', 'DenseMatrix', 'SparseMatrix', 'concat'];\nexport var createAdd = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    addScalar,\n    equalScalar,\n    DenseMatrix,\n    SparseMatrix,\n    concat\n  } = _ref;\n  var matAlgo01xDSid = createMatAlgo01xDSid({\n    typed\n  });\n  var matAlgo04xSidSid = createMatAlgo04xSidSid({\n    typed,\n    equalScalar\n  });\n  var matAlgo10xSids = createMatAlgo10xSids({\n    typed,\n    DenseMatrix\n  });\n  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({\n    typed,\n    matrix,\n    concat\n  });\n  /**\n  * Add two or more values, `x + y`.\n  * For matrices, the function is evaluated element wise.\n  *\n  * Syntax:\n  *\n  *    math.add(x, y)\n  *    math.add(x, y, z, ...)\n  *\n  * Examples:\n  *\n  *    math.add(2, 3)               // returns number 5\n  *    math.add(2, 3, 4)            // returns number 9\n  *\n  *    const a = math.complex(2, 3)\n  *    const b = math.complex(-4, 1)\n  *    math.add(a, b)               // returns Complex -2 + 4i\n  *\n  *    math.add([1, 2, 3], 4)       // returns Array [5, 6, 7]\n  *\n  *    const c = math.unit('5 cm')\n  *    const d = math.unit('2.1 mm')\n  *    math.add(c, d)               // returns Unit 52.1 mm\n  *\n  *    math.add(\"2.3\", \"4\")         // returns number 6.3\n  *\n  * See also:\n  *\n  *    subtract, sum\n  *\n  * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x First value to add\n  * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} y Second value to add\n  * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`\n  */\n  return typed(name, {\n    'any, any': addScalar,\n    'any, any, ...any': typed.referToSelf(self => (x, y, rest) => {\n      var result = self(x, y);\n      for (var i = 0; i < rest.length; i++) {\n        result = self(result, rest[i]);\n      }\n      return result;\n    })\n  }, matrixAlgorithmSuite({\n    elop: addScalar,\n    DS: matAlgo01xDSid,\n    SS: matAlgo04xSidSid,\n    Ss: matAlgo10xSids\n  }));\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAa;IAAe;IAAe;IAAgB;CAAS;AACpG,IAAI,YAAY,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAChE,IAAI,EACF,KAAK,EACL,MAAM,EACN,SAAS,EACT,WAAW,EACX,WAAW,EACX,YAAY,EACZ,MAAM,EACP,GAAG;IACJ,IAAI,iBAAiB,CAAA,GAAA,iLAAA,CAAA,uBAAoB,AAAD,EAAE;QACxC;IACF;IACA,IAAI,mBAAmB,CAAA,GAAA,mLAAA,CAAA,yBAAsB,AAAD,EAAE;QAC5C;QACA;IACF;IACA,IAAI,iBAAiB,CAAA,GAAA,iLAAA,CAAA,uBAAoB,AAAD,EAAE;QACxC;QACA;IACF;IACA,IAAI,uBAAuB,CAAA,GAAA,uLAAA,CAAA,6BAA0B,AAAD,EAAE;QACpD;QACA;QACA;IACF;IACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiCA,GACA,OAAO,MAAM,MAAM;QACjB,YAAY;QACZ,oBAAoB,MAAM,WAAW,CAAC,CAAA,OAAQ,CAAC,GAAG,GAAG;gBACnD,IAAI,SAAS,KAAK,GAAG;gBACrB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;oBACpC,SAAS,KAAK,QAAQ,IAAI,CAAC,EAAE;gBAC/B;gBACA,OAAO;YACT;IACF,GAAG,qBAAqB;QACtB,MAAM;QACN,IAAI;QACJ,IAAI;QACJ,IAAI;IACN;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4439, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/hypot.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { flatten } from '../../utils/array.js';\nimport { isComplex } from '../../utils/is.js';\nvar name = 'hypot';\nvar dependencies = ['typed', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'sqrt', 'smaller', 'isPositive'];\nexport var createHypot = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    abs,\n    addScalar,\n    divideScalar,\n    multiplyScalar,\n    sqrt,\n    smaller,\n    isPositive\n  } = _ref;\n  /**\n   * Calculate the hypotenuse of a list with values. The hypotenuse is defined as:\n   *\n   *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)\n   *\n   * For matrix input, the hypotenuse is calculated for all values in the matrix.\n   *\n   * Syntax:\n   *\n   *     math.hypot(a, b, ...)\n   *     math.hypot([a, b, c, ...])\n   *\n   * Examples:\n   *\n   *     math.hypot(3, 4)      // 5\n   *     math.hypot(3, 4, 5)   // 7.0710678118654755\n   *     math.hypot([3, 4, 5]) // 7.0710678118654755\n   *     math.hypot(-2)        // 2\n   *\n   * See also:\n   *\n   *     abs, norm\n   *\n   * @param {... number | BigNumber | Array | Matrix} args    A list with numeric values or an Array or Matrix.\n   *                                                          Matrix and Array input is flattened and returns a\n   *                                                          single number for the whole matrix.\n   * @return {number | BigNumber} Returns the hypothenusa of the input values.\n   */\n  return typed(name, {\n    '... number | BigNumber': _hypot,\n    Array: _hypot,\n    Matrix: M => _hypot(flatten(M.toArray()))\n  });\n\n  /**\n   * Calculate the hypotenuse for an Array with values\n   * @param {Array.<number | BigNumber>} args\n   * @return {number | BigNumber} Returns the result\n   * @private\n   */\n  function _hypot(args) {\n    // code based on `hypot` from es6-shim:\n    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633\n    var result = 0;\n    var largest = 0;\n    for (var i = 0; i < args.length; i++) {\n      if (isComplex(args[i])) {\n        throw new TypeError('Unexpected type of argument to hypot');\n      }\n      var value = abs(args[i]);\n      if (smaller(largest, value)) {\n        result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));\n        result = addScalar(result, 1);\n        largest = value;\n      } else {\n        result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);\n      }\n    }\n    return multiplyScalar(largest, sqrt(result));\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAO;IAAa;IAAgB;IAAkB;IAAQ;IAAW;CAAa;AAC5G,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,KAAK,EACL,GAAG,EACH,SAAS,EACT,YAAY,EACZ,cAAc,EACd,IAAI,EACJ,OAAO,EACP,UAAU,EACX,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BC,GACD,OAAO,MAAM,MAAM;QACjB,0BAA0B;QAC1B,OAAO;QACP,QAAQ,CAAA,IAAK,OAAO,CAAA,GAAA,sJAAA,CAAA,UAAO,AAAD,EAAE,EAAE,OAAO;IACvC;;IAEA;;;;;GAKC,GACD,SAAS,OAAO,IAAI;QAClB,uCAAuC;QACvC,4EAA4E;QAC5E,IAAI,SAAS;QACb,IAAI,UAAU;QACd,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;YACpC,IAAI,CAAA,GAAA,mJAAA,CAAA,YAAS,AAAD,EAAE,IAAI,CAAC,EAAE,GAAG;gBACtB,MAAM,IAAI,UAAU;YACtB;YACA,IAAI,QAAQ,IAAI,IAAI,CAAC,EAAE;YACvB,IAAI,QAAQ,SAAS,QAAQ;gBAC3B,SAAS,eAAe,QAAQ,eAAe,aAAa,SAAS,QAAQ,aAAa,SAAS;gBACnG,SAAS,UAAU,QAAQ;gBAC3B,UAAU;YACZ,OAAO;gBACL,SAAS,UAAU,QAAQ,WAAW,SAAS,eAAe,aAAa,OAAO,UAAU,aAAa,OAAO,YAAY;YAC9H;QACF;QACA,OAAO,eAAe,SAAS,KAAK;IACtC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4526, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/norm.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'norm';\nvar dependencies = ['typed', 'abs', 'add', 'pow', 'conj', 'sqrt', 'multiply', 'equalScalar', 'larger', 'smaller', 'matrix', 'ctranspose', 'eigs'];\nexport var createNorm = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    abs,\n    add,\n    pow,\n    conj,\n    sqrt,\n    multiply,\n    equalScalar,\n    larger,\n    smaller,\n    matrix,\n    ctranspose,\n    eigs\n  } = _ref;\n  /**\n   * Calculate the norm of a number, vector or matrix.\n   *\n   * The second parameter p is optional. If not provided, it defaults to 2.\n   *\n   * Syntax:\n   *\n   *    math.norm(x)\n   *    math.norm(x, p)\n   *\n   * Examples:\n   *\n   *    math.abs(-3.5)                         // returns 3.5\n   *    math.norm(-3.5)                        // returns 3.5\n   *\n   *    math.norm(math.complex(3, -4))         // returns 5\n   *\n   *    math.norm([1, 2, -3], Infinity)        // returns 3\n   *    math.norm([1, 2, -3], -Infinity)       // returns 1\n   *\n   *    math.norm([3, 4], 2)                   // returns 5\n   *\n   *    math.norm([[1, 2], [3, 4]], 1)          // returns 6\n   *    math.norm([[1, 2], [3, 4]], 'inf')     // returns 7\n   *    math.norm([[1, 2], [3, 4]], 'fro')     // returns 5.477225575051661\n   *\n   * See also:\n   *\n   *    abs, hypot\n   *\n   * @param  {number | BigNumber | Complex | Array | Matrix} x\n   *            Value for which to calculate the norm\n   * @param  {number | BigNumber | string} [p=2]\n   *            Vector space.\n   *            Supported numbers include Infinity and -Infinity.\n   *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)\n   * @return {number | BigNumber} the p-norm\n   */\n  return typed(name, {\n    number: Math.abs,\n    Complex: function Complex(x) {\n      return x.abs();\n    },\n    BigNumber: function BigNumber(x) {\n      // norm(x) = abs(x)\n      return x.abs();\n    },\n    boolean: function boolean(x) {\n      // norm(x) = abs(x)\n      return Math.abs(x);\n    },\n    Array: function Array(x) {\n      return _norm(matrix(x), 2);\n    },\n    Matrix: function Matrix(x) {\n      return _norm(x, 2);\n    },\n    'Array, number | BigNumber | string': function Array_number__BigNumber__string(x, p) {\n      return _norm(matrix(x), p);\n    },\n    'Matrix, number | BigNumber | string': function Matrix_number__BigNumber__string(x, p) {\n      return _norm(x, p);\n    }\n  });\n\n  /**\n   * Calculate the plus infinity norm for a vector\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n  function _vectorNormPlusInfinity(x) {\n    // norm(x, Infinity) = max(abs(x))\n    var pinf = 0;\n    // skip zeros since abs(0) === 0\n    x.forEach(function (value) {\n      var v = abs(value);\n      if (larger(v, pinf)) {\n        pinf = v;\n      }\n    }, true);\n    return pinf;\n  }\n\n  /**\n   * Calculate the minus infinity norm for a vector\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n  function _vectorNormMinusInfinity(x) {\n    // norm(x, -Infinity) = min(abs(x))\n    var ninf;\n    // skip zeros since abs(0) === 0\n    x.forEach(function (value) {\n      var v = abs(value);\n      if (!ninf || smaller(v, ninf)) {\n        ninf = v;\n      }\n    }, true);\n    return ninf || 0;\n  }\n\n  /**\n   * Calculate the norm for a vector\n   * @param {Matrix} x\n   * @param {number | string} p\n   * @returns {number} Returns the norm\n   * @private\n   */\n  function _vectorNorm(x, p) {\n    // check p\n    if (p === Number.POSITIVE_INFINITY || p === 'inf') {\n      return _vectorNormPlusInfinity(x);\n    }\n    if (p === Number.NEGATIVE_INFINITY || p === '-inf') {\n      return _vectorNormMinusInfinity(x);\n    }\n    if (p === 'fro') {\n      return _norm(x, 2);\n    }\n    if (typeof p === 'number' && !isNaN(p)) {\n      // check p != 0\n      if (!equalScalar(p, 0)) {\n        // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p\n        var n = 0;\n        // skip zeros since abs(0) === 0\n        x.forEach(function (value) {\n          n = add(pow(abs(value), p), n);\n        }, true);\n        return pow(n, 1 / p);\n      }\n      return Number.POSITIVE_INFINITY;\n    }\n    // invalid parameter value\n    throw new Error('Unsupported parameter value');\n  }\n\n  /**\n   * Calculate the Frobenius norm for a matrix\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n  function _matrixNormFrobenius(x) {\n    // norm(x) = sqrt(sum(diag(x'x)))\n    var fro = 0;\n    x.forEach(function (value, index) {\n      fro = add(fro, multiply(value, conj(value)));\n    });\n    return abs(sqrt(fro));\n  }\n\n  /**\n   * Calculate the norm L1 for a matrix\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n  function _matrixNormOne(x) {\n    // norm(x) = the largest column sum\n    var c = [];\n    // result\n    var maxc = 0;\n    // skip zeros since abs(0) == 0\n    x.forEach(function (value, index) {\n      var j = index[1];\n      var cj = add(c[j] || 0, abs(value));\n      if (larger(cj, maxc)) {\n        maxc = cj;\n      }\n      c[j] = cj;\n    }, true);\n    return maxc;\n  }\n\n  /**\n   * Calculate the norm L2 for a matrix\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n  function _matrixNormTwo(x) {\n    // norm(x) = sqrt( max eigenvalue of A*.A)\n    var sizeX = x.size();\n    if (sizeX[0] !== sizeX[1]) {\n      throw new RangeError('Invalid matrix dimensions');\n    }\n    var tx = ctranspose(x);\n    var squaredX = multiply(tx, x);\n    var eigenVals = eigs(squaredX).values.toArray();\n    var rho = eigenVals[eigenVals.length - 1];\n    return abs(sqrt(rho));\n  }\n\n  /**\n   * Calculate the infinity norm for a matrix\n   * @param {Matrix} x\n   * @returns {number} Returns the norm\n   * @private\n   */\n  function _matrixNormInfinity(x) {\n    // norm(x) = the largest row sum\n    var r = [];\n    // result\n    var maxr = 0;\n    // skip zeros since abs(0) == 0\n    x.forEach(function (value, index) {\n      var i = index[0];\n      var ri = add(r[i] || 0, abs(value));\n      if (larger(ri, maxr)) {\n        maxr = ri;\n      }\n      r[i] = ri;\n    }, true);\n    return maxr;\n  }\n\n  /**\n   * Calculate the norm for a 2D Matrix (M*N)\n   * @param {Matrix} x\n   * @param {number | string} p\n   * @returns {number} Returns the norm\n   * @private\n   */\n  function _matrixNorm(x, p) {\n    // check p\n    if (p === 1) {\n      return _matrixNormOne(x);\n    }\n    if (p === Number.POSITIVE_INFINITY || p === 'inf') {\n      return _matrixNormInfinity(x);\n    }\n    if (p === 'fro') {\n      return _matrixNormFrobenius(x);\n    }\n    if (p === 2) {\n      return _matrixNormTwo(x);\n    } // invalid parameter value\n\n    throw new Error('Unsupported parameter value ' + p);\n  }\n\n  /**\n   * Calculate the norm for an array\n   * @param {Matrix} x\n   * @param {number | string} p\n   * @returns {number} Returns the norm\n   * @private\n   */\n  function _norm(x, p) {\n    // size\n    var sizeX = x.size();\n\n    // check if it is a vector\n    if (sizeX.length === 1) {\n      return _vectorNorm(x, p);\n    }\n    // MxN matrix\n    if (sizeX.length === 2) {\n      if (sizeX[0] && sizeX[1]) {\n        return _matrixNorm(x, p);\n      } else {\n        throw new RangeError('Invalid matrix dimensions');\n      }\n    }\n  }\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAO;IAAO;IAAO;IAAQ;IAAQ;IAAY;IAAe;IAAU;IAAW;IAAU;IAAc;CAAO;AAC1I,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACL,GAAG,EACH,GAAG,EACH,GAAG,EACH,IAAI,EACJ,IAAI,EACJ,QAAQ,EACR,WAAW,EACX,MAAM,EACN,OAAO,EACP,MAAM,EACN,UAAU,EACV,IAAI,EACL,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,KAAK,GAAG;QAChB,SAAS,SAAS,QAAQ,CAAC;YACzB,OAAO,EAAE,GAAG;QACd;QACA,WAAW,SAAS,UAAU,CAAC;YAC7B,mBAAmB;YACnB,OAAO,EAAE,GAAG;QACd;QACA,SAAS,SAAS,QAAQ,CAAC;YACzB,mBAAmB;YACnB,OAAO,KAAK,GAAG,CAAC;QAClB;QACA,OAAO,SAAS,MAAM,CAAC;YACrB,OAAO,MAAM,OAAO,IAAI;QAC1B;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,MAAM,GAAG;QAClB;QACA,sCAAsC,SAAS,gCAAgC,CAAC,EAAE,CAAC;YACjF,OAAO,MAAM,OAAO,IAAI;QAC1B;QACA,uCAAuC,SAAS,iCAAiC,CAAC,EAAE,CAAC;YACnF,OAAO,MAAM,GAAG;QAClB;IACF;;IAEA;;;;;GAKC,GACD,SAAS,wBAAwB,CAAC;QAChC,kCAAkC;QAClC,IAAI,OAAO;QACX,gCAAgC;QAChC,EAAE,OAAO,CAAC,SAAU,KAAK;YACvB,IAAI,IAAI,IAAI;YACZ,IAAI,OAAO,GAAG,OAAO;gBACnB,OAAO;YACT;QACF,GAAG;QACH,OAAO;IACT;IAEA;;;;;GAKC,GACD,SAAS,yBAAyB,CAAC;QACjC,mCAAmC;QACnC,IAAI;QACJ,gCAAgC;QAChC,EAAE,OAAO,CAAC,SAAU,KAAK;YACvB,IAAI,IAAI,IAAI;YACZ,IAAI,CAAC,QAAQ,QAAQ,GAAG,OAAO;gBAC7B,OAAO;YACT;QACF,GAAG;QACH,OAAO,QAAQ;IACjB;IAEA;;;;;;GAMC,GACD,SAAS,YAAY,CAAC,EAAE,CAAC;QACvB,UAAU;QACV,IAAI,MAAM,OAAO,iBAAiB,IAAI,MAAM,OAAO;YACjD,OAAO,wBAAwB;QACjC;QACA,IAAI,MAAM,OAAO,iBAAiB,IAAI,MAAM,QAAQ;YAClD,OAAO,yBAAyB;QAClC;QACA,IAAI,MAAM,OAAO;YACf,OAAO,MAAM,GAAG;QAClB;QACA,IAAI,OAAO,MAAM,YAAY,CAAC,MAAM,IAAI;YACtC,eAAe;YACf,IAAI,CAAC,YAAY,GAAG,IAAI;gBACtB,sCAAsC;gBACtC,IAAI,IAAI;gBACR,gCAAgC;gBAChC,EAAE,OAAO,CAAC,SAAU,KAAK;oBACvB,IAAI,IAAI,IAAI,IAAI,QAAQ,IAAI;gBAC9B,GAAG;gBACH,OAAO,IAAI,GAAG,IAAI;YACpB;YACA,OAAO,OAAO,iBAAiB;QACjC;QACA,0BAA0B;QAC1B,MAAM,IAAI,MAAM;IAClB;IAEA;;;;;GAKC,GACD,SAAS,qBAAqB,CAAC;QAC7B,iCAAiC;QACjC,IAAI,MAAM;QACV,EAAE,OAAO,CAAC,SAAU,KAAK,EAAE,KAAK;YAC9B,MAAM,IAAI,KAAK,SAAS,OAAO,KAAK;QACtC;QACA,OAAO,IAAI,KAAK;IAClB;IAEA;;;;;GAKC,GACD,SAAS,eAAe,CAAC;QACvB,mCAAmC;QACnC,IAAI,IAAI,EAAE;QACV,SAAS;QACT,IAAI,OAAO;QACX,+BAA+B;QAC/B,EAAE,OAAO,CAAC,SAAU,KAAK,EAAE,KAAK;YAC9B,IAAI,IAAI,KAAK,CAAC,EAAE;YAChB,IAAI,KAAK,IAAI,CAAC,CAAC,EAAE,IAAI,GAAG,IAAI;YAC5B,IAAI,OAAO,IAAI,OAAO;gBACpB,OAAO;YACT;YACA,CAAC,CAAC,EAAE,GAAG;QACT,GAAG;QACH,OAAO;IACT;IAEA;;;;;GAKC,GACD,SAAS,eAAe,CAAC;QACvB,0CAA0C;QAC1C,IAAI,QAAQ,EAAE,IAAI;QAClB,IAAI,KAAK,CAAC,EAAE,KAAK,KAAK,CAAC,EAAE,EAAE;YACzB,MAAM,IAAI,WAAW;QACvB;QACA,IAAI,KAAK,WAAW;QACpB,IAAI,WAAW,SAAS,IAAI;QAC5B,IAAI,YAAY,KAAK,UAAU,MAAM,CAAC,OAAO;QAC7C,IAAI,MAAM,SAAS,CAAC,UAAU,MAAM,GAAG,EAAE;QACzC,OAAO,IAAI,KAAK;IAClB;IAEA;;;;;GAKC,GACD,SAAS,oBAAoB,CAAC;QAC5B,gCAAgC;QAChC,IAAI,IAAI,EAAE;QACV,SAAS;QACT,IAAI,OAAO;QACX,+BAA+B;QAC/B,EAAE,OAAO,CAAC,SAAU,KAAK,EAAE,KAAK;YAC9B,IAAI,IAAI,KAAK,CAAC,EAAE;YAChB,IAAI,KAAK,IAAI,CAAC,CAAC,EAAE,IAAI,GAAG,IAAI;YAC5B,IAAI,OAAO,IAAI,OAAO;gBACpB,OAAO;YACT;YACA,CAAC,CAAC,EAAE,GAAG;QACT,GAAG;QACH,OAAO;IACT;IAEA;;;;;;GAMC,GACD,SAAS,YAAY,CAAC,EAAE,CAAC;QACvB,UAAU;QACV,IAAI,MAAM,GAAG;YACX,OAAO,eAAe;QACxB;QACA,IAAI,MAAM,OAAO,iBAAiB,IAAI,MAAM,OAAO;YACjD,OAAO,oBAAoB;QAC7B;QACA,IAAI,MAAM,OAAO;YACf,OAAO,qBAAqB;QAC9B;QACA,IAAI,MAAM,GAAG;YACX,OAAO,eAAe;QACxB,EAAE,0BAA0B;QAE5B,MAAM,IAAI,MAAM,iCAAiC;IACnD;IAEA;;;;;;GAMC,GACD,SAAS,MAAM,CAAC,EAAE,CAAC;QACjB,OAAO;QACP,IAAI,QAAQ,EAAE,IAAI;QAElB,0BAA0B;QAC1B,IAAI,MAAM,MAAM,KAAK,GAAG;YACtB,OAAO,YAAY,GAAG;QACxB;QACA,aAAa;QACb,IAAI,MAAM,MAAM,KAAK,GAAG;YACtB,IAAI,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,EAAE,EAAE;gBACxB,OAAO,YAAY,GAAG;YACxB,OAAO;gBACL,MAAM,IAAI,WAAW;YACvB;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4803, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/arithmetic/divide.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { extend } from '../../utils/object.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js';\nvar name = 'divide';\nvar dependencies = ['typed', 'matrix', 'multiply', 'equalScalar', 'divideScalar', 'inv'];\nexport var createDivide = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    multiply,\n    equalScalar,\n    divideScalar,\n    inv\n  } = _ref;\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n\n  /**\n   * Divide two values, `x / y`.\n   * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.\n   *\n   * Syntax:\n   *\n   *    math.divide(x, y)\n   *\n   * Examples:\n   *\n   *    math.divide(2, 3)            // returns number 0.6666666666666666\n   *\n   *    const a = math.complex(5, 14)\n   *    const b = math.complex(4, 1)\n   *    math.divide(a, b)            // returns Complex 2 + 3i\n   *\n   *    const c = [[7, -6], [13, -4]]\n   *    const d = [[1, 2], [4, 3]]\n   *    math.divide(c, d)            // returns Array [[-9, 4], [-11, 6]]\n   *\n   *    const e = math.unit('18 km')\n   *    math.divide(e, 4.5)          // returns Unit 4 km\n   *\n   * See also:\n   *\n   *    multiply\n   *\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x   Numerator\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Array | Matrix} y          Denominator\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`\n   */\n  return typed('divide', extend({\n    // we extend the signatures of divideScalar with signatures dealing with matrices\n\n    'Array | Matrix, Array | Matrix': function Array__Matrix_Array__Matrix(x, y) {\n      // TODO: implement matrix right division using pseudo inverse\n      // https://www.mathworks.nl/help/matlab/ref/mrdivide.html\n      // https://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html\n      // https://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour\n      return multiply(x, inv(y));\n    },\n    'DenseMatrix, any': function DenseMatrix_any(x, y) {\n      return matAlgo14xDs(x, y, divideScalar, false);\n    },\n    'SparseMatrix, any': function SparseMatrix_any(x, y) {\n      return matAlgo11xS0s(x, y, divideScalar, false);\n    },\n    'Array, any': function Array_any(x, y) {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(x), y, divideScalar, false).valueOf();\n    },\n    'any, Array | Matrix': function any_Array__Matrix(x, y) {\n      return multiply(x, inv(y));\n    }\n  }, divideScalar.signatures));\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAY;IAAe;IAAgB;CAAM;AACjF,IAAI,eAAe,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACnE,IAAI,EACF,KAAK,EACL,MAAM,EACN,QAAQ,EACR,WAAW,EACX,YAAY,EACZ,GAAG,EACJ,GAAG;IACJ,IAAI,gBAAgB,CAAA,GAAA,gLAAA,CAAA,sBAAmB,AAAD,EAAE;QACtC;QACA;IACF;IACA,IAAI,eAAe,CAAA,GAAA,+KAAA,CAAA,qBAAkB,AAAD,EAAE;QACpC;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8BC,GACD,OAAO,MAAM,UAAU,CAAA,GAAA,uJAAA,CAAA,SAAM,AAAD,EAAE;QAC5B,iFAAiF;QAEjF,kCAAkC,SAAS,4BAA4B,CAAC,EAAE,CAAC;YACzE,6DAA6D;YAC7D,yDAAyD;YACzD,0EAA0E;YAC1E,qHAAqH;YACrH,OAAO,SAAS,GAAG,IAAI;QACzB;QACA,oBAAoB,SAAS,gBAAgB,CAAC,EAAE,CAAC;YAC/C,OAAO,aAAa,GAAG,GAAG,cAAc;QAC1C;QACA,qBAAqB,SAAS,iBAAiB,CAAC,EAAE,CAAC;YACjD,OAAO,cAAc,GAAG,GAAG,cAAc;QAC3C;QACA,cAAc,SAAS,UAAU,CAAC,EAAE,CAAC;YACnC,4BAA4B;YAC5B,OAAO,aAAa,OAAO,IAAI,GAAG,cAAc,OAAO,OAAO;QAChE;QACA,uBAAuB,SAAS,kBAAkB,CAAC,EAAE,CAAC;YACpD,OAAO,SAAS,GAAG,IAAI;QACzB;IACF,GAAG,aAAa,UAAU;AAC5B","ignoreList":[0],"debugId":null}}]
}