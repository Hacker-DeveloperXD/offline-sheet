{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromFunction';\nvar dependencies = ['typed', 'matrix', 'isZero'];\nexport var createMatrixFromFunction = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    isZero\n  } = _ref;\n  /**\n   * Create a matrix by evaluating a generating function at each index.\n   * The simplest overload returns a multi-dimensional array as long as `size` is an array.\n   * Passing `size` as a Matrix or specifying a `format` will result in returning a Matrix.\n   *\n   * Syntax:\n   *\n   *    math.matrixFromFunction(size, fn)\n   *    math.matrixFromFunction(size, fn, format)\n   *    math.matrixFromFunction(size, fn, format, datatype)\n   *    math.matrixFromFunction(size, format, fn)\n   *    math.matrixFromFunction(size, format, datatype, fn)\n   *\n   * Examples:\n   *\n   *    math.matrixFromFunction([3,3], i => i[0] - i[1]) // an antisymmetric matrix\n   *    math.matrixFromFunction([100, 100], 'sparse', i => i[0] - i[1] === 1 ? 4 : 0) // a sparse subdiagonal matrix\n   *    math.matrixFromFunction([5], i => math.random()) // a random vector\n   *\n   * See also:\n   *\n   *    matrix, zeros\n   *\n   * @param {Array | Matrix} size   The size of the matrix to be created\n   * @param {function} fn           Callback function invoked for every entry in the matrix\n   * @param {string} [format]       The Matrix storage format, either `'dense'` or `'sparse'`\n   * @param {string} [datatype]     Type of the values\n   * @return {Array | Matrix} Returns the created matrix\n   */\n  return typed(name, {\n    'Array | Matrix, function, string, string': function Array__Matrix_function_string_string(size, fn, format, datatype) {\n      return _create(size, fn, format, datatype);\n    },\n    'Array | Matrix, function, string': function Array__Matrix_function_string(size, fn, format) {\n      return _create(size, fn, format);\n    },\n    'Matrix, function': function Matrix_function(size, fn) {\n      return _create(size, fn, 'dense');\n    },\n    'Array, function': function Array_function(size, fn) {\n      return _create(size, fn, 'dense').toArray();\n    },\n    'Array | Matrix, string, function': function Array__Matrix_string_function(size, format, fn) {\n      return _create(size, fn, format);\n    },\n    'Array | Matrix, string, string, function': function Array__Matrix_string_string_function(size, format, datatype, fn) {\n      return _create(size, fn, format, datatype);\n    }\n  });\n  function _create(size, fn, format, datatype) {\n    var m;\n    if (datatype !== undefined) {\n      m = matrix(format, datatype);\n    } else {\n      m = matrix(format);\n    }\n    m.resize(size);\n    m.forEach(function (_, index) {\n      var val = fn(index);\n      if (isZero(val)) return;\n      m.set(index, val);\n    });\n    return m;\n  }\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;CAAS;AACzC,IAAI,2BAA2B,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAC/E,IAAI,EACF,KAAK,EACL,MAAM,EACN,MAAM,EACP,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BC,GACD,OAAO,MAAM,MAAM;QACjB,4CAA4C,SAAS,qCAAqC,IAAI,EAAE,EAAE,EAAE,MAAM,EAAE,QAAQ;YAClH,OAAO,QAAQ,MAAM,IAAI,QAAQ;QACnC;QACA,oCAAoC,SAAS,8BAA8B,IAAI,EAAE,EAAE,EAAE,MAAM;YACzF,OAAO,QAAQ,MAAM,IAAI;QAC3B;QACA,oBAAoB,SAAS,gBAAgB,IAAI,EAAE,EAAE;YACnD,OAAO,QAAQ,MAAM,IAAI;QAC3B;QACA,mBAAmB,SAAS,eAAe,IAAI,EAAE,EAAE;YACjD,OAAO,QAAQ,MAAM,IAAI,SAAS,OAAO;QAC3C;QACA,oCAAoC,SAAS,8BAA8B,IAAI,EAAE,MAAM,EAAE,EAAE;YACzF,OAAO,QAAQ,MAAM,IAAI;QAC3B;QACA,4CAA4C,SAAS,qCAAqC,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,EAAE;YAClH,OAAO,QAAQ,MAAM,IAAI,QAAQ;QACnC;IACF;;IACA,SAAS,QAAQ,IAAI,EAAE,EAAE,EAAE,MAAM,EAAE,QAAQ;QACzC,IAAI;QACJ,IAAI,aAAa,WAAW;YAC1B,IAAI,OAAO,QAAQ;QACrB,OAAO;YACL,IAAI,OAAO;QACb;QACA,EAAE,MAAM,CAAC;QACT,EAAE,OAAO,CAAC,SAAU,CAAC,EAAE,KAAK;YAC1B,IAAI,MAAM,GAAG;YACb,IAAI,OAAO,MAAM;YACjB,EAAE,GAAG,CAAC,OAAO;QACf;QACA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromRows';\nvar dependencies = ['typed', 'matrix', 'flatten', 'size'];\nexport var createMatrixFromRows = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    flatten,\n    size\n  } = _ref;\n  /**\n   * Create a dense matrix from vectors as individual rows.\n   * If you pass column vectors, they will be transposed (but not conjugated!)\n   *\n   * Syntax:\n   *\n   *    math.matrixFromRows(...arr)\n   *    math.matrixFromRows(row1, row2)\n   *    math.matrixFromRows(row1, row2, row3)\n   *\n   * Examples:\n   *\n   *    math.matrixFromRows([1, 2, 3], [[4],[5],[6]])\n   *    math.matrixFromRows(...vectors)\n   *\n   * See also:\n   *\n   *    matrix, matrixFromColumns, matrixFromFunction, zeros\n   *\n   * @param {... Array | Matrix} rows  Multiple rows\n   * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned\n   */\n  return typed(name, {\n    '...Array': function Array(arr) {\n      return _createArray(arr);\n    },\n    '...Matrix': function Matrix(arr) {\n      return matrix(_createArray(arr.map(m => m.toArray())));\n    }\n\n    // TODO implement this properly for SparseMatrix\n  });\n  function _createArray(arr) {\n    if (arr.length === 0) throw new TypeError('At least one row is needed to construct a matrix.');\n    var N = checkVectorTypeAndReturnLength(arr[0]);\n    var result = [];\n    for (var row of arr) {\n      var rowLength = checkVectorTypeAndReturnLength(row);\n      if (rowLength !== N) {\n        throw new TypeError('The vectors had different length: ' + (N | 0) + ' ≠ ' + (rowLength | 0));\n      }\n      result.push(flatten(row));\n    }\n    return result;\n  }\n  function checkVectorTypeAndReturnLength(vec) {\n    var s = size(vec);\n    if (s.length === 1) {\n      // 1D vector\n      return s[0];\n    } else if (s.length === 2) {\n      // 2D vector\n      if (s[0] === 1) {\n        // row vector\n        return s[1];\n      } else if (s[1] === 1) {\n        // col vector\n        return s[0];\n      } else {\n        throw new TypeError('At least one of the arguments is not a vector.');\n      }\n    } else {\n      throw new TypeError('Only one- or two-dimensional vectors are supported.');\n    }\n  }\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAW;CAAO;AAClD,IAAI,uBAAuB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAC3E,IAAI,EACF,KAAK,EACL,MAAM,EACN,OAAO,EACP,IAAI,EACL,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;GAqBC,GACD,OAAO,MAAM,MAAM;QACjB,YAAY,SAAS,MAAM,GAAG;YAC5B,OAAO,aAAa;QACtB;QACA,aAAa,SAAS,OAAO,GAAG;YAC9B,OAAO,OAAO,aAAa,IAAI,GAAG,CAAC,CAAA,IAAK,EAAE,OAAO;QACnD;IAGF;;IACA,SAAS,aAAa,GAAG;QACvB,IAAI,IAAI,MAAM,KAAK,GAAG,MAAM,IAAI,UAAU;QAC1C,IAAI,IAAI,+BAA+B,GAAG,CAAC,EAAE;QAC7C,IAAI,SAAS,EAAE;QACf,KAAK,IAAI,OAAO,IAAK;YACnB,IAAI,YAAY,+BAA+B;YAC/C,IAAI,cAAc,GAAG;gBACnB,MAAM,IAAI,UAAU,uCAAuC,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,YAAY,CAAC;YAC7F;YACA,OAAO,IAAI,CAAC,QAAQ;QACtB;QACA,OAAO;IACT;IACA,SAAS,+BAA+B,GAAG;QACzC,IAAI,IAAI,KAAK;QACb,IAAI,EAAE,MAAM,KAAK,GAAG;YAClB,YAAY;YACZ,OAAO,CAAC,CAAC,EAAE;QACb,OAAO,IAAI,EAAE,MAAM,KAAK,GAAG;YACzB,YAAY;YACZ,IAAI,CAAC,CAAC,EAAE,KAAK,GAAG;gBACd,aAAa;gBACb,OAAO,CAAC,CAAC,EAAE;YACb,OAAO,IAAI,CAAC,CAAC,EAAE,KAAK,GAAG;gBACrB,aAAa;gBACb,OAAO,CAAC,CAAC,EAAE;YACb,OAAO;gBACL,MAAM,IAAI,UAAU;YACtB;QACF,OAAO;YACL,MAAM,IAAI,UAAU;QACtB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromColumns';\nvar dependencies = ['typed', 'matrix', 'flatten', 'size'];\nexport var createMatrixFromColumns = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    flatten,\n    size\n  } = _ref;\n  /**\n   * Create a dense matrix from vectors as individual columns.\n   * If you pass row vectors, they will be transposed (but not conjugated!)\n   *\n   * Syntax:\n   *\n   *    math.matrixFromColumns(...arr)\n   *    math.matrixFromColumns(col1, col2)\n   *    math.matrixFromColumns(col1, col2, col3)\n   *\n   * Examples:\n   *\n   *    math.matrixFromColumns([1, 2, 3], [[4],[5],[6]])\n   *    math.matrixFromColumns(...vectors)\n   *\n   * See also:\n   *\n   *    matrix, matrixFromRows, matrixFromFunction, zeros\n   *\n   * @param {... Array | Matrix} cols Multiple columns\n   * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned\n   */\n  return typed(name, {\n    '...Array': function Array(arr) {\n      return _createArray(arr);\n    },\n    '...Matrix': function Matrix(arr) {\n      return matrix(_createArray(arr.map(m => m.toArray())));\n    }\n\n    // TODO implement this properly for SparseMatrix\n  });\n  function _createArray(arr) {\n    if (arr.length === 0) throw new TypeError('At least one column is needed to construct a matrix.');\n    var N = checkVectorTypeAndReturnLength(arr[0]);\n\n    // create an array with empty rows\n    var result = [];\n    for (var i = 0; i < N; i++) {\n      result[i] = [];\n    }\n\n    // loop columns\n    for (var col of arr) {\n      var colLength = checkVectorTypeAndReturnLength(col);\n      if (colLength !== N) {\n        throw new TypeError('The vectors had different length: ' + (N | 0) + ' ≠ ' + (colLength | 0));\n      }\n      var f = flatten(col);\n\n      // push a value to each row\n      for (var _i = 0; _i < N; _i++) {\n        result[_i].push(f[_i]);\n      }\n    }\n    return result;\n  }\n  function checkVectorTypeAndReturnLength(vec) {\n    var s = size(vec);\n    if (s.length === 1) {\n      // 1D vector\n      return s[0];\n    } else if (s.length === 2) {\n      // 2D vector\n      if (s[0] === 1) {\n        // row vector\n        return s[1];\n      } else if (s[1] === 1) {\n        // col vector\n        return s[0];\n      } else {\n        throw new TypeError('At least one of the arguments is not a vector.');\n      }\n    } else {\n      throw new TypeError('Only one- or two-dimensional vectors are supported.');\n    }\n  }\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAW;CAAO;AAClD,IAAI,0BAA0B,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAC9E,IAAI,EACF,KAAK,EACL,MAAM,EACN,OAAO,EACP,IAAI,EACL,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;GAqBC,GACD,OAAO,MAAM,MAAM;QACjB,YAAY,SAAS,MAAM,GAAG;YAC5B,OAAO,aAAa;QACtB;QACA,aAAa,SAAS,OAAO,GAAG;YAC9B,OAAO,OAAO,aAAa,IAAI,GAAG,CAAC,CAAA,IAAK,EAAE,OAAO;QACnD;IAGF;;IACA,SAAS,aAAa,GAAG;QACvB,IAAI,IAAI,MAAM,KAAK,GAAG,MAAM,IAAI,UAAU;QAC1C,IAAI,IAAI,+BAA+B,GAAG,CAAC,EAAE;QAE7C,kCAAkC;QAClC,IAAI,SAAS,EAAE;QACf,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YAC1B,MAAM,CAAC,EAAE,GAAG,EAAE;QAChB;QAEA,eAAe;QACf,KAAK,IAAI,OAAO,IAAK;YACnB,IAAI,YAAY,+BAA+B;YAC/C,IAAI,cAAc,GAAG;gBACnB,MAAM,IAAI,UAAU,uCAAuC,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,YAAY,CAAC;YAC7F;YACA,IAAI,IAAI,QAAQ;YAEhB,2BAA2B;YAC3B,IAAK,IAAI,KAAK,GAAG,KAAK,GAAG,KAAM;gBAC7B,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG;YACvB;QACF;QACA,OAAO;IACT;IACA,SAAS,+BAA+B,GAAG;QACzC,IAAI,IAAI,KAAK;QACb,IAAI,EAAE,MAAM,KAAK,GAAG;YAClB,YAAY;YACZ,OAAO,CAAC,CAAC,EAAE;QACb,OAAO,IAAI,EAAE,MAAM,KAAK,GAAG;YACzB,YAAY;YACZ,IAAI,CAAC,CAAC,EAAE,KAAK,GAAG;gBACd,aAAa;gBACb,OAAO,CAAC,CAAC,EAAE;YACb,OAAO,IAAI,CAAC,CAAC,EAAE,KAAK,GAAG;gBACrB,aAAa;gBACb,OAAO,CAAC,CAAC,EAAE;YACb,OAAO;gBACL,MAAM,IAAI,UAAU;YACtB;QACF,OAAO;YACL,MAAM,IAAI,UAAU;QACtB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 268, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/apply.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { arraySize } from '../../utils/array.js';\nimport { isMatrix } from '../../utils/is.js';\nimport { IndexError } from '../../error/IndexError.js';\nvar name = 'apply';\nvar dependencies = ['typed', 'isInteger'];\nexport var createApply = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    isInteger\n  } = _ref;\n  /**\n   * Apply a function that maps an array to a scalar\n   * along a given axis of a matrix or array.\n   * Returns a new matrix or array with one less dimension than the input.\n   *\n   * Syntax:\n   *\n   *     math.apply(A, dim, callback)\n   *\n   * Where:\n   *\n   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.\n   *\n   * Examples:\n   *\n   *    const A = [[1, 2], [3, 4]]\n   *    const sum = math.sum\n   *\n   *    math.apply(A, 0, sum)             // returns [4, 6]\n   *    math.apply(A, 1, sum)             // returns [3, 7]\n   *\n   * See also:\n   *\n   *    map, filter, forEach\n   *\n   * @param {Array | Matrix} array   The input Matrix\n   * @param {number} dim             The dimension along which the callback is applied\n   * @param {Function} callback      The callback function that is applied. This Function\n   *                                 should take an array or 1-d matrix as an input and\n   *                                 return a number.\n   * @return {Array | Matrix} res    The residual matrix with the function applied over some dimension.\n   */\n  return typed(name, {\n    'Array | Matrix, number | BigNumber, function': function Array__Matrix_number__BigNumber_function(mat, dim, callback) {\n      if (!isInteger(dim)) {\n        throw new TypeError('Integer number expected for dimension');\n      }\n      var size = Array.isArray(mat) ? arraySize(mat) : mat.size();\n      if (dim < 0 || dim >= size.length) {\n        throw new IndexError(dim, size.length);\n      }\n      if (isMatrix(mat)) {\n        return mat.create(_apply(mat.valueOf(), dim, callback), mat.datatype());\n      } else {\n        return _apply(mat, dim, callback);\n      }\n    }\n  });\n});\n\n/**\n * Recursively reduce a matrix\n * @param {Array} mat\n * @param {number} dim\n * @param {Function} callback\n * @returns {Array} ret\n * @private\n */\nfunction _apply(mat, dim, callback) {\n  var i, ret, tran;\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      return callback(mat);\n    } else {\n      tran = _switch(mat);\n      ret = [];\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _apply(tran[i], dim - 1, callback);\n      }\n      return ret;\n    }\n  } else {\n    ret = [];\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _apply(mat[i], dim - 1, callback);\n    }\n    return ret;\n  }\n}\n\n/**\n * Transpose a matrix\n * @param {Array} mat\n * @returns {Array} ret\n * @private\n */\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n    ret.push(tmp);\n  }\n  return ret;\n}"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;CAAY;AAClC,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,KAAK,EACL,SAAS,EACV,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BC,GACD,OAAO,MAAM,MAAM;QACjB,gDAAgD,SAAS,yCAAyC,GAAG,EAAE,GAAG,EAAE,QAAQ;YAClH,IAAI,CAAC,UAAU,MAAM;gBACnB,MAAM,IAAI,UAAU;YACtB;YACA,IAAI,OAAO,MAAM,OAAO,CAAC,OAAO,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE,OAAO,IAAI,IAAI;YACzD,IAAI,MAAM,KAAK,OAAO,KAAK,MAAM,EAAE;gBACjC,MAAM,IAAI,2JAAA,CAAA,aAAU,CAAC,KAAK,KAAK,MAAM;YACvC;YACA,IAAI,CAAA,GAAA,mJAAA,CAAA,WAAQ,AAAD,EAAE,MAAM;gBACjB,OAAO,IAAI,MAAM,CAAC,OAAO,IAAI,OAAO,IAAI,KAAK,WAAW,IAAI,QAAQ;YACtE,OAAO;gBACL,OAAO,OAAO,KAAK,KAAK;YAC1B;QACF;IACF;AACF;AAEA;;;;;;;CAOC,GACD,SAAS,OAAO,GAAG,EAAE,GAAG,EAAE,QAAQ;IAChC,IAAI,GAAG,KAAK;IACZ,IAAI,OAAO,GAAG;QACZ,IAAI,CAAC,MAAM,OAAO,CAAC,GAAG,CAAC,EAAE,GAAG;YAC1B,OAAO,SAAS;QAClB,OAAO;YACL,OAAO,QAAQ;YACf,MAAM,EAAE;YACR,IAAK,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;gBAChC,GAAG,CAAC,EAAE,GAAG,OAAO,IAAI,CAAC,EAAE,EAAE,MAAM,GAAG;YACpC;YACA,OAAO;QACT;IACF,OAAO;QACL,MAAM,EAAE;QACR,IAAK,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAK;YAC/B,GAAG,CAAC,EAAE,GAAG,OAAO,GAAG,CAAC,EAAE,EAAE,MAAM,GAAG;QACnC;QACA,OAAO;IACT;AACF;AAEA;;;;;CAKC,GACD,SAAS,QAAQ,GAAG;IAClB,IAAI,IAAI,IAAI,MAAM;IAClB,IAAI,IAAI,GAAG,CAAC,EAAE,CAAC,MAAM;IACrB,IAAI,GAAG;IACP,IAAI,MAAM,EAAE;IACZ,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;QACtB,IAAI,MAAM,EAAE;QACZ,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;YACtB,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;QACpB;QACA,IAAI,IAAI,CAAC;IACX;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/concat.js"],"sourcesContent":["import { isBigNumber, isMatrix, isNumber } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { arraySize, concat as _concat } from '../../utils/array.js';\nimport { IndexError } from '../../error/IndexError.js';\nimport { DimensionError } from '../../error/DimensionError.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'concat';\nvar dependencies = ['typed', 'matrix', 'isInteger'];\nexport var createConcat = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    isInteger\n  } = _ref;\n  /**\n   * Concatenate two or more matrices.\n   *\n   * Syntax:\n   *\n   *     math.concat(A, B, C, ...)\n   *     math.concat(A, B, C, ..., dim)\n   *\n   * Where:\n   *\n   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.\n   *   By default the last dimension of the matrices.\n   *\n   * Examples:\n   *\n   *    const A = [[1, 2], [5, 6]]\n   *    const B = [[3, 4], [7, 8]]\n   *\n   *    math.concat(A, B)                  // returns [[1, 2, 3, 4], [5, 6, 7, 8]]\n   *    math.concat(A, B, 0)               // returns [[1, 2], [5, 6], [3, 4], [7, 8]]\n   *    math.concat('hello', ' ', 'world') // returns 'hello world'\n   *\n   * See also:\n   *\n   *    size, squeeze, subset, transpose\n   *\n   * @param {... Array | Matrix} args     Two or more matrices\n   * @return {Array | Matrix} Concatenated matrix\n   */\n  return typed(name, {\n    // TODO: change signature to '...Array | Matrix, dim?' when supported\n    '...Array | Matrix | number | BigNumber': function Array__Matrix__number__BigNumber(args) {\n      var i;\n      var len = args.length;\n      var dim = -1; // zero-based dimension\n      var prevDim;\n      var asMatrix = false;\n      var matrices = []; // contains multi dimensional arrays\n\n      for (i = 0; i < len; i++) {\n        var arg = args[i];\n\n        // test whether we need to return a Matrix (if not we return an Array)\n        if (isMatrix(arg)) {\n          asMatrix = true;\n        }\n        if (isNumber(arg) || isBigNumber(arg)) {\n          if (i !== len - 1) {\n            throw new Error('Dimension must be specified as last argument');\n          }\n\n          // last argument contains the dimension on which to concatenate\n          prevDim = dim;\n          dim = arg.valueOf(); // change BigNumber to number\n\n          if (!isInteger(dim)) {\n            throw new TypeError('Integer number expected for dimension');\n          }\n          if (dim < 0 || i > 0 && dim > prevDim) {\n            // TODO: would be more clear when throwing a DimensionError here\n            throw new IndexError(dim, prevDim + 1);\n          }\n        } else {\n          // this is a matrix or array\n          var m = clone(arg).valueOf();\n          var size = arraySize(m);\n          matrices[i] = m;\n          prevDim = dim;\n          dim = size.length - 1;\n\n          // verify whether each of the matrices has the same number of dimensions\n          if (i > 0 && dim !== prevDim) {\n            throw new DimensionError(prevDim + 1, dim + 1);\n          }\n        }\n      }\n      if (matrices.length === 0) {\n        throw new SyntaxError('At least one matrix expected');\n      }\n      var res = matrices.shift();\n      while (matrices.length) {\n        res = _concat(res, matrices.shift(), dim);\n      }\n      return asMatrix ? matrix(res) : res;\n    },\n    '...string': function string(args) {\n      return args.join('');\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;CAAY;AAC5C,IAAI,eAAe,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACnE,IAAI,EACF,KAAK,EACL,MAAM,EACN,SAAS,EACV,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BC,GACD,OAAO,MAAM,MAAM;QACjB,qEAAqE;QACrE,0CAA0C,SAAS,iCAAiC,IAAI;YACtF,IAAI;YACJ,IAAI,MAAM,KAAK,MAAM;YACrB,IAAI,MAAM,CAAC,GAAG,uBAAuB;YACrC,IAAI;YACJ,IAAI,WAAW;YACf,IAAI,WAAW,EAAE,EAAE,oCAAoC;YAEvD,IAAK,IAAI,GAAG,IAAI,KAAK,IAAK;gBACxB,IAAI,MAAM,IAAI,CAAC,EAAE;gBAEjB,sEAAsE;gBACtE,IAAI,CAAA,GAAA,mJAAA,CAAA,WAAQ,AAAD,EAAE,MAAM;oBACjB,WAAW;gBACb;gBACA,IAAI,CAAA,GAAA,mJAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,CAAA,GAAA,mJAAA,CAAA,cAAW,AAAD,EAAE,MAAM;oBACrC,IAAI,MAAM,MAAM,GAAG;wBACjB,MAAM,IAAI,MAAM;oBAClB;oBAEA,+DAA+D;oBAC/D,UAAU;oBACV,MAAM,IAAI,OAAO,IAAI,6BAA6B;oBAElD,IAAI,CAAC,UAAU,MAAM;wBACnB,MAAM,IAAI,UAAU;oBACtB;oBACA,IAAI,MAAM,KAAK,IAAI,KAAK,MAAM,SAAS;wBACrC,gEAAgE;wBAChE,MAAM,IAAI,2JAAA,CAAA,aAAU,CAAC,KAAK,UAAU;oBACtC;gBACF,OAAO;oBACL,4BAA4B;oBAC5B,IAAI,IAAI,CAAA,GAAA,uJAAA,CAAA,QAAK,AAAD,EAAE,KAAK,OAAO;oBAC1B,IAAI,OAAO,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE;oBACrB,QAAQ,CAAC,EAAE,GAAG;oBACd,UAAU;oBACV,MAAM,KAAK,MAAM,GAAG;oBAEpB,wEAAwE;oBACxE,IAAI,IAAI,KAAK,QAAQ,SAAS;wBAC5B,MAAM,IAAI,+JAAA,CAAA,iBAAc,CAAC,UAAU,GAAG,MAAM;oBAC9C;gBACF;YACF;YACA,IAAI,SAAS,MAAM,KAAK,GAAG;gBACzB,MAAM,IAAI,YAAY;YACxB;YACA,IAAI,MAAM,SAAS,KAAK;YACxB,MAAO,SAAS,MAAM,CAAE;gBACtB,MAAM,CAAA,GAAA,sJAAA,CAAA,SAAO,AAAD,EAAE,KAAK,SAAS,KAAK,IAAI;YACvC;YACA,OAAO,WAAW,OAAO,OAAO;QAClC;QACA,aAAa,SAAS,OAAO,IAAI;YAC/B,OAAO,KAAK,IAAI,CAAC;QACnB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 500, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/column.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { validateIndex } from '../../utils/array.js';\nvar name = 'column';\nvar dependencies = ['typed', 'Index', 'matrix', 'range'];\nexport var createColumn = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    Index,\n    matrix,\n    range\n  } = _ref;\n  /**\n   * Return a column from a Matrix.\n   *\n   * Syntax:\n   *\n   *     math.column(value, index)\n   *\n   * Example:\n   *\n   *     // get a column\n   *     const d = [[1, 2], [3, 4]]\n   *     math.column(d, 1) // returns [[2], [4]]\n   *\n   * See also:\n   *\n   *     row\n   *\n   * @param {Array | Matrix } value   An array or matrix\n   * @param {number} column           The index of the column\n   * @return {Array | Matrix}         The retrieved column\n   */\n  return typed(name, {\n    'Matrix, number': _column,\n    'Array, number': function Array_number(value, column) {\n      return _column(matrix(clone(value)), column).valueOf();\n    }\n  });\n\n  /**\n   * Retrieve a column of a matrix\n   * @param {Matrix } value  A matrix\n   * @param {number} column  The index of the column\n   * @return {Matrix}        The retrieved column\n   */\n  function _column(value, column) {\n    // check dimensions\n    if (value.size().length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    }\n    validateIndex(column, value.size()[1]);\n    var rowRange = range(0, value.size()[0]);\n    var index = new Index(rowRange, column);\n    var result = value.subset(index);\n    return isMatrix(result) ? result : matrix([[result]]);\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAS;IAAU;CAAQ;AACjD,IAAI,eAAe,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACnE,IAAI,EACF,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;GAoBC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB;QAClB,iBAAiB,SAAS,aAAa,KAAK,EAAE,MAAM;YAClD,OAAO,QAAQ,OAAO,CAAA,GAAA,uJAAA,CAAA,QAAK,AAAD,EAAE,SAAS,QAAQ,OAAO;QACtD;IACF;;IAEA;;;;;GAKC,GACD,SAAS,QAAQ,KAAK,EAAE,MAAM;QAC5B,mBAAmB;QACnB,IAAI,MAAM,IAAI,GAAG,MAAM,KAAK,GAAG;YAC7B,MAAM,IAAI,MAAM;QAClB;QACA,CAAA,GAAA,sJAAA,CAAA,gBAAa,AAAD,EAAE,QAAQ,MAAM,IAAI,EAAE,CAAC,EAAE;QACrC,IAAI,WAAW,MAAM,GAAG,MAAM,IAAI,EAAE,CAAC,EAAE;QACvC,IAAI,QAAQ,IAAI,MAAM,UAAU;QAChC,IAAI,SAAS,MAAM,MAAM,CAAC;QAC1B,OAAO,CAAA,GAAA,mJAAA,CAAA,WAAQ,AAAD,EAAE,UAAU,SAAS,OAAO;YAAC;gBAAC;aAAO;SAAC;IACtD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 574, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/count.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'count';\nvar dependencies = ['typed', 'size', 'prod'];\nexport var createCount = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    size,\n    prod\n  } = _ref;\n  /**\n   * Count the number of elements of a matrix, array or string.\n   *\n   * Syntax:\n   *\n   *     math.count(x)\n   *\n   * Examples:\n   *\n   *     math.count('hello world')        // returns 11\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.count(A)                    // returns 6\n   *     math.count(math.range(1,6))      // returns 5\n   *\n   * See also:\n   *\n   *     size\n   *\n   * @param {string | Array | Matrix} x  A matrix or string\n   * @return {number} An integer with the elements in `x`.\n   */\n  return typed(name, {\n    string: function string(x) {\n      return x.length;\n    },\n    'Matrix | Array': function Matrix__Array(x) {\n      return prod(size(x));\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAQ;CAAO;AACrC,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,KAAK,EACL,IAAI,EACJ,IAAI,EACL,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;GAoBC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,EAAE,MAAM;QACjB;QACA,kBAAkB,SAAS,cAAc,CAAC;YACxC,OAAO,KAAK,KAAK;QACnB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/cross.js"],"sourcesContent":["import { arraySize, squeeze } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'cross';\nvar dependencies = ['typed', 'matrix', 'subtract', 'multiply'];\nexport var createCross = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    multiply\n  } = _ref;\n  /**\n   * Calculate the cross product for two vectors in three dimensional space.\n   * The cross product of `A = [a1, a2, a3]` and `B = [b1, b2, b3]` is defined\n   * as:\n   *\n   *    cross(A, B) = [\n   *      a2 * b3 - a3 * b2,\n   *      a3 * b1 - a1 * b3,\n   *      a1 * b2 - a2 * b1\n   *    ]\n   *\n   * If one of the input vectors has a dimension greater than 1, the output\n   * vector will be a 1x3 (2-dimensional) matrix.\n   *\n   * Syntax:\n   *\n   *    math.cross(x, y)\n   *\n   * Examples:\n   *\n   *    math.cross([1, 1, 0],   [0, 1, 1])       // Returns [1, -1, 1]\n   *    math.cross([3, -3, 1],  [4, 9, 2])       // Returns [-15, -2, 39]\n   *    math.cross([2, 3, 4],   [5, 6, 7])       // Returns [-3, 6, -3]\n   *    math.cross([[1, 2, 3]], [[4], [5], [6]]) // Returns [[-3, 6, -3]]\n   *\n   * See also:\n   *\n   *    dot, multiply\n   *\n   * @param  {Array | Matrix} x   First vector\n   * @param  {Array | Matrix} y   Second vector\n   * @return {Array | Matrix}     Returns the cross product of `x` and `y`\n   */\n  return typed(name, {\n    'Matrix, Matrix': function Matrix_Matrix(x, y) {\n      return matrix(_cross(x.toArray(), y.toArray()));\n    },\n    'Matrix, Array': function Matrix_Array(x, y) {\n      return matrix(_cross(x.toArray(), y));\n    },\n    'Array, Matrix': function Array_Matrix(x, y) {\n      return matrix(_cross(x, y.toArray()));\n    },\n    'Array, Array': _cross\n  });\n\n  /**\n   * Calculate the cross product for two arrays\n   * @param {Array} x  First vector\n   * @param {Array} y  Second vector\n   * @returns {Array} Returns the cross product of x and y\n   * @private\n   */\n  function _cross(x, y) {\n    var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);\n    x = squeeze(x);\n    y = squeeze(y);\n    var xSize = arraySize(x);\n    var ySize = arraySize(y);\n    if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {\n      throw new RangeError('Vectors with length 3 expected ' + '(Size A = [' + xSize.join(', ') + '], B = [' + ySize.join(', ') + '])');\n    }\n    var product = [subtract(multiply(x[1], y[2]), multiply(x[2], y[1])), subtract(multiply(x[2], y[0]), multiply(x[0], y[2])), subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))];\n    if (highestDimension > 1) {\n      return [product];\n    } else {\n      return product;\n    }\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAY;CAAW;AACvD,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,KAAK,EACL,MAAM,EACN,QAAQ,EACR,QAAQ,EACT,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,OAAO,OAAO,OAAO,EAAE,OAAO,IAAI,EAAE,OAAO;QAC7C;QACA,iBAAiB,SAAS,aAAa,CAAC,EAAE,CAAC;YACzC,OAAO,OAAO,OAAO,EAAE,OAAO,IAAI;QACpC;QACA,iBAAiB,SAAS,aAAa,CAAC,EAAE,CAAC;YACzC,OAAO,OAAO,OAAO,GAAG,EAAE,OAAO;QACnC;QACA,gBAAgB;IAClB;;IAEA;;;;;;GAMC,GACD,SAAS,OAAO,CAAC,EAAE,CAAC;QAClB,IAAI,mBAAmB,KAAK,GAAG,CAAC,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE,GAAG,MAAM,EAAE,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE,GAAG,MAAM;QACxE,IAAI,CAAA,GAAA,sJAAA,CAAA,UAAO,AAAD,EAAE;QACZ,IAAI,CAAA,GAAA,sJAAA,CAAA,UAAO,AAAD,EAAE;QACZ,IAAI,QAAQ,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE;QACtB,IAAI,QAAQ,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE;QACtB,IAAI,MAAM,MAAM,KAAK,KAAK,MAAM,MAAM,KAAK,KAAK,KAAK,CAAC,EAAE,KAAK,KAAK,KAAK,CAAC,EAAE,KAAK,GAAG;YAChF,MAAM,IAAI,WAAW,oCAAoC,gBAAgB,MAAM,IAAI,CAAC,QAAQ,aAAa,MAAM,IAAI,CAAC,QAAQ;QAC9H;QACA,IAAI,UAAU;YAAC,SAAS,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;YAAI,SAAS,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;YAAI,SAAS,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;SAAG;QAChL,IAAI,mBAAmB,GAAG;YACxB,OAAO;gBAAC;aAAQ;QAClB,OAAO;YACL,OAAO;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 718, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/diag.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { arraySize } from '../../utils/array.js';\nimport { isInteger } from '../../utils/number.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'diag';\nvar dependencies = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];\nexport var createDiag = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    DenseMatrix,\n    SparseMatrix\n  } = _ref;\n  /**\n   * Create a diagonal matrix or retrieve the diagonal of a matrix\n   *\n   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.\n   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.\n   * When k is positive, the values are placed on the super diagonal.\n   * When k is negative, the values are placed on the sub diagonal.\n   *\n   * Syntax:\n   *\n   *     math.diag(X)\n   *     math.diag(X, format)\n   *     math.diag(X, k)\n   *     math.diag(X, k, format)\n   *\n   * Examples:\n   *\n   *     // create a diagonal matrix\n   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\n   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]\n   *\n   *    // retrieve the diagonal from a matrix\n   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n   *    math.diag(a)   // returns [1, 5, 9]\n   *\n   * See also:\n   *\n   *     ones, zeros, identity\n   *\n   * @param {Matrix | Array} x          A two dimensional matrix or a vector\n   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled\n   *                                    in or retrieved.\n   * @param {string} [format='dense']   The matrix storage format.\n   *\n   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.\n   */\n  return typed(name, {\n    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments\n\n    Array: function Array(x) {\n      return _diag(x, 0, arraySize(x), null);\n    },\n    'Array, number': function Array_number(x, k) {\n      return _diag(x, k, arraySize(x), null);\n    },\n    'Array, BigNumber': function Array_BigNumber(x, k) {\n      return _diag(x, k.toNumber(), arraySize(x), null);\n    },\n    'Array, string': function Array_string(x, format) {\n      return _diag(x, 0, arraySize(x), format);\n    },\n    'Array, number, string': function Array_number_string(x, k, format) {\n      return _diag(x, k, arraySize(x), format);\n    },\n    'Array, BigNumber, string': function Array_BigNumber_string(x, k, format) {\n      return _diag(x, k.toNumber(), arraySize(x), format);\n    },\n    Matrix: function Matrix(x) {\n      return _diag(x, 0, x.size(), x.storage());\n    },\n    'Matrix, number': function Matrix_number(x, k) {\n      return _diag(x, k, x.size(), x.storage());\n    },\n    'Matrix, BigNumber': function Matrix_BigNumber(x, k) {\n      return _diag(x, k.toNumber(), x.size(), x.storage());\n    },\n    'Matrix, string': function Matrix_string(x, format) {\n      return _diag(x, 0, x.size(), format);\n    },\n    'Matrix, number, string': function Matrix_number_string(x, k, format) {\n      return _diag(x, k, x.size(), format);\n    },\n    'Matrix, BigNumber, string': function Matrix_BigNumber_string(x, k, format) {\n      return _diag(x, k.toNumber(), x.size(), format);\n    }\n  });\n\n  /**\n   * Creeate diagonal matrix from a vector or vice versa\n   * @param {Array | Matrix} x\n   * @param {number} k\n   * @param {string} format Storage format for matrix. If null,\n   *                          an Array is returned\n   * @returns {Array | Matrix}\n   * @private\n   */\n  function _diag(x, k, size, format) {\n    if (!isInteger(k)) {\n      throw new TypeError('Second parameter in function diag must be an integer');\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0;\n\n    // check dimensions\n    switch (size.length) {\n      case 1:\n        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);\n      case 2:\n        return _getDiagonal(x, k, format, size, kSub, kSuper);\n    }\n    throw new RangeError('Matrix for function diag must be 2 dimensional');\n  }\n  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {\n    // matrix size\n    var ms = [l + kSub, l + kSuper];\n    if (format && format !== 'sparse' && format !== 'dense') {\n      throw new TypeError(\"Unknown matrix type \".concat(format, \"\\\"\"));\n    }\n\n    // create diagonal matrix\n    var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k);\n    // check we need to return a matrix\n    return format !== null ? m : m.valueOf();\n  }\n  function _getDiagonal(x, k, format, s, kSub, kSuper) {\n    // check x is a Matrix\n    if (isMatrix(x)) {\n      // get diagonal matrix\n      var dm = x.diagonal(k);\n      // check we need to return a matrix\n      if (format !== null) {\n        // check we need to change matrix format\n        if (format !== dm.storage()) {\n          return matrix(dm, format);\n        }\n        return dm;\n      }\n      return dm.valueOf();\n    }\n    // vector size\n    var n = Math.min(s[0] - kSub, s[1] - kSuper);\n    // diagonal values\n    var vector = [];\n    // loop diagonal\n    for (var i = 0; i < n; i++) {\n      vector[i] = x[i + kSub][i + kSuper];\n    }\n    // check we need to return a matrix\n    return format !== null ? matrix(vector) : vector;\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAe;CAAe;AAC9D,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACL,MAAM,EACN,WAAW,EACX,YAAY,EACb,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoCC,GACD,OAAO,MAAM,MAAM;QACjB,uGAAuG;QAEvG,OAAO,SAAS,MAAM,CAAC;YACrB,OAAO,MAAM,GAAG,GAAG,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE,IAAI;QACnC;QACA,iBAAiB,SAAS,aAAa,CAAC,EAAE,CAAC;YACzC,OAAO,MAAM,GAAG,GAAG,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE,IAAI;QACnC;QACA,oBAAoB,SAAS,gBAAgB,CAAC,EAAE,CAAC;YAC/C,OAAO,MAAM,GAAG,EAAE,QAAQ,IAAI,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE,IAAI;QAC9C;QACA,iBAAiB,SAAS,aAAa,CAAC,EAAE,MAAM;YAC9C,OAAO,MAAM,GAAG,GAAG,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE,IAAI;QACnC;QACA,yBAAyB,SAAS,oBAAoB,CAAC,EAAE,CAAC,EAAE,MAAM;YAChE,OAAO,MAAM,GAAG,GAAG,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE,IAAI;QACnC;QACA,4BAA4B,SAAS,uBAAuB,CAAC,EAAE,CAAC,EAAE,MAAM;YACtE,OAAO,MAAM,GAAG,EAAE,QAAQ,IAAI,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE,IAAI;QAC9C;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,MAAM,GAAG,GAAG,EAAE,IAAI,IAAI,EAAE,OAAO;QACxC;QACA,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,OAAO,MAAM,GAAG,GAAG,EAAE,IAAI,IAAI,EAAE,OAAO;QACxC;QACA,qBAAqB,SAAS,iBAAiB,CAAC,EAAE,CAAC;YACjD,OAAO,MAAM,GAAG,EAAE,QAAQ,IAAI,EAAE,IAAI,IAAI,EAAE,OAAO;QACnD;QACA,kBAAkB,SAAS,cAAc,CAAC,EAAE,MAAM;YAChD,OAAO,MAAM,GAAG,GAAG,EAAE,IAAI,IAAI;QAC/B;QACA,0BAA0B,SAAS,qBAAqB,CAAC,EAAE,CAAC,EAAE,MAAM;YAClE,OAAO,MAAM,GAAG,GAAG,EAAE,IAAI,IAAI;QAC/B;QACA,6BAA6B,SAAS,wBAAwB,CAAC,EAAE,CAAC,EAAE,MAAM;YACxE,OAAO,MAAM,GAAG,EAAE,QAAQ,IAAI,EAAE,IAAI,IAAI;QAC1C;IACF;;IAEA;;;;;;;;GAQC,GACD,SAAS,MAAM,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM;QAC/B,IAAI,CAAC,CAAA,GAAA,uJAAA,CAAA,YAAS,AAAD,EAAE,IAAI;YACjB,MAAM,IAAI,UAAU;QACtB;QACA,IAAI,SAAS,IAAI,IAAI,IAAI;QACzB,IAAI,OAAO,IAAI,IAAI,CAAC,IAAI;QAExB,mBAAmB;QACnB,OAAQ,KAAK,MAAM;YACjB,KAAK;gBACH,OAAO,sBAAsB,GAAG,GAAG,QAAQ,IAAI,CAAC,EAAE,EAAE,MAAM;YAC5D,KAAK;gBACH,OAAO,aAAa,GAAG,GAAG,QAAQ,MAAM,MAAM;QAClD;QACA,MAAM,IAAI,WAAW;IACvB;IACA,SAAS,sBAAsB,CAAC,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM;QAC1D,cAAc;QACd,IAAI,KAAK;YAAC,IAAI;YAAM,IAAI;SAAO;QAC/B,IAAI,UAAU,WAAW,YAAY,WAAW,SAAS;YACvD,MAAM,IAAI,UAAU,uBAAuB,MAAM,CAAC,QAAQ;QAC5D;QAEA,yBAAyB;QACzB,IAAI,IAAI,WAAW,WAAW,aAAa,QAAQ,CAAC,IAAI,GAAG,KAAK,YAAY,QAAQ,CAAC,IAAI,GAAG;QAC5F,mCAAmC;QACnC,OAAO,WAAW,OAAO,IAAI,EAAE,OAAO;IACxC;IACA,SAAS,aAAa,CAAC,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM;QACjD,sBAAsB;QACtB,IAAI,CAAA,GAAA,mJAAA,CAAA,WAAQ,AAAD,EAAE,IAAI;YACf,sBAAsB;YACtB,IAAI,KAAK,EAAE,QAAQ,CAAC;YACpB,mCAAmC;YACnC,IAAI,WAAW,MAAM;gBACnB,wCAAwC;gBACxC,IAAI,WAAW,GAAG,OAAO,IAAI;oBAC3B,OAAO,OAAO,IAAI;gBACpB;gBACA,OAAO;YACT;YACA,OAAO,GAAG,OAAO;QACnB;QACA,cAAc;QACd,IAAI,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,MAAM,CAAC,CAAC,EAAE,GAAG;QACrC,kBAAkB;QAClB,IAAI,SAAS,EAAE;QACf,gBAAgB;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YAC1B,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC,IAAI,KAAK,CAAC,IAAI,OAAO;QACrC;QACA,mCAAmC;QACnC,OAAO,WAAW,OAAO,OAAO,UAAU;IAC5C;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 884, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/filter.js"],"sourcesContent":["import { optimizeCallback } from '../../utils/optimizeCallback.js';\nimport { filter, filterRegExp } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'filter';\nvar dependencies = ['typed'];\nexport var createFilter = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Filter the items in an array or one dimensional matrix.\n   *\n   * The callback is invoked with three arguments: the current value,\n   * the current index, and the matrix operated upon.\n   * Note that because the matrix/array might be\n   * multidimensional, the \"index\" argument is always an array of numbers giving\n   * the index in each dimension. This is true even for vectors: the \"index\"\n   * argument is an array of length 1, rather than simply a number.\n   *\n   * Syntax:\n   *\n   *    math.filter(x, test)\n   *\n   * Examples:\n   *\n   *    function isPositive (x) {\n   *      return x > 0\n   *    }\n   *    math.filter([6, -2, -1, 4, 3], isPositive) // returns [6, 4, 3]\n   *\n   *    math.filter([\"23\", \"foo\", \"100\", \"55\", \"bar\"], /[0-9]+/) // returns [\"23\", \"100\", \"55\"]\n   *\n   * See also:\n   *\n   *    forEach, map, sort\n   *\n   * @param {Matrix | Array} x    A one dimensional matrix or array to filter\n   * @param {Function | RegExp} test\n   *        A function or regular expression to test items.\n   *        All entries for which `test` returns true are returned.\n   *        When `test` is a function, it is invoked with three parameters:\n   *        the value of the element, the index of the element, and the\n   *        matrix/array being traversed. The function must return a boolean.\n   * @return {Matrix | Array} Returns the filtered matrix.\n   */\n  return typed('filter', {\n    'Array, function': _filterCallback,\n    'Matrix, function': function Matrix_function(x, test) {\n      return x.create(_filterCallback(x.valueOf(), test), x.datatype());\n    },\n    'Array, RegExp': filterRegExp,\n    'Matrix, RegExp': function Matrix_RegExp(x, test) {\n      return x.create(filterRegExp(x.valueOf(), test), x.datatype());\n    }\n  });\n});\n\n/**\n * Filter values in a callback given a callback function\n * @param {Array} x\n * @param {Function} callback\n * @return {Array} Returns the filtered array\n * @private\n */\nfunction _filterCallback(x, callback) {\n  var fastCallback = optimizeCallback(callback, x, 'filter');\n  return filter(x, function (value, index, array) {\n    // invoke the callback function with the right number of arguments\n    return fastCallback(value, [index], array);\n  });\n}"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,eAAe,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACnE,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmCC,GACD,OAAO,MAAM,UAAU;QACrB,mBAAmB;QACnB,oBAAoB,SAAS,gBAAgB,CAAC,EAAE,IAAI;YAClD,OAAO,EAAE,MAAM,CAAC,gBAAgB,EAAE,OAAO,IAAI,OAAO,EAAE,QAAQ;QAChE;QACA,iBAAiB,sJAAA,CAAA,eAAY;QAC7B,kBAAkB,SAAS,cAAc,CAAC,EAAE,IAAI;YAC9C,OAAO,EAAE,MAAM,CAAC,CAAA,GAAA,sJAAA,CAAA,eAAY,AAAD,EAAE,EAAE,OAAO,IAAI,OAAO,EAAE,QAAQ;QAC7D;IACF;AACF;AAEA;;;;;;CAMC,GACD,SAAS,gBAAgB,CAAC,EAAE,QAAQ;IAClC,IAAI,eAAe,CAAA,GAAA,iKAAA,CAAA,mBAAgB,AAAD,EAAE,UAAU,GAAG;IACjD,OAAO,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,GAAG,SAAU,KAAK,EAAE,KAAK,EAAE,KAAK;QAC5C,kEAAkE;QAClE,OAAO,aAAa,OAAO;YAAC;SAAM,EAAE;IACtC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 966, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/flatten.js"],"sourcesContent":["import { flatten as flattenArray } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'flatten';\nvar dependencies = ['typed'];\nexport var createFlatten = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Flatten a multidimensional matrix into a single dimensional matrix.\n   * A new matrix is returned, the original matrix is left untouched.\n   *\n   * Syntax:\n   *\n   *    math.flatten(x)\n   *\n   * Examples:\n   *\n   *    math.flatten([[1,2], [3,4]])   // returns [1, 2, 3, 4]\n   *\n   * See also:\n   *\n   *    concat, resize, size, squeeze\n   *\n   * @param {Matrix | Array} x   Matrix to be flattened\n   * @return {Matrix | Array} Returns the flattened matrix\n   */\n  return typed(name, {\n    Array: function Array(x) {\n      return flattenArray(x);\n    },\n    Matrix: function Matrix(x) {\n      // Return the same matrix type as x (Dense or Sparse Matrix)\n      // Return the same data type as x\n      return x.create(flattenArray(x.toArray()), x.datatype());\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,gBAAgB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACpE,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;GAkBC,GACD,OAAO,MAAM,MAAM;QACjB,OAAO,SAAS,MAAM,CAAC;YACrB,OAAO,CAAA,GAAA,sJAAA,CAAA,UAAY,AAAD,EAAE;QACtB;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,4DAA4D;YAC5D,iCAAiC;YACjC,OAAO,EAAE,MAAM,CAAC,CAAA,GAAA,sJAAA,CAAA,UAAY,AAAD,EAAE,EAAE,OAAO,KAAK,EAAE,QAAQ;QACvD;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1014, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/forEach.js"],"sourcesContent":["import { optimizeCallback } from '../../utils/optimizeCallback.js';\nimport { factory } from '../../utils/factory.js';\nimport { recurse } from '../../utils/array.js';\nvar name = 'forEach';\nvar dependencies = ['typed'];\nexport var createForEach = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Iterate over all elements of a matrix/array, and executes the given callback function.\n   *\n   * The callback is invoked with three arguments: the current value,\n   * the current index, and the matrix operated upon.\n   * Note that because the matrix/array might be\n   * multidimensional, the \"index\" argument is always an array of numbers giving\n   * the index in each dimension. This is true even for vectors: the \"index\"\n   * argument is an array of length 1, rather than simply a number.\n   *\n   * Syntax:\n   *\n   *    math.forEach(x, callback)\n   *\n   * Examples:\n   *\n   *    math.forEach([1, 2, 3], function(value) {\n   *      console.log(value)\n   *    })\n   *    // outputs 1, 2, 3\n   *\n   * See also:\n   *\n   *    filter, map, sort\n   *\n   * @param {Matrix | Array} x    The matrix to iterate on.\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix/array being traversed.\n   */\n  return typed(name, {\n    'Array, function': _forEach,\n    'Matrix, function': function Matrix_function(x, callback) {\n      x.forEach(callback);\n    }\n  });\n});\n\n/**\n * forEach for a multidimensional array\n * @param {Array} array\n * @param {Function} callback\n * @private\n */\nfunction _forEach(array, callback) {\n  recurse(array, [], array, optimizeCallback(callback, array, name));\n}"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,gBAAgB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACpE,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BC,GACD,OAAO,MAAM,MAAM;QACjB,mBAAmB;QACnB,oBAAoB,SAAS,gBAAgB,CAAC,EAAE,QAAQ;YACtD,EAAE,OAAO,CAAC;QACZ;IACF;AACF;AAEA;;;;;CAKC,GACD,SAAS,SAAS,KAAK,EAAE,QAAQ;IAC/B,CAAA,GAAA,sJAAA,CAAA,UAAO,AAAD,EAAE,OAAO,EAAE,EAAE,OAAO,CAAA,GAAA,iKAAA,CAAA,mBAAgB,AAAD,EAAE,UAAU,OAAO;AAC9D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1079, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { getArrayDataType } from '../../utils/array.js';\nimport { typeOf } from '../../utils/is.js';\nvar name = 'getMatrixDataType';\nvar dependencies = ['typed'];\nexport var createGetMatrixDataType = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Find the data type of all elements in a matrix or array,\n   * for example 'number' if all items are a number and 'Complex' if all values\n   * are complex numbers.\n   * If a matrix contains more than one data type, it will return 'mixed'.\n   *\n   * Syntax:\n   *\n   *    math.getMatrixDataType(x)\n   *\n   * Examples:\n   *\n   *    const x = [ [1, 2, 3], [4, 5, 6] ]\n   *    const mixedX = [ [1, true], [2, 3] ]\n   *    const fractionX = [ [math.fraction(1, 3)], [math.fraction(1, 3)] ]\n   *    const unitX = [ [math.unit('5cm')], [math.unit('5cm')] ]\n   *    const bigNumberX = [ [math.bignumber(1)], [math.bignumber(0)] ]\n   *    const sparse = math.sparse(x)\n   *    const dense = math.matrix(x)\n   *    math.getMatrixDataType(x)   // returns 'number'\n   *    math.getMatrixDataType(sparse)   // returns 'number'\n   *    math.getMatrixDataType(dense)   // returns 'number'\n   *    math.getMatrixDataType(mixedX) // returns 'mixed'\n   *    math.getMatrixDataType(fractionX) // returns 'Fraction'\n   *    math.getMatrixDataType(unitX) // returns 'Unit'\n   *    math.getMatrixDataType(bigNumberX) // return 'BigNumber'\n   *\n   * See also:\n   *  SparseMatrix, DenseMatrix\n   *\n   * @param {...Matrix | Array} x   The Matrix with values.\n   *\n   * @return {string} A string representation of the matrix type\n   */\n  return typed(name, {\n    Array: function Array(x) {\n      return getArrayDataType(x, typeOf);\n    },\n    Matrix: function Matrix(x) {\n      return x.getDataType();\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,0BAA0B,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAC9E,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiCC,GACD,OAAO,MAAM,MAAM;QACjB,OAAO,SAAS,MAAM,CAAC;YACrB,OAAO,CAAA,GAAA,sJAAA,CAAA,mBAAgB,AAAD,EAAE,GAAG,mJAAA,CAAA,SAAM;QACnC;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,EAAE,WAAW;QACtB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1142, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/identity.js"],"sourcesContent":["import { isBigNumber } from '../../utils/is.js';\nimport { resize } from '../../utils/array.js';\nimport { isInteger } from '../../utils/number.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'identity';\nvar dependencies = ['typed', 'config', 'matrix', 'BigNumber', 'DenseMatrix', 'SparseMatrix'];\nexport var createIdentity = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    matrix,\n    BigNumber,\n    DenseMatrix,\n    SparseMatrix\n  } = _ref;\n  /**\n   * Create a 2-dimensional identity matrix with size m x n or n x n.\n   * The matrix has ones on the diagonal and zeros elsewhere.\n   *\n   * Syntax:\n   *\n   *    math.identity(n)\n   *    math.identity(n, format)\n   *    math.identity(m, n)\n   *    math.identity(m, n, format)\n   *    math.identity([m, n])\n   *    math.identity([m, n], format)\n   *\n   * Examples:\n   *\n   *    math.identity(3)                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n   *    math.identity(3, 2)                 // returns [[1, 0], [0, 1], [0, 0]]\n   *\n   *    const A = [[1, 2, 3], [4, 5, 6]]\n   *    math.identity(math.size(A))         // returns [[1, 0, 0], [0, 1, 0]]\n   *\n   * See also:\n   *\n   *    diag, ones, zeros, size, range\n   *\n   * @param {...number | Matrix | Array} size   The size for the matrix\n   * @param {string} [format]                   The Matrix storage format\n   *\n   * @return {Matrix | Array | number} A matrix with ones on the diagonal.\n   */\n  return typed(name, {\n    '': function _() {\n      return config.matrix === 'Matrix' ? matrix([]) : [];\n    },\n    string: function string(format) {\n      return matrix(format);\n    },\n    'number | BigNumber': function number__BigNumber(rows) {\n      return _identity(rows, rows, config.matrix === 'Matrix' ? 'dense' : undefined);\n    },\n    'number | BigNumber, string': function number__BigNumber_string(rows, format) {\n      return _identity(rows, rows, format);\n    },\n    'number | BigNumber, number | BigNumber': function number__BigNumber_number__BigNumber(rows, cols) {\n      return _identity(rows, cols, config.matrix === 'Matrix' ? 'dense' : undefined);\n    },\n    'number | BigNumber, number | BigNumber, string': function number__BigNumber_number__BigNumber_string(rows, cols, format) {\n      return _identity(rows, cols, format);\n    },\n    Array: function Array(size) {\n      return _identityVector(size);\n    },\n    'Array, string': function Array_string(size, format) {\n      return _identityVector(size, format);\n    },\n    Matrix: function Matrix(size) {\n      return _identityVector(size.valueOf(), size.storage());\n    },\n    'Matrix, string': function Matrix_string(size, format) {\n      return _identityVector(size.valueOf(), format);\n    }\n  });\n  function _identityVector(size, format) {\n    switch (size.length) {\n      case 0:\n        return format ? matrix(format) : [];\n      case 1:\n        return _identity(size[0], size[0], format);\n      case 2:\n        return _identity(size[0], size[1], format);\n      default:\n        throw new Error('Vector containing two values expected');\n    }\n  }\n\n  /**\n   * Create an identity matrix\n   * @param {number | BigNumber} rows\n   * @param {number | BigNumber} cols\n   * @param {string} [format]\n   * @returns {Matrix}\n   * @private\n   */\n  function _identity(rows, cols, format) {\n    // BigNumber constructor with the right precision\n    var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber : null;\n    if (isBigNumber(rows)) rows = rows.toNumber();\n    if (isBigNumber(cols)) cols = cols.toNumber();\n    if (!isInteger(rows) || rows < 1) {\n      throw new Error('Parameters in function identity must be positive integers');\n    }\n    if (!isInteger(cols) || cols < 1) {\n      throw new Error('Parameters in function identity must be positive integers');\n    }\n    var one = Big ? new BigNumber(1) : 1;\n    var defaultValue = Big ? new Big(0) : 0;\n    var size = [rows, cols];\n\n    // check we need to return a matrix\n    if (format) {\n      // create diagonal matrix (use optimized implementation for storage format)\n      if (format === 'sparse') {\n        return SparseMatrix.diagonal(size, one, 0, defaultValue);\n      }\n      if (format === 'dense') {\n        return DenseMatrix.diagonal(size, one, 0, defaultValue);\n      }\n      throw new TypeError(\"Unknown matrix type \\\"\".concat(format, \"\\\"\"));\n    }\n\n    // create and resize array\n    var res = resize([], size, defaultValue);\n    // fill in ones on the diagonal\n    var minimum = rows < cols ? rows : cols;\n    // fill diagonal\n    for (var d = 0; d < minimum; d++) {\n      res[d][d] = one;\n    }\n    return res;\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1290, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/kron.js"],"sourcesContent":["import { arraySize as size } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'kron';\nvar dependencies = ['typed', 'matrix', 'multiplyScalar'];\nexport var createKron = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    multiplyScalar\n  } = _ref;\n  /**\n     * Calculates the Kronecker product of 2 matrices or vectors.\n     *\n     * NOTE: If a one dimensional vector / matrix is given, it will be\n     * wrapped so its two dimensions.\n     * See the examples.\n     *\n     * Syntax:\n     *\n     *    math.kron(x, y)\n     *\n     * Examples:\n     *\n     *    math.kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])\n     *    // returns [ [ 1, 2, 0, 0 ], [ 3, 4, 0, 0 ], [ 0, 0, 1, 2 ], [ 0, 0, 3, 4 ] ]\n     *\n     *    math.kron([1,1], [2,3,4])\n     *    // returns [ [ 2, 3, 4, 2, 3, 4 ] ]\n     *\n     * See also:\n     *\n     *    multiply, dot, cross\n     *\n     * @param  {Array | Matrix} x     First vector\n     * @param  {Array | Matrix} y     Second vector\n     * @return {Array | Matrix}       Returns the Kronecker product of `x` and `y`\n     */\n  return typed(name, {\n    'Matrix, Matrix': function Matrix_Matrix(x, y) {\n      return matrix(_kron(x.toArray(), y.toArray()));\n    },\n    'Matrix, Array': function Matrix_Array(x, y) {\n      return matrix(_kron(x.toArray(), y));\n    },\n    'Array, Matrix': function Array_Matrix(x, y) {\n      return matrix(_kron(x, y.toArray()));\n    },\n    'Array, Array': _kron\n  });\n\n  /**\n     * Calculate the Kronecker product of two matrices / vectors\n     * @param {Array} a  First vector\n     * @param {Array} b  Second vector\n     * @returns {Array} Returns the Kronecker product of x and y\n     * @private\n     */\n  function _kron(a, b) {\n    // Deal with the dimensions of the matricies.\n    if (size(a).length === 1) {\n      // Wrap it in a 2D Matrix\n      a = [a];\n    }\n    if (size(b).length === 1) {\n      // Wrap it in a 2D Matrix\n      b = [b];\n    }\n    if (size(a).length > 2 || size(b).length > 2) {\n      throw new RangeError('Vectors with dimensions greater then 2 are not supported expected ' + '(Size x = ' + JSON.stringify(a.length) + ', y = ' + JSON.stringify(b.length) + ')');\n    }\n    var t = [];\n    var r = [];\n    return a.map(function (a) {\n      return b.map(function (b) {\n        r = [];\n        t.push(r);\n        return a.map(function (y) {\n          return b.map(function (x) {\n            return r.push(multiplyScalar(y, x));\n          });\n        });\n      });\n    }) && t;\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;CAAiB;AACjD,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACL,MAAM,EACN,cAAc,EACf,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;KA0BG,GACH,OAAO,MAAM,MAAM;QACjB,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,OAAO,OAAO,MAAM,EAAE,OAAO,IAAI,EAAE,OAAO;QAC5C;QACA,iBAAiB,SAAS,aAAa,CAAC,EAAE,CAAC;YACzC,OAAO,OAAO,MAAM,EAAE,OAAO,IAAI;QACnC;QACA,iBAAiB,SAAS,aAAa,CAAC,EAAE,CAAC;YACzC,OAAO,OAAO,MAAM,GAAG,EAAE,OAAO;QAClC;QACA,gBAAgB;IAClB;;IAEA;;;;;;KAMG,GACH,SAAS,MAAM,CAAC,EAAE,CAAC;QACjB,6CAA6C;QAC7C,IAAI,CAAA,GAAA,sJAAA,CAAA,YAAI,AAAD,EAAE,GAAG,MAAM,KAAK,GAAG;YACxB,yBAAyB;YACzB,IAAI;gBAAC;aAAE;QACT;QACA,IAAI,CAAA,GAAA,sJAAA,CAAA,YAAI,AAAD,EAAE,GAAG,MAAM,KAAK,GAAG;YACxB,yBAAyB;YACzB,IAAI;gBAAC;aAAE;QACT;QACA,IAAI,CAAA,GAAA,sJAAA,CAAA,YAAI,AAAD,EAAE,GAAG,MAAM,GAAG,KAAK,CAAA,GAAA,sJAAA,CAAA,YAAI,AAAD,EAAE,GAAG,MAAM,GAAG,GAAG;YAC5C,MAAM,IAAI,WAAW,uEAAuE,eAAe,KAAK,SAAS,CAAC,EAAE,MAAM,IAAI,WAAW,KAAK,SAAS,CAAC,EAAE,MAAM,IAAI;QAC9K;QACA,IAAI,IAAI,EAAE;QACV,IAAI,IAAI,EAAE;QACV,OAAO,EAAE,GAAG,CAAC,SAAU,CAAC;YACtB,OAAO,EAAE,GAAG,CAAC,SAAU,CAAC;gBACtB,IAAI,EAAE;gBACN,EAAE,IAAI,CAAC;gBACP,OAAO,EAAE,GAAG,CAAC,SAAU,CAAC;oBACtB,OAAO,EAAE,GAAG,CAAC,SAAU,CAAC;wBACtB,OAAO,EAAE,IAAI,CAAC,eAAe,GAAG;oBAClC;gBACF;YACF;QACF,MAAM;IACR;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1388, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/map.js"],"sourcesContent":["import { optimizeCallback } from '../../utils/optimizeCallback.js';\nimport { arraySize, broadcastSizes, broadcastTo, get, recurse } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'map';\nvar dependencies = ['typed'];\nexport var createMap = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Create a new matrix or array with the results of a callback function executed on\n   * each entry of a given matrix/array.\n   *\n   * For each entry of the input,\n   *\n   * the callback is invoked with 2N + 1 arguments:\n   * the N values of the entry, the index at which that entry occurs, and the N full\n   * broadcasted matrix/array being traversed where N is the number of matrices being traversed.\n   * Note that because the matrix/array might be\n   * multidimensional, the \"index\" argument is always an array of numbers giving\n   * the index in each dimension. This is true even for vectors: the \"index\"\n   * argument is an array of length 1, rather than simply a number.\n   *\n   * Syntax:\n   *\n   *    math.map(x, callback)\n   *    math.map(x, y, ..., callback)\n   *\n   * Examples:\n   *\n   *    math.map([1, 2, 3], function(value) {\n   *      return value * value\n   *    })  // returns [1, 4, 9]\n   *    math.map([1, 2], [3, 4], function(a, b) {\n   *     return a + b\n   *    })  // returns [4, 6]\n   *\n   *    // The callback is normally called with three arguments:\n   *    //    callback(value, index, Array)\n   *    // If you want to call with only one argument, use:\n   *    math.map([1, 2, 3], x => math.format(x)) // returns ['1', '2', '3']\n   *    // It can also be called with 2N + 1 arguments: for N arrays\n   *    //    callback(value1, value2, index, BroadcastedArray1, BroadcastedArray2)\n   *\n   * See also:\n   *\n   *    filter, forEach, sort\n   *\n   * @param {Matrix | Array} x    The input to iterate on.\n   * @param {Function} callback\n   *     The function to call (as described above) on each entry of the input\n   * @return {Matrix | array}\n   *     Transformed map of x; always has the same type and shape as x\n   */\n  return typed(name, {\n    'Array, function': _mapArray,\n    'Matrix, function': function Matrix_function(x, callback) {\n      return x.map(callback);\n    },\n    'Array|Matrix, Array|Matrix, ...Array|Matrix|function': (A, B, rest) => _mapMultiple([A, B, ...rest.slice(0, rest.length - 1)], rest[rest.length - 1])\n  });\n\n  /**\n  * Maps over multiple arrays or matrices.\n  *\n  * @param {Array<Array|Matrix>} Arrays - An array of arrays or matrices to map over.\n  * @param {function} multiCallback - The callback function to apply to each element.\n  * @throws {Error} If the last argument is not a callback function.\n  * @returns {Array|Matrix} A new array or matrix with each element being the result of the callback function.\n  *\n  * @example\n  * _mapMultiple([[1, 2, 3], [4, 5, 6]], (a, b) => a + b); // Returns [5, 7, 9]\n  */\n  function _mapMultiple(Arrays, multiCallback) {\n    if (typeof multiCallback !== 'function') {\n      throw new Error('Last argument must be a callback function');\n    }\n    var firstArrayIsMatrix = Arrays[0].isMatrix;\n    var newSize = broadcastSizes(...Arrays.map(M => M.isMatrix ? M.size() : arraySize(M)));\n    var _get = firstArrayIsMatrix ? (matrix, idx) => matrix.get(idx) : get;\n    var broadcastedArrays = firstArrayIsMatrix ? Arrays.map(M => M.isMatrix ? M.create(broadcastTo(M.toArray(), newSize), M.datatype()) : Arrays[0].create(broadcastTo(M.valueOf(), newSize))) : Arrays.map(M => M.isMatrix ? broadcastTo(M.toArray(), newSize) : broadcastTo(M, newSize));\n    var callback;\n    if (typed.isTypedFunction(multiCallback)) {\n      var firstIndex = newSize.map(() => 0);\n      var firstValues = broadcastedArrays.map(array => _get(array, firstIndex));\n      var callbackCase = _getTypedCallbackCase(multiCallback, firstValues, firstIndex, broadcastedArrays);\n      callback = _getLimitedCallback(callbackCase);\n    } else {\n      var numberOfArrays = Arrays.length;\n      var _callbackCase = _getCallbackCase(multiCallback, numberOfArrays);\n      callback = _getLimitedCallback(_callbackCase);\n    }\n    var broadcastedArraysCallback = (x, idx) => callback([x, ...broadcastedArrays.slice(1).map(Array => _get(Array, idx))], idx);\n    if (firstArrayIsMatrix) {\n      return broadcastedArrays[0].map(broadcastedArraysCallback);\n    } else {\n      return _mapArray(broadcastedArrays[0], broadcastedArraysCallback);\n    }\n    function _getLimitedCallback(callbackCase) {\n      switch (callbackCase) {\n        case 0:\n          return x => multiCallback(...x);\n        case 1:\n          return (x, idx) => multiCallback(...x, idx);\n        case 2:\n          return (x, idx) => multiCallback(...x, idx, ...broadcastedArrays);\n      }\n    }\n    function _getCallbackCase(callback, numberOfArrays) {\n      if (callback.length > numberOfArrays + 1) {\n        return 2;\n      }\n      if (callback.length === numberOfArrays + 1) {\n        return 1;\n      }\n      return 0;\n    }\n    function _getTypedCallbackCase(callback, values, idx, arrays) {\n      if (typed.resolve(callback, [...values, idx, ...arrays]) !== null) {\n        return 2;\n      }\n      if (typed.resolve(callback, [...values, idx]) !== null) {\n        return 1;\n      }\n      if (typed.resolve(callback, values) !== null) {\n        return 0;\n      }\n      // this should never happen\n      return 0;\n    }\n  }\n  /**\n  * Map for a multi dimensional array\n  * @param {Array} array\n  * @param {Function} callback\n  * @return {Array}\n  * @private\n  */\n  function _mapArray(array, callback) {\n    return recurse(array, [], array, optimizeCallback(callback, array, name));\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1554, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/diff.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { isInteger } from '../../utils/number.js';\nimport { isMatrix } from '../../utils/is.js';\nvar name = 'diff';\nvar dependencies = ['typed', 'matrix', 'subtract', 'number'];\nexport var createDiff = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtract,\n    number\n  } = _ref;\n  /**\n   * Create a new matrix or array of the difference between elements of the given array\n   * The optional dim parameter lets you specify the dimension to evaluate the difference of\n   * If no dimension parameter is passed it is assumed as dimension 0\n   *\n   * Dimension is zero-based in javascript and one-based in the parser and can be a number or bignumber\n   * Arrays must be 'rectangular' meaning arrays like [1, 2]\n   * If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays\n   *\n   * Syntax:\n   *\n   *     math.diff(arr)\n   *     math.diff(arr, dim)\n   *\n   * Examples:\n   *\n   *     const arr = [1, 2, 4, 7, 0]\n   *     math.diff(arr) // returns [1, 2, 3, -7] (no dimension passed so 0 is assumed)\n   *     math.diff(math.matrix(arr)) // returns Matrix [1, 2, 3, -7]\n   *\n   *     const arr = [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [9, 8, 7, 6, 4]]\n   *     math.diff(arr) // returns [[0, 0, 0, 0, 0], [8, 6, 4, 2, -1]]\n   *     math.diff(arr, 0) // returns [[0, 0, 0, 0, 0], [8, 6, 4, 2, -1]]\n   *     math.diff(arr, 1) // returns [[1, 1, 1, 1], [1, 1, 1, 1], [-1, -1, -1, -2]]\n   *     math.diff(arr, math.bignumber(1)) // returns [[1, 1, 1, 1], [1, 1, 1, 1], [-1, -1, -1, -2]]\n   *\n   *     math.diff(arr, 2) // throws RangeError as arr is 2 dimensional not 3\n   *     math.diff(arr, -1) // throws RangeError as negative dimensions are not allowed\n   *\n   *     // These will all produce the same result\n   *     math.diff([[1, 2], [3, 4]])\n   *     math.diff([math.matrix([1, 2]), math.matrix([3, 4])])\n   *     math.diff([[1, 2], math.matrix([3, 4])])\n   *     math.diff([math.matrix([1, 2]), [3, 4]])\n   *     // They do not produce the same result as  math.diff(math.matrix([[1, 2], [3, 4]])) as this returns a matrix\n   *\n   * See Also:\n   *\n   *      sum\n   *      subtract\n   *      partitionSelect\n   *\n   * @param {Array | Matrix} arr      An array or matrix\n   * @param {number | BigNumber} dim  Dimension\n   * @return {Array | Matrix}         Difference between array elements in given dimension\n   */\n  return typed(name, {\n    'Array | Matrix': function Array__Matrix(arr) {\n      // No dimension specified => assume dimension 0\n      if (isMatrix(arr)) {\n        return matrix(_diff(arr.toArray()));\n      } else {\n        return _diff(arr);\n      }\n    },\n    'Array | Matrix, number': function Array__Matrix_number(arr, dim) {\n      if (!isInteger(dim)) throw new RangeError('Dimension must be a whole number');\n      if (isMatrix(arr)) {\n        return matrix(_recursive(arr.toArray(), dim));\n      } else {\n        return _recursive(arr, dim);\n      }\n    },\n    'Array, BigNumber': typed.referTo('Array,number', selfAn => (arr, dim) => selfAn(arr, number(dim))),\n    'Matrix, BigNumber': typed.referTo('Matrix,number', selfMn => (arr, dim) => selfMn(arr, number(dim)))\n  });\n\n  /**\n   * Recursively find the correct dimension in the array/matrix\n   * Then Apply _diff to that dimension\n   *\n   * @param {Array} arr      The array\n   * @param {number} dim     Dimension\n   * @return {Array}         resulting array\n   */\n  function _recursive(arr, dim) {\n    if (isMatrix(arr)) {\n      arr = arr.toArray(); // Makes sure arrays like [ matrix([0, 1]), matrix([1, 0]) ] are processed properly\n    }\n    if (!Array.isArray(arr)) {\n      throw RangeError('Array/Matrix does not have that many dimensions');\n    }\n    if (dim > 0) {\n      var result = [];\n      arr.forEach(element => {\n        result.push(_recursive(element, dim - 1));\n      });\n      return result;\n    } else if (dim === 0) {\n      return _diff(arr);\n    } else {\n      throw RangeError('Cannot have negative dimension');\n    }\n  }\n\n  /**\n   * Difference between elements in the array\n   *\n   * @param {Array} arr      An array\n   * @return {Array}         resulting array\n   */\n  function _diff(arr) {\n    var result = [];\n    var size = arr.length;\n    for (var i = 1; i < size; i++) {\n      result.push(_ElementDiff(arr[i - 1], arr[i]));\n    }\n    return result;\n  }\n\n  /**\n   * Difference between 2 objects\n   *\n   * @param {Object} obj1    First object\n   * @param {Object} obj2    Second object\n   * @return {Array}         resulting array\n   */\n  function _ElementDiff(obj1, obj2) {\n    // Convert matrices to arrays\n    if (isMatrix(obj1)) obj1 = obj1.toArray();\n    if (isMatrix(obj2)) obj2 = obj2.toArray();\n    var obj1IsArray = Array.isArray(obj1);\n    var obj2IsArray = Array.isArray(obj2);\n    if (obj1IsArray && obj2IsArray) {\n      return _ArrayDiff(obj1, obj2);\n    }\n    if (!obj1IsArray && !obj2IsArray) {\n      return subtract(obj2, obj1); // Difference is (second - first) NOT (first - second)\n    }\n    throw TypeError('Cannot calculate difference between 1 array and 1 non-array');\n  }\n\n  /**\n   * Difference of elements in 2 arrays\n   *\n   * @param {Array} arr1     Array 1\n   * @param {Array} arr2     Array 2\n   * @return {Array}         resulting array\n   */\n  function _ArrayDiff(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      throw RangeError('Not all sub-arrays have the same length');\n    }\n    var result = [];\n    var size = arr1.length;\n    for (var i = 0; i < size; i++) {\n      result.push(_ElementDiff(arr1[i], arr2[i]));\n    }\n    return result;\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1721, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/ones.js"],"sourcesContent":["import { isBigNumber } from '../../utils/is.js';\nimport { isInteger } from '../../utils/number.js';\nimport { resize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ones';\nvar dependencies = ['typed', 'config', 'matrix', 'BigNumber'];\nexport var createOnes = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    matrix,\n    BigNumber\n  } = _ref;\n  /**\n   * Create a matrix filled with ones. The created matrix can have one or\n   * multiple dimensions.\n   *\n   * Syntax:\n   *\n   *    math.ones(m)\n   *    math.ones(m, format)\n   *    math.ones(m, n)\n   *    math.ones(m, n, format)\n   *    math.ones([m, n])\n   *    math.ones([m, n], format)\n   *    math.ones([m, n, p, ...])\n   *    math.ones([m, n, p, ...], format)\n   *\n   * Examples:\n   *\n   *    math.ones()                    // returns []\n   *    math.ones(3)                   // returns [1, 1, 1]\n   *    math.ones(3, 2)                // returns [[1, 1], [1, 1], [1, 1]]\n   *    math.ones(3, 2, 'dense')       // returns Dense Matrix [[1, 1], [1, 1], [1, 1]]\n   *\n   *    const A = [[1, 2, 3], [4, 5, 6]]\n   *    math.ones(math.size(A))       // returns [[1, 1, 1], [1, 1, 1]]\n   *\n   * See also:\n   *\n   *    zeros, identity, size, range\n   *\n   * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix\n   * @param {string} [format]           The Matrix storage format\n   *\n   * @return {Array | Matrix | number}  A matrix filled with ones\n   */\n  return typed('ones', {\n    '': function _() {\n      return config.matrix === 'Array' ? _ones([]) : _ones([], 'default');\n    },\n    // math.ones(m, n, p, ..., format)\n    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this\n    '...number | BigNumber | string': function number__BigNumber__string(size) {\n      var last = size[size.length - 1];\n      if (typeof last === 'string') {\n        var format = size.pop();\n        return _ones(size, format);\n      } else if (config.matrix === 'Array') {\n        return _ones(size);\n      } else {\n        return _ones(size, 'default');\n      }\n    },\n    Array: _ones,\n    Matrix: function Matrix(size) {\n      var format = size.storage();\n      return _ones(size.valueOf(), format);\n    },\n    'Array | Matrix, string': function Array__Matrix_string(size, format) {\n      return _ones(size.valueOf(), format);\n    }\n  });\n\n  /**\n   * Create an Array or Matrix with ones\n   * @param {Array} size\n   * @param {string} [format='default']\n   * @return {Array | Matrix}\n   * @private\n   */\n  function _ones(size, format) {\n    var hasBigNumbers = _normalize(size);\n    var defaultValue = hasBigNumbers ? new BigNumber(1) : 1;\n    _validate(size);\n    if (format) {\n      // return a matrix\n      var m = matrix(format);\n      if (size.length > 0) {\n        return m.resize(size, defaultValue);\n      }\n      return m;\n    } else {\n      // return an Array\n      var arr = [];\n      if (size.length > 0) {\n        return resize(arr, size, defaultValue);\n      }\n      return arr;\n    }\n  }\n\n  // replace BigNumbers with numbers, returns true if size contained BigNumbers\n  function _normalize(size) {\n    var hasBigNumbers = false;\n    size.forEach(function (value, index, arr) {\n      if (isBigNumber(value)) {\n        hasBigNumbers = true;\n        arr[index] = value.toNumber();\n      }\n    });\n    return hasBigNumbers;\n  }\n\n  // validate arguments\n  function _validate(size) {\n    size.forEach(function (value) {\n      if (typeof value !== 'number' || !isInteger(value) || value < 0) {\n        throw new Error('Parameters in function ones must be positive integers');\n      }\n    });\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAU;CAAY;AACtD,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACL,MAAM,EACN,MAAM,EACN,SAAS,EACV,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiCC,GACD,OAAO,MAAM,QAAQ;QACnB,IAAI,SAAS;YACX,OAAO,OAAO,MAAM,KAAK,UAAU,MAAM,EAAE,IAAI,MAAM,EAAE,EAAE;QAC3D;QACA,kCAAkC;QAClC,wGAAwG;QACxG,kCAAkC,SAAS,0BAA0B,IAAI;YACvE,IAAI,OAAO,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE;YAChC,IAAI,OAAO,SAAS,UAAU;gBAC5B,IAAI,SAAS,KAAK,GAAG;gBACrB,OAAO,MAAM,MAAM;YACrB,OAAO,IAAI,OAAO,MAAM,KAAK,SAAS;gBACpC,OAAO,MAAM;YACf,OAAO;gBACL,OAAO,MAAM,MAAM;YACrB;QACF;QACA,OAAO;QACP,QAAQ,SAAS,OAAO,IAAI;YAC1B,IAAI,SAAS,KAAK,OAAO;YACzB,OAAO,MAAM,KAAK,OAAO,IAAI;QAC/B;QACA,0BAA0B,SAAS,qBAAqB,IAAI,EAAE,MAAM;YAClE,OAAO,MAAM,KAAK,OAAO,IAAI;QAC/B;IACF;;IAEA;;;;;;GAMC,GACD,SAAS,MAAM,IAAI,EAAE,MAAM;QACzB,IAAI,gBAAgB,WAAW;QAC/B,IAAI,eAAe,gBAAgB,IAAI,UAAU,KAAK;QACtD,UAAU;QACV,IAAI,QAAQ;YACV,kBAAkB;YAClB,IAAI,IAAI,OAAO;YACf,IAAI,KAAK,MAAM,GAAG,GAAG;gBACnB,OAAO,EAAE,MAAM,CAAC,MAAM;YACxB;YACA,OAAO;QACT,OAAO;YACL,kBAAkB;YAClB,IAAI,MAAM,EAAE;YACZ,IAAI,KAAK,MAAM,GAAG,GAAG;gBACnB,OAAO,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,KAAK,MAAM;YAC3B;YACA,OAAO;QACT;IACF;IAEA,6EAA6E;IAC7E,SAAS,WAAW,IAAI;QACtB,IAAI,gBAAgB;QACpB,KAAK,OAAO,CAAC,SAAU,KAAK,EAAE,KAAK,EAAE,GAAG;YACtC,IAAI,CAAA,GAAA,mJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ;gBACtB,gBAAgB;gBAChB,GAAG,CAAC,MAAM,GAAG,MAAM,QAAQ;YAC7B;QACF;QACA,OAAO;IACT;IAEA,qBAAqB;IACrB,SAAS,UAAU,IAAI;QACrB,KAAK,OAAO,CAAC,SAAU,KAAK;YAC1B,IAAI,OAAO,UAAU,YAAY,CAAC,CAAA,GAAA,uJAAA,CAAA,YAAS,AAAD,EAAE,UAAU,QAAQ,GAAG;gBAC/D,MAAM,IAAI,MAAM;YAClB;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1853, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/range.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { noBignumber, noMatrix } from '../../utils/noop.js';\nvar name = 'range';\nvar dependencies = ['typed', 'config', '?matrix', '?bignumber', 'smaller', 'smallerEq', 'larger', 'largerEq', 'add', 'isPositive'];\nexport var createRange = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    matrix,\n    bignumber,\n    smaller,\n    smallerEq,\n    larger,\n    largerEq,\n    add,\n    isPositive\n  } = _ref;\n  /**\n   * Create an array from a range.\n   * By default, the range end is excluded. This can be customized by providing\n   * an extra parameter `includeEnd`.\n   *\n   * Syntax:\n   *\n   *     math.range(str [, includeEnd])               // Create a range from a string,\n   *                                                  // where the string contains the\n   *                                                  // start, optional step, and end,\n   *                                                  // separated by a colon.\n   *     math.range(start, end [, includeEnd])        // Create a range with start and\n   *                                                  // end and a step size of 1.\n   *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,\n   *                                                  // and end.\n   *\n   * Where:\n   *\n   * - `str: string`\n   *   A string 'start:end' or 'start:step:end'\n   * - `start: {number | BigNumber | Unit}`\n   *   Start of the range\n   * - `end: number | BigNumber | Unit`\n   *   End of the range, excluded by default, included when parameter includeEnd=true\n   * - `step: number | BigNumber | Unit`\n   *   Step size. Default value is 1.\n   * - `includeEnd: boolean`\n   *   Option to specify whether to include the end or not. False by default.\n   *\n   * Examples:\n   *\n   *     math.range(2, 6)        // [2, 3, 4, 5]\n   *     math.range(2, -3, -1)   // [2, 1, 0, -1, -2]\n   *     math.range('2:1:6')     // [2, 3, 4, 5]\n   *     math.range(2, 6, true)  // [2, 3, 4, 5, 6]\n   *     math.range(math.unit(2, 'm'), math.unit(-3, 'm'), math.unit(-1, 'm')) // [2 m, 1 m, 0 m , -1 m, -2 m]\n   *\n   * See also:\n   *\n   *     ones, zeros, size, subset\n   *\n   * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.\n   * @return {Array | Matrix} range\n   */\n  return typed(name, {\n    // TODO: simplify signatures when typed-function supports default values and optional arguments\n\n    // TODO: a number or boolean should not be converted to string here\n    string: _strRange,\n    'string, boolean': _strRange,\n    'number, number': function number_number(start, end) {\n      return _out(_range(start, end, 1, false));\n    },\n    'number, number, number': function number_number_number(start, end, step) {\n      return _out(_range(start, end, step, false));\n    },\n    'number, number, boolean': function number_number_boolean(start, end, includeEnd) {\n      return _out(_range(start, end, 1, includeEnd));\n    },\n    'number, number, number, boolean': function number_number_number_boolean(start, end, step, includeEnd) {\n      return _out(_range(start, end, step, includeEnd));\n    },\n    'BigNumber, BigNumber': function BigNumber_BigNumber(start, end) {\n      var BigNumber = start.constructor;\n      return _out(_range(start, end, new BigNumber(1), false));\n    },\n    'BigNumber, BigNumber, BigNumber': function BigNumber_BigNumber_BigNumber(start, end, step) {\n      return _out(_range(start, end, step, false));\n    },\n    'BigNumber, BigNumber, boolean': function BigNumber_BigNumber_boolean(start, end, includeEnd) {\n      var BigNumber = start.constructor;\n      return _out(_range(start, end, new BigNumber(1), includeEnd));\n    },\n    'BigNumber, BigNumber, BigNumber, boolean': function BigNumber_BigNumber_BigNumber_boolean(start, end, step, includeEnd) {\n      return _out(_range(start, end, step, includeEnd));\n    },\n    'Unit, Unit, Unit': function Unit_Unit_Unit(start, end, step) {\n      return _out(_range(start, end, step, false));\n    },\n    'Unit, Unit, Unit, boolean': function Unit_Unit_Unit_boolean(start, end, step, includeEnd) {\n      return _out(_range(start, end, step, includeEnd));\n    }\n  });\n  function _out(arr) {\n    if (config.matrix === 'Matrix') {\n      return matrix ? matrix(arr) : noMatrix();\n    }\n    return arr;\n  }\n  function _strRange(str, includeEnd) {\n    var r = _parse(str);\n    if (!r) {\n      throw new SyntaxError('String \"' + str + '\" is no valid range');\n    }\n    if (config.number === 'BigNumber') {\n      if (bignumber === undefined) {\n        noBignumber();\n      }\n      return _out(_range(bignumber(r.start), bignumber(r.end), bignumber(r.step)), includeEnd);\n    } else {\n      return _out(_range(r.start, r.end, r.step, includeEnd));\n    }\n  }\n\n  /**\n   * Create a range with numbers or BigNumbers\n   * @param {number | BigNumber | Unit} start\n   * @param {number | BigNumber | Unit} end\n   * @param {number | BigNumber | Unit} step\n   * @param {boolean} includeEnd\n   * @returns {Array} range\n   * @private\n   */\n  function _range(start, end, step, includeEnd) {\n    var array = [];\n    var ongoing = isPositive(step) ? includeEnd ? smallerEq : smaller : includeEnd ? largerEq : larger;\n    var x = start;\n    while (ongoing(x, end)) {\n      array.push(x);\n      x = add(x, step);\n    }\n    return array;\n  }\n\n  /**\n   * Parse a string into a range,\n   * The string contains the start, optional step, and end, separated by a colon.\n   * If the string does not contain a valid range, null is returned.\n   * For example str='0:2:11'.\n   * @param {string} str\n   * @return {{start: number, end: number, step: number} | null} range Object containing properties start, end, step\n   * @private\n   */\n  function _parse(str) {\n    var args = str.split(':');\n\n    // number\n    var nums = args.map(function (arg) {\n      // use Number and not parseFloat as Number returns NaN on invalid garbage in the string\n      return Number(arg);\n    });\n    var invalid = nums.some(function (num) {\n      return isNaN(num);\n    });\n    if (invalid) {\n      return null;\n    }\n    switch (nums.length) {\n      case 2:\n        return {\n          start: nums[0],\n          end: nums[1],\n          step: 1\n        };\n      case 3:\n        return {\n          start: nums[0],\n          end: nums[2],\n          step: nums[1]\n        };\n      default:\n        return null;\n    }\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2040, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/reshape.js"],"sourcesContent":["import { reshape as arrayReshape } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'reshape';\nvar dependencies = ['typed', 'isInteger', 'matrix'];\nexport var createReshape = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    isInteger\n  } = _ref;\n  /**\n   * Reshape a multi dimensional array to fit the specified dimensions\n   *\n   * Syntax:\n   *\n   *     math.reshape(x, sizes)\n   *\n   * Examples:\n   *\n   *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3])\n   *     // returns Array  [[1, 2, 3], [4, 5, 6]]\n   *\n   *     math.reshape([[1, 2], [3, 4]], [1, 4])\n   *     // returns Array  [[1, 2, 3, 4]]\n   *\n   *     math.reshape([[1, 2], [3, 4]], [4])\n   *     // returns Array [1, 2, 3, 4]\n   *\n   *     const x = math.matrix([1, 2, 3, 4, 5, 6, 7, 8])\n   *     math.reshape(x, [2, 2, 2])\n   *     // returns Matrix [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n   *\n   *    math.reshape([1, 2, 3, 4], [-1, 2])\n   *    // returns Matrix [[1, 2], [3, 4]]\n   *\n   * See also:\n   *\n   *     size, squeeze, resize\n   *\n   * @param {Array | Matrix | *} x  Matrix to be reshaped\n   * @param {number[]} sizes        One dimensional array with integral sizes for\n   *                                each dimension. One -1 is allowed as wildcard,\n   *                                which calculates this dimension automatically.\n   *\n   * @return {* | Array | Matrix}   A reshaped clone of matrix `x`\n   *\n   * @throws {TypeError}            If `sizes` does not contain solely integers\n   * @throws {DimensionError}       If the product of the new dimension sizes does\n   *                                not equal that of the old ones\n   */\n  return typed(name, {\n    'Matrix, Array': function Matrix_Array(x, sizes) {\n      return x.reshape(sizes, true);\n    },\n    'Array, Array': function Array_Array(x, sizes) {\n      sizes.forEach(function (size) {\n        if (!isInteger(size)) {\n          throw new TypeError('Invalid size for dimension: ' + size);\n        }\n      });\n      return arrayReshape(x, sizes);\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAa;CAAS;AAC5C,IAAI,gBAAgB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACpE,IAAI,EACF,KAAK,EACL,SAAS,EACV,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuCC,GACD,OAAO,MAAM,MAAM;QACjB,iBAAiB,SAAS,aAAa,CAAC,EAAE,KAAK;YAC7C,OAAO,EAAE,OAAO,CAAC,OAAO;QAC1B;QACA,gBAAgB,SAAS,YAAY,CAAC,EAAE,KAAK;YAC3C,MAAM,OAAO,CAAC,SAAU,IAAI;gBAC1B,IAAI,CAAC,UAAU,OAAO;oBACpB,MAAM,IAAI,UAAU,iCAAiC;gBACvD;YACF;YACA,OAAO,CAAA,GAAA,sJAAA,CAAA,UAAY,AAAD,EAAE,GAAG;QACzB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2114, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/resize.js"],"sourcesContent":["import { isBigNumber, isMatrix } from '../../utils/is.js';\nimport { DimensionError } from '../../error/DimensionError.js';\nimport { ArgumentsError } from '../../error/ArgumentsError.js';\nimport { isInteger } from '../../utils/number.js';\nimport { format } from '../../utils/string.js';\nimport { clone } from '../../utils/object.js';\nimport { resize as arrayResize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'resize';\nvar dependencies = ['config', 'matrix'];\nexport var createResize = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    matrix\n  } = _ref;\n  /**\n   * Resize a matrix\n   *\n   * Syntax:\n   *\n   *     math.resize(x, size)\n   *     math.resize(x, size, defaultValue)\n   *\n   * Examples:\n   *\n   *     math.resize([1, 2, 3, 4, 5], [3]) // returns Array  [1, 2, 3]\n   *     math.resize([1, 2, 3], [5], 0)    // returns Array  [1, 2, 3, 0, 0]\n   *     math.resize(2, [2, 3], 0)         // returns Matrix [[2, 0, 0], [0, 0, 0]]\n   *     math.resize(\"hello\", [8], \"!\")    // returns string 'hello!!!'\n   *\n   * See also:\n   *\n   *     size, squeeze, subset, reshape\n   *\n   * @param {Array | Matrix | *} x             Matrix to be resized\n   * @param {Array | Matrix} size              One dimensional array with numbers\n   * @param {number | string} [defaultValue=0] Zero by default, except in\n   *                                           case of a string, in that case\n   *                                           defaultValue = ' '\n   * @return {* | Array | Matrix} A resized clone of matrix `x`\n   */\n  // TODO: rework resize to a typed-function\n  return function resize(x, size, defaultValue) {\n    if (arguments.length !== 2 && arguments.length !== 3) {\n      throw new ArgumentsError('resize', arguments.length, 2, 3);\n    }\n    if (isMatrix(size)) {\n      size = size.valueOf(); // get Array\n    }\n    if (isBigNumber(size[0])) {\n      // convert bignumbers to numbers\n      size = size.map(function (value) {\n        return !isBigNumber(value) ? value : value.toNumber();\n      });\n    }\n\n    // check x is a Matrix\n    if (isMatrix(x)) {\n      // use optimized matrix implementation, return copy\n      return x.resize(size, defaultValue, true);\n    }\n    if (typeof x === 'string') {\n      // resize string\n      return _resizeString(x, size, defaultValue);\n    }\n\n    // check result should be a matrix\n    var asMatrix = Array.isArray(x) ? false : config.matrix !== 'Array';\n    if (size.length === 0) {\n      // output a scalar\n      while (Array.isArray(x)) {\n        x = x[0];\n      }\n      return clone(x);\n    } else {\n      // output an array/matrix\n      if (!Array.isArray(x)) {\n        x = [x];\n      }\n      x = clone(x);\n      var res = arrayResize(x, size, defaultValue);\n      return asMatrix ? matrix(res) : res;\n    }\n  };\n\n  /**\n   * Resize a string\n   * @param {string} str\n   * @param {number[]} size\n   * @param {string} [defaultChar=' ']\n   * @private\n   */\n  function _resizeString(str, size, defaultChar) {\n    if (defaultChar !== undefined) {\n      if (typeof defaultChar !== 'string' || defaultChar.length !== 1) {\n        throw new TypeError('Single character expected as defaultValue');\n      }\n    } else {\n      defaultChar = ' ';\n    }\n    if (size.length !== 1) {\n      throw new DimensionError(size.length, 1);\n    }\n    var len = size[0];\n    if (typeof len !== 'number' || !isInteger(len)) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n    }\n    if (str.length > len) {\n      return str.substring(0, len);\n    } else if (str.length < len) {\n      var res = str;\n      for (var i = 0, ii = len - str.length; i < ii; i++) {\n        res += defaultChar;\n      }\n      return res;\n    } else {\n      return str;\n    }\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2249, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/rotate.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { arraySize } from '../../utils/array.js';\nvar name = 'rotate';\nvar dependencies = ['typed', 'multiply', 'rotationMatrix'];\nexport var createRotate = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    multiply,\n    rotationMatrix\n  } = _ref;\n  /**\n     * Rotate a vector of size 1x2 counter-clockwise by a given angle\n     * Rotate a vector of size 1x3 counter-clockwise by a given angle around the given axis\n     *\n     * Syntax:\n     *\n     *    math.rotate(w, theta)\n     *    math.rotate(w, theta, v)\n     *\n     * Examples:\n     *\n     *    math.rotate([11, 12], math.pi / 2)                           // returns [-12, 11]\n     *    math.rotate(matrix([11, 12]), math.pi / 2)                   // returns [-12, 11]\n     *\n     *    math.rotate([1, 0, 0], unit('90deg'), [0, 0, 1])             // returns [0, 1, 0]\n     *    math.rotate(matrix([1, 0, 0]), unit('90deg'), [0, 0, 1])     // returns Matrix [0, 1, 0]\n     *\n     *    math.rotate([1, 0], math.complex(1 + i))                     // returns [cos(1 + i) - sin(1 + i), sin(1 + i) + cos(1 + i)]\n     *\n     * See also:\n     *\n     *    matrix, rotationMatrix\n     *\n     * @param {Array | Matrix} w                             Vector to rotate\n     * @param {number | BigNumber | Complex | Unit} theta    Rotation angle\n     * @param {Array | Matrix} [v]                           Rotation axis\n     * @return {Array | Matrix}                              Multiplication of the rotation matrix and w\n     */\n  return typed(name, {\n    'Array , number | BigNumber | Complex | Unit': function Array__number__BigNumber__Complex__Unit(w, theta) {\n      _validateSize(w, 2);\n      var matrixRes = multiply(rotationMatrix(theta), w);\n      return matrixRes.toArray();\n    },\n    'Matrix , number | BigNumber | Complex | Unit': function Matrix__number__BigNumber__Complex__Unit(w, theta) {\n      _validateSize(w, 2);\n      return multiply(rotationMatrix(theta), w);\n    },\n    'Array, number | BigNumber | Complex | Unit, Array | Matrix': function Array_number__BigNumber__Complex__Unit_Array__Matrix(w, theta, v) {\n      _validateSize(w, 3);\n      var matrixRes = multiply(rotationMatrix(theta, v), w);\n      return matrixRes;\n    },\n    'Matrix, number | BigNumber | Complex | Unit, Array | Matrix': function Matrix_number__BigNumber__Complex__Unit_Array__Matrix(w, theta, v) {\n      _validateSize(w, 3);\n      return multiply(rotationMatrix(theta, v), w);\n    }\n  });\n  function _validateSize(v, expectedSize) {\n    var actualSize = Array.isArray(v) ? arraySize(v) : v.size();\n    if (actualSize.length > 2) {\n      throw new RangeError(\"Vector must be of dimensions 1x\".concat(expectedSize));\n    }\n    if (actualSize.length === 2 && actualSize[1] !== 1) {\n      throw new RangeError(\"Vector must be of dimensions 1x\".concat(expectedSize));\n    }\n    if (actualSize[0] !== expectedSize) {\n      throw new RangeError(\"Vector must be of dimensions 1x\".concat(expectedSize));\n    }\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAY;CAAiB;AACnD,IAAI,eAAe,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACnE,IAAI,EACF,KAAK,EACL,QAAQ,EACR,cAAc,EACf,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;KA2BG,GACH,OAAO,MAAM,MAAM;QACjB,+CAA+C,SAAS,wCAAwC,CAAC,EAAE,KAAK;YACtG,cAAc,GAAG;YACjB,IAAI,YAAY,SAAS,eAAe,QAAQ;YAChD,OAAO,UAAU,OAAO;QAC1B;QACA,gDAAgD,SAAS,yCAAyC,CAAC,EAAE,KAAK;YACxG,cAAc,GAAG;YACjB,OAAO,SAAS,eAAe,QAAQ;QACzC;QACA,8DAA8D,SAAS,qDAAqD,CAAC,EAAE,KAAK,EAAE,CAAC;YACrI,cAAc,GAAG;YACjB,IAAI,YAAY,SAAS,eAAe,OAAO,IAAI;YACnD,OAAO;QACT;QACA,+DAA+D,SAAS,sDAAsD,CAAC,EAAE,KAAK,EAAE,CAAC;YACvI,cAAc,GAAG;YACjB,OAAO,SAAS,eAAe,OAAO,IAAI;QAC5C;IACF;;IACA,SAAS,cAAc,CAAC,EAAE,YAAY;QACpC,IAAI,aAAa,MAAM,OAAO,CAAC,KAAK,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE,KAAK,EAAE,IAAI;QACzD,IAAI,WAAW,MAAM,GAAG,GAAG;YACzB,MAAM,IAAI,WAAW,kCAAkC,MAAM,CAAC;QAChE;QACA,IAAI,WAAW,MAAM,KAAK,KAAK,UAAU,CAAC,EAAE,KAAK,GAAG;YAClD,MAAM,IAAI,WAAW,kCAAkC,MAAM,CAAC;QAChE;QACA,IAAI,UAAU,CAAC,EAAE,KAAK,cAAc;YAClC,MAAM,IAAI,WAAW,kCAAkC,MAAM,CAAC;QAChE;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2331, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js"],"sourcesContent":["import { isBigNumber } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'rotationMatrix';\nvar dependencies = ['typed', 'config', 'multiplyScalar', 'addScalar', 'unaryMinus', 'norm', 'matrix', 'BigNumber', 'DenseMatrix', 'SparseMatrix', 'cos', 'sin'];\nexport var createRotationMatrix = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    multiplyScalar,\n    addScalar,\n    unaryMinus,\n    norm,\n    BigNumber,\n    matrix,\n    DenseMatrix,\n    SparseMatrix,\n    cos,\n    sin\n  } = _ref;\n  /**\n   * Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).\n   * Create a 2-dimensional counter-clockwise rotation matrix (3x3) by a given angle (expressed in radians) around a given axis (1x3).\n   *\n   * Syntax:\n   *\n   *    math.rotationMatrix(theta)\n   *    math.rotationMatrix(theta, format)\n   *    math.rotationMatrix(theta, [v])\n   *    math.rotationMatrix(theta, [v], format)\n   *\n   * Examples:\n   *\n   *    math.rotationMatrix(math.pi / 2)                      // returns [[0, -1], [1, 0]]\n   *    math.rotationMatrix(math.bignumber(1))                // returns [[bignumber(cos(1)), bignumber(-sin(1))], [bignumber(sin(1)), bignumber(cos(1))]]\n   *    math.rotationMatrix(math.complex(1 + i))              // returns [[cos(1 + i), -sin(1 + i)], [sin(1 + i), cos(1 + i)]]\n   *    math.rotationMatrix(math.unit('1rad'))                // returns [[cos(1), -sin(1)], [sin(1), cos(1)]]\n   *\n   *    math.rotationMatrix(math.pi / 2, [0, 1, 0])           // returns [[0, 0, 1], [0, 1, 0], [-1, 0, 0]]\n   *    math.rotationMatrix(math.pi / 2, matrix([0, 1, 0]))   // returns matrix([[0, 0, 1], [0, 1, 0], [-1, 0, 0]])\n   *\n   *\n   * See also:\n   *\n   *    matrix, cos, sin\n   *\n   *\n   * @param {number | BigNumber | Complex | Unit} theta    Rotation angle\n   * @param {Array | Matrix} [v]                           Rotation axis\n   * @param {string} [format]                              Result Matrix storage format\n   * @return {Array | Matrix}                              Rotation matrix\n   */\n\n  return typed(name, {\n    '': function _() {\n      return config.matrix === 'Matrix' ? matrix([]) : [];\n    },\n    string: function string(format) {\n      return matrix(format);\n    },\n    'number | BigNumber | Complex | Unit': function number__BigNumber__Complex__Unit(theta) {\n      return _rotationMatrix2x2(theta, config.matrix === 'Matrix' ? 'dense' : undefined);\n    },\n    'number | BigNumber | Complex | Unit, string': function number__BigNumber__Complex__Unit_string(theta, format) {\n      return _rotationMatrix2x2(theta, format);\n    },\n    'number | BigNumber | Complex | Unit, Array': function number__BigNumber__Complex__Unit_Array(theta, v) {\n      var matrixV = matrix(v);\n      _validateVector(matrixV);\n      return _rotationMatrix3x3(theta, matrixV, undefined);\n    },\n    'number | BigNumber | Complex | Unit, Matrix': function number__BigNumber__Complex__Unit_Matrix(theta, v) {\n      _validateVector(v);\n      var storageType = v.storage() || (config.matrix === 'Matrix' ? 'dense' : undefined);\n      return _rotationMatrix3x3(theta, v, storageType);\n    },\n    'number | BigNumber | Complex | Unit, Array, string': function number__BigNumber__Complex__Unit_Array_string(theta, v, format) {\n      var matrixV = matrix(v);\n      _validateVector(matrixV);\n      return _rotationMatrix3x3(theta, matrixV, format);\n    },\n    'number | BigNumber | Complex | Unit, Matrix, string': function number__BigNumber__Complex__Unit_Matrix_string(theta, v, format) {\n      _validateVector(v);\n      return _rotationMatrix3x3(theta, v, format);\n    }\n  });\n\n  /**\n   * Returns 2x2 matrix of 2D rotation of angle theta\n   *\n   * @param {number | BigNumber | Complex | Unit} theta  The rotation angle\n   * @param {string} format                              The result Matrix storage format\n   * @returns {Matrix}\n   * @private\n   */\n  function _rotationMatrix2x2(theta, format) {\n    var Big = isBigNumber(theta);\n    var minusOne = Big ? new BigNumber(-1) : -1;\n    var cosTheta = cos(theta);\n    var sinTheta = sin(theta);\n    var data = [[cosTheta, multiplyScalar(minusOne, sinTheta)], [sinTheta, cosTheta]];\n    return _convertToFormat(data, format);\n  }\n  function _validateVector(v) {\n    var size = v.size();\n    if (size.length < 1 || size[0] !== 3) {\n      throw new RangeError('Vector must be of dimensions 1x3');\n    }\n  }\n  function _mul(array) {\n    return array.reduce((p, curr) => multiplyScalar(p, curr));\n  }\n  function _convertToFormat(data, format) {\n    if (format) {\n      if (format === 'sparse') {\n        return new SparseMatrix(data);\n      }\n      if (format === 'dense') {\n        return new DenseMatrix(data);\n      }\n      throw new TypeError(\"Unknown matrix type \\\"\".concat(format, \"\\\"\"));\n    }\n    return data;\n  }\n\n  /**\n   * Returns a 3x3 matrix of rotation of angle theta around vector v\n   *\n   * @param {number | BigNumber | Complex | Unit} theta The rotation angle\n   * @param {Matrix} v                                  The rotation axis vector\n   * @param {string} format                             The storage format of the resulting matrix\n   * @returns {Matrix}\n   * @private\n   */\n  function _rotationMatrix3x3(theta, v, format) {\n    var normV = norm(v);\n    if (normV === 0) {\n      throw new RangeError('Rotation around zero vector');\n    }\n    var Big = isBigNumber(theta) ? BigNumber : null;\n    var one = Big ? new Big(1) : 1;\n    var minusOne = Big ? new Big(-1) : -1;\n    var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;\n    var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;\n    var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;\n    var c = cos(theta);\n    var oneMinusC = addScalar(one, unaryMinus(c));\n    var s = sin(theta);\n    var r11 = addScalar(c, _mul([vx, vx, oneMinusC]));\n    var r12 = addScalar(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));\n    var r13 = addScalar(_mul([vx, vz, oneMinusC]), _mul([vy, s]));\n    var r21 = addScalar(_mul([vx, vy, oneMinusC]), _mul([vz, s]));\n    var r22 = addScalar(c, _mul([vy, vy, oneMinusC]));\n    var r23 = addScalar(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));\n    var r31 = addScalar(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));\n    var r32 = addScalar(_mul([vy, vz, oneMinusC]), _mul([vx, s]));\n    var r33 = addScalar(c, _mul([vz, vz, oneMinusC]));\n    var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];\n    return _convertToFormat(data, format);\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2591, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/row.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { validateIndex } from '../../utils/array.js';\nvar name = 'row';\nvar dependencies = ['typed', 'Index', 'matrix', 'range'];\nexport var createRow = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    Index,\n    matrix,\n    range\n  } = _ref;\n  /**\n   * Return a row from a Matrix.\n   *\n   * Syntax:\n   *\n   *     math.row(value, index)\n   *\n   * Example:\n   *\n   *     // get a row\n   *     const d = [[1, 2], [3, 4]]\n   *     math.row(d, 1) // returns [[3, 4]]\n   *\n   * See also:\n   *\n   *     column\n   *\n   * @param {Array | Matrix } value   An array or matrix\n   * @param {number} row              The index of the row\n   * @return {Array | Matrix}         The retrieved row\n   */\n  return typed(name, {\n    'Matrix, number': _row,\n    'Array, number': function Array_number(value, row) {\n      return _row(matrix(clone(value)), row).valueOf();\n    }\n  });\n\n  /**\n   * Retrieve a row of a matrix\n   * @param {Matrix } value  A matrix\n   * @param {number} row     The index of the row\n   * @return {Matrix}        The retrieved row\n   */\n  function _row(value, row) {\n    // check dimensions\n    if (value.size().length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    }\n    validateIndex(row, value.size()[0]);\n    var columnRange = range(0, value.size()[1]);\n    var index = new Index(row, columnRange);\n    var result = value.subset(index);\n    return isMatrix(result) ? result : matrix([[result]]);\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAS;IAAU;CAAQ;AACjD,IAAI,YAAY,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAChE,IAAI,EACF,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;GAoBC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB;QAClB,iBAAiB,SAAS,aAAa,KAAK,EAAE,GAAG;YAC/C,OAAO,KAAK,OAAO,CAAA,GAAA,uJAAA,CAAA,QAAK,AAAD,EAAE,SAAS,KAAK,OAAO;QAChD;IACF;;IAEA;;;;;GAKC,GACD,SAAS,KAAK,KAAK,EAAE,GAAG;QACtB,mBAAmB;QACnB,IAAI,MAAM,IAAI,GAAG,MAAM,KAAK,GAAG;YAC7B,MAAM,IAAI,MAAM;QAClB;QACA,CAAA,GAAA,sJAAA,CAAA,gBAAa,AAAD,EAAE,KAAK,MAAM,IAAI,EAAE,CAAC,EAAE;QAClC,IAAI,cAAc,MAAM,GAAG,MAAM,IAAI,EAAE,CAAC,EAAE;QAC1C,IAAI,QAAQ,IAAI,MAAM,KAAK;QAC3B,IAAI,SAAS,MAAM,MAAM,CAAC;QAC1B,OAAO,CAAA,GAAA,mJAAA,CAAA,WAAQ,AAAD,EAAE,UAAU,SAAS,OAAO;YAAC;gBAAC;aAAO;SAAC;IACtD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2665, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/size.js"],"sourcesContent":["import { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { noMatrix } from '../../utils/noop.js';\nvar name = 'size';\nvar dependencies = ['typed', 'config', '?matrix'];\nexport var createSize = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    matrix\n  } = _ref;\n  /**\n   * Calculate the size of a matrix or scalar.\n   *\n   * Syntax:\n   *\n   *     math.size(x)\n   *\n   * Examples:\n   *\n   *     math.size(2.3)                       // returns []\n   *     math.size('hello world')             // returns [11]\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.size(A)                         // returns [2, 3]\n   *     math.size(math.range(1,6).toArray()) // returns [5]\n   *\n   * See also:\n   *\n   *     count, resize, squeeze, subset\n   *\n   * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix\n   * @return {Array | Matrix} A vector with size of `x`.\n   */\n  return typed(name, {\n    Matrix: function Matrix(x) {\n      return x.create(x.size(), 'number');\n    },\n    Array: arraySize,\n    string: function string(x) {\n      return config.matrix === 'Array' ? [x.length] : matrix([x.length], 'dense', 'number');\n    },\n    'number | Complex | BigNumber | Unit | boolean | null': function number__Complex__BigNumber__Unit__boolean__null(x) {\n      // scalar\n      return config.matrix === 'Array' ? [] : matrix ? matrix([], 'dense', 'number') : noMatrix();\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;CAAU;AAC1C,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACL,MAAM,EACN,MAAM,EACP,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;GAsBC,GACD,OAAO,MAAM,MAAM;QACjB,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,EAAE,MAAM,CAAC,EAAE,IAAI,IAAI;QAC5B;QACA,OAAO,sJAAA,CAAA,YAAS;QAChB,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,OAAO,MAAM,KAAK,UAAU;gBAAC,EAAE,MAAM;aAAC,GAAG,OAAO;gBAAC,EAAE,MAAM;aAAC,EAAE,SAAS;QAC9E;QACA,wDAAwD,SAAS,gDAAgD,CAAC;YAChH,SAAS;YACT,OAAO,OAAO,MAAM,KAAK,UAAU,EAAE,GAAG,SAAS,OAAO,EAAE,EAAE,SAAS,YAAY,CAAA,GAAA,qJAAA,CAAA,WAAQ,AAAD;QAC1F;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2728, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/squeeze.js"],"sourcesContent":["import { clone } from '../../utils/object.js';\nimport { squeeze as arraySqueeze } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'squeeze';\nvar dependencies = ['typed'];\nexport var createSqueeze = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.\n   *\n   * Syntax:\n   *\n   *     math.squeeze(x)\n   *\n   * Examples:\n   *\n   *     math.squeeze([3])           // returns 3\n   *     math.squeeze([[3]])         // returns 3\n   *\n   *     const A = math.zeros(3, 1)    // returns [[0], [0], [0]] (size 3x1)\n   *     math.squeeze(A)             // returns [0, 0, 0] (size 3)\n   *\n   *     const B = math.zeros(1, 3)    // returns [[0, 0, 0]] (size 1x3)\n   *     math.squeeze(B)             // returns [0, 0, 0] (size 3)\n   *\n   *     // only inner and outer dimensions are removed\n   *     const C = math.zeros(2, 1, 3) // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)\n   *     math.squeeze(C)             // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)\n   *\n   * See also:\n   *\n   *     subset\n   *\n   * @param {Matrix | Array} x      Matrix to be squeezed\n   * @return {Matrix | Array} Squeezed matrix\n   */\n  return typed(name, {\n    Array: function Array(x) {\n      return arraySqueeze(clone(x));\n    },\n    Matrix: function Matrix(x) {\n      var res = arraySqueeze(x.toArray());\n      // FIXME: return the same type of matrix as the input\n      return Array.isArray(res) ? x.create(res, x.datatype()) : res;\n    },\n    any: function any(x) {\n      // scalar\n      return clone(x);\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;CAAQ;AACrB,IAAI,gBAAgB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACpE,IAAI,EACF,KAAK,EACN,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BC,GACD,OAAO,MAAM,MAAM;QACjB,OAAO,SAAS,OAAM,CAAC;YACrB,OAAO,CAAA,GAAA,sJAAA,CAAA,UAAY,AAAD,EAAE,CAAA,GAAA,uJAAA,CAAA,QAAK,AAAD,EAAE;QAC5B;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,IAAI,MAAM,CAAA,GAAA,sJAAA,CAAA,UAAY,AAAD,EAAE,EAAE,OAAO;YAChC,qDAAqD;YACrD,OAAO,MAAM,OAAO,CAAC,OAAO,EAAE,MAAM,CAAC,KAAK,EAAE,QAAQ,MAAM;QAC5D;QACA,KAAK,SAAS,IAAI,CAAC;YACjB,SAAS;YACT,OAAO,CAAA,GAAA,uJAAA,CAAA,QAAK,AAAD,EAAE;QACf;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2792, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/subset.js"],"sourcesContent":["import { isIndex } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { isEmptyIndex, validateIndex, validateIndexSourceSize } from '../../utils/array.js';\nimport { getSafeProperty, setSafeProperty } from '../../utils/customs.js';\nimport { DimensionError } from '../../error/DimensionError.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'subset';\nvar dependencies = ['typed', 'matrix', 'zeros', 'add'];\nexport var createSubset = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    zeros,\n    add\n  } = _ref;\n  /**\n   * Get or set a subset of a matrix or string.\n   *\n   * Syntax:\n   *     math.subset(value, index)                                // retrieve a subset\n   *     math.subset(value, index, replacement [, defaultValue])  // replace a subset\n   *\n   * Examples:\n   *\n   *     // get a subset\n   *     const d = [[1, 2], [3, 4]]\n   *     math.subset(d, math.index(1, 0))             // returns 3\n   *     math.subset(d, math.index([0, 1], 1))        // returns [[2], [4]]\n   *     math.subset(d, math.index([false, true], 0)) // returns [[3]]\n   *\n   *     // replace a subset\n   *     const e = []\n   *     const f = math.subset(e, math.index(0, [0, 2]), [5, 6])  // f = [[5, 0, 6]]\n   *     const g = math.subset(f, math.index(1, 1), 7, 0)         // g = [[5, 0, 6], [0, 7, 0]]\n   *     math.subset(g, math.index([false, true], 1), 8)          // returns [[5, 0, 6], [0, 8, 0]]\n   *\n   *     // get submatrix using ranges\n   *     const M = [\n   *       [1,2,3],\n   *       [4,5,6],\n   *       [7,8,9]\n   *     ]\n   *     math.subset(M, math.index(math.range(0,2), math.range(0,3))) // [[1, 2, 3], [4, 5, 6]]\n   *\n   * See also:\n   *\n   *     size, resize, squeeze, index\n   *\n   * @param {Array | Matrix | string} matrix  An array, matrix, or string\n   * @param {Index} index\n   *    For each dimension of the target, specifies an index or a list of\n   *    indices to fetch or set. `subset` uses the cartesian product of\n   *    the indices specified in each dimension.\n   * @param {*} [replacement]                 An array, matrix, or scalar.\n   *                                          If provided, the subset is replaced with replacement.\n   *                                          If not provided, the subset is returned\n   * @param {*} [defaultValue=undefined]      Default value, filled in on new entries when\n   *                                          the matrix is resized. If not provided,\n   *                                          math.matrix elements will be left undefined.\n   * @return {Array | Matrix | string} Either the retrieved subset or the updated matrix.\n   */\n\n  return typed(name, {\n    // get subset\n    'Matrix, Index': function Matrix_Index(value, index) {\n      if (isEmptyIndex(index)) {\n        return matrix();\n      }\n      validateIndexSourceSize(value, index);\n      return value.subset(index);\n    },\n    'Array, Index': typed.referTo('Matrix, Index', function (subsetRef) {\n      return function (value, index) {\n        var subsetResult = subsetRef(matrix(value), index);\n        return index.isScalar() ? subsetResult : subsetResult.valueOf();\n      };\n    }),\n    'Object, Index': _getObjectProperty,\n    'string, Index': _getSubstring,\n    // set subset\n    'Matrix, Index, any, any': function Matrix_Index_any_any(value, index, replacement, defaultValue) {\n      if (isEmptyIndex(index)) {\n        return value;\n      }\n      validateIndexSourceSize(value, index);\n      return value.clone().subset(index, _broadcastReplacement(replacement, index), defaultValue);\n    },\n    'Array, Index, any, any': typed.referTo('Matrix, Index, any, any', function (subsetRef) {\n      return function (value, index, replacement, defaultValue) {\n        var subsetResult = subsetRef(matrix(value), index, replacement, defaultValue);\n        return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;\n      };\n    }),\n    'Array, Index, any': typed.referTo('Matrix, Index, any, any', function (subsetRef) {\n      return function (value, index, replacement) {\n        return subsetRef(matrix(value), index, replacement, undefined).valueOf();\n      };\n    }),\n    'Matrix, Index, any': typed.referTo('Matrix, Index, any, any', function (subsetRef) {\n      return function (value, index, replacement) {\n        return subsetRef(value, index, replacement, undefined);\n      };\n    }),\n    'string, Index, string': _setSubstring,\n    'string, Index, string, string': _setSubstring,\n    'Object, Index, any': _setObjectProperty\n  });\n\n  /**\n   * Broadcasts a replacment value to be the same size as index\n   * @param {number | BigNumber | Array | Matrix} replacement Replacement value to try to broadcast\n   * @param {*} index Index value\n   * @returns broadcasted replacement that matches the size of index\n   */\n\n  function _broadcastReplacement(replacement, index) {\n    if (typeof replacement === 'string') {\n      throw new Error('can\\'t boradcast a string');\n    }\n    if (index._isScalar) {\n      return replacement;\n    }\n    var indexSize = index.size();\n    if (indexSize.every(d => d > 0)) {\n      try {\n        return add(replacement, zeros(indexSize));\n      } catch (error) {\n        return replacement;\n      }\n    } else {\n      return replacement;\n    }\n  }\n});\n\n/**\n * Retrieve a subset of a string\n * @param {string} str            string from which to get a substring\n * @param {Index} index           An index or list of indices (character positions)\n * @returns {string} substring\n * @private\n */\nfunction _getSubstring(str, index) {\n  if (!isIndex(index)) {\n    // TODO: better error message\n    throw new TypeError('Index expected');\n  }\n  if (isEmptyIndex(index)) {\n    return '';\n  }\n  validateIndexSourceSize(Array.from(str), index);\n  if (index.size().length !== 1) {\n    throw new DimensionError(index.size().length, 1);\n  }\n\n  // validate whether the range is out of range\n  var strLen = str.length;\n  validateIndex(index.min()[0], strLen);\n  validateIndex(index.max()[0], strLen);\n  var range = index.dimension(0);\n  var substr = '';\n  range.forEach(function (v) {\n    substr += str.charAt(v);\n  });\n  return substr;\n}\n\n/**\n * Replace a substring in a string\n * @param {string} str            string to be replaced\n * @param {Index} index           An index or list of indices (character positions)\n * @param {string} replacement    Replacement string\n * @param {string} [defaultValue] Default value to be used when resizing\n *                                the string. is ' ' by default\n * @returns {string} result\n * @private\n */\nfunction _setSubstring(str, index, replacement, defaultValue) {\n  if (!index || index.isIndex !== true) {\n    // TODO: better error message\n    throw new TypeError('Index expected');\n  }\n  if (isEmptyIndex(index)) {\n    return str;\n  }\n  validateIndexSourceSize(Array.from(str), index);\n  if (index.size().length !== 1) {\n    throw new DimensionError(index.size().length, 1);\n  }\n  if (defaultValue !== undefined) {\n    if (typeof defaultValue !== 'string' || defaultValue.length !== 1) {\n      throw new TypeError('Single character expected as defaultValue');\n    }\n  } else {\n    defaultValue = ' ';\n  }\n  var range = index.dimension(0);\n  var len = range.size()[0];\n  if (len !== replacement.length) {\n    throw new DimensionError(range.size()[0], replacement.length);\n  }\n\n  // validate whether the range is out of range\n  var strLen = str.length;\n  validateIndex(index.min()[0]);\n  validateIndex(index.max()[0]);\n\n  // copy the string into an array with characters\n  var chars = [];\n  for (var i = 0; i < strLen; i++) {\n    chars[i] = str.charAt(i);\n  }\n  range.forEach(function (v, i) {\n    chars[v] = replacement.charAt(i[0]);\n  });\n\n  // initialize undefined characters with a space\n  if (chars.length > strLen) {\n    for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {\n      if (!chars[_i]) {\n        chars[_i] = defaultValue;\n      }\n    }\n  }\n  return chars.join('');\n}\n\n/**\n * Retrieve a property from an object\n * @param {Object} object\n * @param {Index} index\n * @return {*} Returns the value of the property\n * @private\n */\nfunction _getObjectProperty(object, index) {\n  if (isEmptyIndex(index)) {\n    return undefined;\n  }\n  if (index.size().length !== 1) {\n    throw new DimensionError(index.size(), 1);\n  }\n  var key = index.dimension(0);\n  if (typeof key !== 'string') {\n    throw new TypeError('String expected as index to retrieve an object property');\n  }\n  return getSafeProperty(object, key);\n}\n\n/**\n * Set a property on an object\n * @param {Object} object\n * @param {Index} index\n * @param {*} replacement\n * @return {*} Returns the updated object\n * @private\n */\nfunction _setObjectProperty(object, index, replacement) {\n  if (isEmptyIndex(index)) {\n    return object;\n  }\n  if (index.size().length !== 1) {\n    throw new DimensionError(index.size(), 1);\n  }\n  var key = index.dimension(0);\n  if (typeof key !== 'string') {\n    throw new TypeError('String expected as index to retrieve an object property');\n  }\n\n  // clone the object, and apply the property to the clone\n  var updated = clone(object);\n  setSafeProperty(updated, key, replacement);\n  return updated;\n}"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAS;CAAM;AAC/C,IAAI,eAAe,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACnE,IAAI,EACF,KAAK,EACL,MAAM,EACN,KAAK,EACL,GAAG,EACJ,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6CC,GAED,OAAO,MAAM,MAAM;QACjB,aAAa;QACb,iBAAiB,SAAS,aAAa,KAAK,EAAE,KAAK;YACjD,IAAI,CAAA,GAAA,sJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ;gBACvB,OAAO;YACT;YACA,CAAA,GAAA,sJAAA,CAAA,0BAAuB,AAAD,EAAE,OAAO;YAC/B,OAAO,MAAM,MAAM,CAAC;QACtB;QACA,gBAAgB,MAAM,OAAO,CAAC,iBAAiB,SAAU,SAAS;YAChE,OAAO,SAAU,KAAK,EAAE,KAAK;gBAC3B,IAAI,eAAe,UAAU,OAAO,QAAQ;gBAC5C,OAAO,MAAM,QAAQ,KAAK,eAAe,aAAa,OAAO;YAC/D;QACF;QACA,iBAAiB;QACjB,iBAAiB;QACjB,aAAa;QACb,2BAA2B,SAAS,qBAAqB,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,YAAY;YAC9F,IAAI,CAAA,GAAA,sJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ;gBACvB,OAAO;YACT;YACA,CAAA,GAAA,sJAAA,CAAA,0BAAuB,AAAD,EAAE,OAAO;YAC/B,OAAO,MAAM,KAAK,GAAG,MAAM,CAAC,OAAO,sBAAsB,aAAa,QAAQ;QAChF;QACA,0BAA0B,MAAM,OAAO,CAAC,2BAA2B,SAAU,SAAS;YACpF,OAAO,SAAU,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,YAAY;gBACtD,IAAI,eAAe,UAAU,OAAO,QAAQ,OAAO,aAAa;gBAChE,OAAO,aAAa,QAAQ,GAAG,aAAa,OAAO,KAAK;YAC1D;QACF;QACA,qBAAqB,MAAM,OAAO,CAAC,2BAA2B,SAAU,SAAS;YAC/E,OAAO,SAAU,KAAK,EAAE,KAAK,EAAE,WAAW;gBACxC,OAAO,UAAU,OAAO,QAAQ,OAAO,aAAa,WAAW,OAAO;YACxE;QACF;QACA,sBAAsB,MAAM,OAAO,CAAC,2BAA2B,SAAU,SAAS;YAChF,OAAO,SAAU,KAAK,EAAE,KAAK,EAAE,WAAW;gBACxC,OAAO,UAAU,OAAO,OAAO,aAAa;YAC9C;QACF;QACA,yBAAyB;QACzB,iCAAiC;QACjC,sBAAsB;IACxB;;IAEA;;;;;GAKC,GAED,SAAS,sBAAsB,WAAW,EAAE,KAAK;QAC/C,IAAI,OAAO,gBAAgB,UAAU;YACnC,MAAM,IAAI,MAAM;QAClB;QACA,IAAI,MAAM,SAAS,EAAE;YACnB,OAAO;QACT;QACA,IAAI,YAAY,MAAM,IAAI;QAC1B,IAAI,UAAU,KAAK,CAAC,CAAA,IAAK,IAAI,IAAI;YAC/B,IAAI;gBACF,OAAO,IAAI,aAAa,MAAM;YAChC,EAAE,OAAO,OAAO;gBACd,OAAO;YACT;QACF,OAAO;YACL,OAAO;QACT;IACF;AACF;AAEA;;;;;;CAMC,GACD,SAAS,cAAc,GAAG,EAAE,KAAK;IAC/B,IAAI,CAAC,CAAA,GAAA,mJAAA,CAAA,UAAO,AAAD,EAAE,QAAQ;QACnB,6BAA6B;QAC7B,MAAM,IAAI,UAAU;IACtB;IACA,IAAI,CAAA,GAAA,sJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ;QACvB,OAAO;IACT;IACA,CAAA,GAAA,sJAAA,CAAA,0BAAuB,AAAD,EAAE,MAAM,IAAI,CAAC,MAAM;IACzC,IAAI,MAAM,IAAI,GAAG,MAAM,KAAK,GAAG;QAC7B,MAAM,IAAI,+JAAA,CAAA,iBAAc,CAAC,MAAM,IAAI,GAAG,MAAM,EAAE;IAChD;IAEA,6CAA6C;IAC7C,IAAI,SAAS,IAAI,MAAM;IACvB,CAAA,GAAA,sJAAA,CAAA,gBAAa,AAAD,EAAE,MAAM,GAAG,EAAE,CAAC,EAAE,EAAE;IAC9B,CAAA,GAAA,sJAAA,CAAA,gBAAa,AAAD,EAAE,MAAM,GAAG,EAAE,CAAC,EAAE,EAAE;IAC9B,IAAI,QAAQ,MAAM,SAAS,CAAC;IAC5B,IAAI,SAAS;IACb,MAAM,OAAO,CAAC,SAAU,CAAC;QACvB,UAAU,IAAI,MAAM,CAAC;IACvB;IACA,OAAO;AACT;AAEA;;;;;;;;;CASC,GACD,SAAS,cAAc,GAAG,EAAE,KAAK,EAAE,WAAW,EAAE,YAAY;IAC1D,IAAI,CAAC,SAAS,MAAM,OAAO,KAAK,MAAM;QACpC,6BAA6B;QAC7B,MAAM,IAAI,UAAU;IACtB;IACA,IAAI,CAAA,GAAA,sJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ;QACvB,OAAO;IACT;IACA,CAAA,GAAA,sJAAA,CAAA,0BAAuB,AAAD,EAAE,MAAM,IAAI,CAAC,MAAM;IACzC,IAAI,MAAM,IAAI,GAAG,MAAM,KAAK,GAAG;QAC7B,MAAM,IAAI,+JAAA,CAAA,iBAAc,CAAC,MAAM,IAAI,GAAG,MAAM,EAAE;IAChD;IACA,IAAI,iBAAiB,WAAW;QAC9B,IAAI,OAAO,iBAAiB,YAAY,aAAa,MAAM,KAAK,GAAG;YACjE,MAAM,IAAI,UAAU;QACtB;IACF,OAAO;QACL,eAAe;IACjB;IACA,IAAI,QAAQ,MAAM,SAAS,CAAC;IAC5B,IAAI,MAAM,MAAM,IAAI,EAAE,CAAC,EAAE;IACzB,IAAI,QAAQ,YAAY,MAAM,EAAE;QAC9B,MAAM,IAAI,+JAAA,CAAA,iBAAc,CAAC,MAAM,IAAI,EAAE,CAAC,EAAE,EAAE,YAAY,MAAM;IAC9D;IAEA,6CAA6C;IAC7C,IAAI,SAAS,IAAI,MAAM;IACvB,CAAA,GAAA,sJAAA,CAAA,gBAAa,AAAD,EAAE,MAAM,GAAG,EAAE,CAAC,EAAE;IAC5B,CAAA,GAAA,sJAAA,CAAA,gBAAa,AAAD,EAAE,MAAM,GAAG,EAAE,CAAC,EAAE;IAE5B,gDAAgD;IAChD,IAAI,QAAQ,EAAE;IACd,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC/B,KAAK,CAAC,EAAE,GAAG,IAAI,MAAM,CAAC;IACxB;IACA,MAAM,OAAO,CAAC,SAAU,CAAC,EAAE,CAAC;QAC1B,KAAK,CAAC,EAAE,GAAG,YAAY,MAAM,CAAC,CAAC,CAAC,EAAE;IACpC;IAEA,+CAA+C;IAC/C,IAAI,MAAM,MAAM,GAAG,QAAQ;QACzB,IAAK,IAAI,KAAK,SAAS,GAAG,OAAO,MAAM,MAAM,EAAE,KAAK,MAAM,KAAM;YAC9D,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE;gBACd,KAAK,CAAC,GAAG,GAAG;YACd;QACF;IACF;IACA,OAAO,MAAM,IAAI,CAAC;AACpB;AAEA;;;;;;CAMC,GACD,SAAS,mBAAmB,MAAM,EAAE,KAAK;IACvC,IAAI,CAAA,GAAA,sJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ;QACvB,OAAO;IACT;IACA,IAAI,MAAM,IAAI,GAAG,MAAM,KAAK,GAAG;QAC7B,MAAM,IAAI,+JAAA,CAAA,iBAAc,CAAC,MAAM,IAAI,IAAI;IACzC;IACA,IAAI,MAAM,MAAM,SAAS,CAAC;IAC1B,IAAI,OAAO,QAAQ,UAAU;QAC3B,MAAM,IAAI,UAAU;IACtB;IACA,OAAO,CAAA,GAAA,wJAAA,CAAA,kBAAe,AAAD,EAAE,QAAQ;AACjC;AAEA;;;;;;;CAOC,GACD,SAAS,mBAAmB,MAAM,EAAE,KAAK,EAAE,WAAW;IACpD,IAAI,CAAA,GAAA,sJAAA,CAAA,eAAY,AAAD,EAAE,QAAQ;QACvB,OAAO;IACT;IACA,IAAI,MAAM,IAAI,GAAG,MAAM,KAAK,GAAG;QAC7B,MAAM,IAAI,+JAAA,CAAA,iBAAc,CAAC,MAAM,IAAI,IAAI;IACzC;IACA,IAAI,MAAM,MAAM,SAAS,CAAC;IAC1B,IAAI,OAAO,QAAQ,UAAU;QAC3B,MAAM,IAAI,UAAU;IACtB;IAEA,wDAAwD;IACxD,IAAI,UAAU,CAAA,GAAA,uJAAA,CAAA,QAAK,AAAD,EAAE;IACpB,CAAA,GAAA,wJAAA,CAAA,kBAAe,AAAD,EAAE,SAAS,KAAK;IAC9B,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3063, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/transpose.js"],"sourcesContent":["import { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'transpose';\nvar dependencies = ['typed', 'matrix'];\nexport var createTranspose = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix\n  } = _ref;\n  /**\n   * Transpose a matrix. All values of the matrix are reflected over its\n   * main diagonal. Only applicable to two dimensional matrices containing\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\n   * vectors and scalars return the input unchanged.\n   *\n   * Syntax:\n   *\n   *     math.transpose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, 6]]\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\n   *\n   * See also:\n   *\n   *     diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be transposed\n   * @return {Array | Matrix}   The transposed matrix\n   */\n  return typed(name, {\n    Array: x => transposeMatrix(matrix(x)).valueOf(),\n    Matrix: transposeMatrix,\n    any: clone // scalars\n  });\n  function transposeMatrix(x) {\n    // matrix size\n    var size = x.size();\n\n    // result\n    var c;\n\n    // process dimensions\n    switch (size.length) {\n      case 1:\n        // vector\n        c = x.clone();\n        break;\n      case 2:\n        {\n          // rows and columns\n          var rows = size[0];\n          var columns = size[1];\n\n          // check columns\n          if (columns === 0) {\n            // throw exception\n            throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');\n          }\n\n          // process storage format\n          switch (x.storage()) {\n            case 'dense':\n              c = _denseTranspose(x, rows, columns);\n              break;\n            case 'sparse':\n              c = _sparseTranspose(x, rows, columns);\n              break;\n          }\n        }\n        break;\n      default:\n        // multi dimensional\n        throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(size) + ')');\n    }\n    return c;\n  }\n  function _denseTranspose(m, rows, columns) {\n    // matrix array\n    var data = m._data;\n    // transposed matrix data\n    var transposed = [];\n    var transposedRow;\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // initialize row\n      transposedRow = transposed[j] = [];\n      // loop rows\n      for (var i = 0; i < rows; i++) {\n        // set data\n        transposedRow[i] = clone(data[i][j]);\n      }\n    }\n    // return matrix\n    return m.createDenseMatrix({\n      data: transposed,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n  function _sparseTranspose(m, rows, columns) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n    // result matrices\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = [];\n    // row counts\n    var w = [];\n    for (var x = 0; x < rows; x++) {\n      w[x] = 0;\n    }\n    // vars\n    var p, l, j;\n    // loop values in matrix\n    for (p = 0, l = index.length; p < l; p++) {\n      // number of values in row\n      w[index[p]]++;\n    }\n    // cumulative sum\n    var sum = 0;\n    // initialize cptr with the cummulative sum of row counts\n    for (var i = 0; i < rows; i++) {\n      // update cptr\n      cptr.push(sum);\n      // update sum\n      sum += w[i];\n      // update w\n      w[i] = cptr[i];\n    }\n    // update cptr\n    cptr.push(sum);\n    // loop columns\n    for (j = 0; j < columns; j++) {\n      // values & index in column\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\n        // C values & index\n        var q = w[index[k]]++;\n        // C[j, i] = A[i, j]\n        cindex[q] = j;\n        // check we need to process values (pattern matrix)\n        if (values) {\n          cvalues[q] = clone(values[k]);\n        }\n      }\n    }\n    // return matrix\n    return m.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3238, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/ctranspose.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'ctranspose';\nvar dependencies = ['typed', 'transpose', 'conj'];\nexport var createCtranspose = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    transpose,\n    conj\n  } = _ref;\n  /**\n   * Transpose and complex conjugate a matrix. All values of the matrix are\n   * reflected over its main diagonal and then the complex conjugate is\n   * taken. This is equivalent to complex conjugation for scalars and\n   * vectors.\n   *\n   * Syntax:\n   *\n   *     math.ctranspose(x)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 2, 3], [4, 5, math.complex(6,7)]]\n   *     math.ctranspose(A)               // returns [[1, 4], [2, 5], [3, {re:6,im:7}]]\n   *\n   * See also:\n   *\n   *     transpose, diag, inv, subset, squeeze\n   *\n   * @param {Array | Matrix} x  Matrix to be ctransposed\n   * @return {Array | Matrix}   The ctransposed matrix\n   */\n  return typed(name, {\n    any: function any(x) {\n      return conj(transpose(x));\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAa;CAAO;AAC1C,IAAI,mBAAmB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACvE,IAAI,EACF,KAAK,EACL,SAAS,EACT,IAAI,EACL,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;GAqBC,GACD,OAAO,MAAM,MAAM;QACjB,KAAK,SAAS,IAAI,CAAC;YACjB,OAAO,KAAK,UAAU;QACxB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3284, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/zeros.js"],"sourcesContent":["import { isBigNumber } from '../../utils/is.js';\nimport { isInteger } from '../../utils/number.js';\nimport { resize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'zeros';\nvar dependencies = ['typed', 'config', 'matrix', 'BigNumber'];\nexport var createZeros = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    matrix,\n    BigNumber\n  } = _ref;\n  /**\n   * Create a matrix filled with zeros. The created matrix can have one or\n   * multiple dimensions.\n   *\n   * Syntax:\n   *\n   *    math.zeros(m)\n   *    math.zeros(m, format)\n   *    math.zeros(m, n)\n   *    math.zeros(m, n, format)\n   *    math.zeros([m, n])\n   *    math.zeros([m, n], format)\n   *\n   * Examples:\n   *\n   *    math.zeros()                   // returns []\n   *    math.zeros(3)                  // returns [0, 0, 0]\n   *    math.zeros(3, 2)               // returns [[0, 0], [0, 0], [0, 0]]\n   *    math.zeros(3, 'dense')         // returns [0, 0, 0]\n   *\n   *    const A = [[1, 2, 3], [4, 5, 6]]\n   *    math.zeros(math.size(A))       // returns [[0, 0, 0], [0, 0, 0]]\n   *\n   * See also:\n   *\n   *    ones, identity, size, range\n   *\n   * @param {...(number|BigNumber) | Array} size    The size of each dimension of the matrix\n   * @param {string} [format]           The Matrix storage format\n   *\n   * @return {Array | Matrix}           A matrix filled with zeros\n   */\n  return typed(name, {\n    '': function _() {\n      return config.matrix === 'Array' ? _zeros([]) : _zeros([], 'default');\n    },\n    // math.zeros(m, n, p, ..., format)\n    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this\n    '...number | BigNumber | string': function number__BigNumber__string(size) {\n      var last = size[size.length - 1];\n      if (typeof last === 'string') {\n        var format = size.pop();\n        return _zeros(size, format);\n      } else if (config.matrix === 'Array') {\n        return _zeros(size);\n      } else {\n        return _zeros(size, 'default');\n      }\n    },\n    Array: _zeros,\n    Matrix: function Matrix(size) {\n      var format = size.storage();\n      return _zeros(size.valueOf(), format);\n    },\n    'Array | Matrix, string': function Array__Matrix_string(size, format) {\n      return _zeros(size.valueOf(), format);\n    }\n  });\n\n  /**\n   * Create an Array or Matrix with zeros\n   * @param {Array} size\n   * @param {string} [format='default']\n   * @return {Array | Matrix}\n   * @private\n   */\n  function _zeros(size, format) {\n    var hasBigNumbers = _normalize(size);\n    var defaultValue = hasBigNumbers ? new BigNumber(0) : 0;\n    _validate(size);\n    if (format) {\n      // return a matrix\n      var m = matrix(format);\n      if (size.length > 0) {\n        return m.resize(size, defaultValue);\n      }\n      return m;\n    } else {\n      // return an Array\n      var arr = [];\n      if (size.length > 0) {\n        return resize(arr, size, defaultValue);\n      }\n      return arr;\n    }\n  }\n\n  // replace BigNumbers with numbers, returns true if size contained BigNumbers\n  function _normalize(size) {\n    var hasBigNumbers = false;\n    size.forEach(function (value, index, arr) {\n      if (isBigNumber(value)) {\n        hasBigNumbers = true;\n        arr[index] = value.toNumber();\n      }\n    });\n    return hasBigNumbers;\n  }\n\n  // validate arguments\n  function _validate(size) {\n    size.forEach(function (value) {\n      if (typeof value !== 'number' || !isInteger(value) || value < 0) {\n        throw new Error('Parameters in function zeros must be positive integers');\n      }\n    });\n  }\n});\n\n// TODO: zeros contains almost the same code as ones. Reuse this?"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAU;CAAY;AACtD,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,KAAK,EACL,MAAM,EACN,MAAM,EACN,SAAS,EACV,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BC,GACD,OAAO,MAAM,MAAM;QACjB,IAAI,SAAS;YACX,OAAO,OAAO,MAAM,KAAK,UAAU,OAAO,EAAE,IAAI,OAAO,EAAE,EAAE;QAC7D;QACA,mCAAmC;QACnC,wGAAwG;QACxG,kCAAkC,SAAS,0BAA0B,IAAI;YACvE,IAAI,OAAO,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE;YAChC,IAAI,OAAO,SAAS,UAAU;gBAC5B,IAAI,SAAS,KAAK,GAAG;gBACrB,OAAO,OAAO,MAAM;YACtB,OAAO,IAAI,OAAO,MAAM,KAAK,SAAS;gBACpC,OAAO,OAAO;YAChB,OAAO;gBACL,OAAO,OAAO,MAAM;YACtB;QACF;QACA,OAAO;QACP,QAAQ,SAAS,OAAO,IAAI;YAC1B,IAAI,SAAS,KAAK,OAAO;YACzB,OAAO,OAAO,KAAK,OAAO,IAAI;QAChC;QACA,0BAA0B,SAAS,qBAAqB,IAAI,EAAE,MAAM;YAClE,OAAO,OAAO,KAAK,OAAO,IAAI;QAChC;IACF;;IAEA;;;;;;GAMC,GACD,SAAS,OAAO,IAAI,EAAE,MAAM;QAC1B,IAAI,gBAAgB,WAAW;QAC/B,IAAI,eAAe,gBAAgB,IAAI,UAAU,KAAK;QACtD,UAAU;QACV,IAAI,QAAQ;YACV,kBAAkB;YAClB,IAAI,IAAI,OAAO;YACf,IAAI,KAAK,MAAM,GAAG,GAAG;gBACnB,OAAO,EAAE,MAAM,CAAC,MAAM;YACxB;YACA,OAAO;QACT,OAAO;YACL,kBAAkB;YAClB,IAAI,MAAM,EAAE;YACZ,IAAI,KAAK,MAAM,GAAG,GAAG;gBACnB,OAAO,CAAA,GAAA,sJAAA,CAAA,SAAM,AAAD,EAAE,KAAK,MAAM;YAC3B;YACA,OAAO;QACT;IACF;IAEA,6EAA6E;IAC7E,SAAS,WAAW,IAAI;QACtB,IAAI,gBAAgB;QACpB,KAAK,OAAO,CAAC,SAAU,KAAK,EAAE,KAAK,EAAE,GAAG;YACtC,IAAI,CAAA,GAAA,mJAAA,CAAA,cAAW,AAAD,EAAE,QAAQ;gBACtB,gBAAgB;gBAChB,GAAG,CAAC,MAAM,GAAG,MAAM,QAAQ;YAC7B;QACF;QACA,OAAO;IACT;IAEA,qBAAqB;IACrB,SAAS,UAAU,IAAI;QACrB,KAAK,OAAO,CAAC,SAAU,KAAK;YAC1B,IAAI,OAAO,UAAU,YAAY,CAAC,CAAA,GAAA,uJAAA,CAAA,YAAS,AAAD,EAAE,UAAU,QAAQ,GAAG;gBAC/D,MAAM,IAAI,MAAM;YAClB;QACF;IACF;AACF,IAEA,iEAAiE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3414, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/fft.js"],"sourcesContent":["import { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'fft';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'divideScalar', 'exp', 'tau', 'i', 'dotDivide', 'conj', 'pow', 'ceil', 'log2'];\nexport var createFft = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    addScalar,\n    multiplyScalar,\n    divideScalar,\n    exp,\n    tau,\n    i: I,\n    dotDivide,\n    conj,\n    pow,\n    ceil,\n    log2\n  } = _ref;\n  /**\n   * Calculate N-dimensional Fourier transform\n   *\n   * Syntax:\n   *\n   *     math.fft(arr)\n   *\n   * Examples:\n   *\n   *    math.fft([[1, 0], [1, 0]]) // returns [[{re:2, im:0}, {re:2, im:0}], [{re:0, im:0}, {re:0, im:0}]]\n   *\n   *\n   * See Also:\n   *\n   *      ifft\n   *\n   * @param {Array | Matrix} arr    An array or matrix\n   * @return {Array | Matrix}       N-dimensional Fourier transformation of the array\n   */\n  return typed(name, {\n    Array: _ndFft,\n    Matrix: function Matrix(matrix) {\n      return matrix.create(_ndFft(matrix.valueOf()), matrix.datatype());\n    }\n  });\n\n  /**\n   * Perform an N-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n  function _ndFft(arr) {\n    var size = arraySize(arr);\n    if (size.length === 1) return _fft(arr, size[0]);\n    // ndFft along dimension 1,...,N-1 then 1dFft along dimension 0\n    return _1dFft(arr.map(slice => _ndFft(slice, size.slice(1))), 0);\n  }\n\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @param {number} dim     dimension of the array to perform on\n   * @return {Array}         resulting array\n   */\n  function _1dFft(arr, dim) {\n    var size = arraySize(arr);\n    if (dim !== 0) return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));\n    if (size.length === 1) return _fft(arr);\n    function _transpose(arr) {\n      // Swap first 2 dimensions\n      var size = arraySize(arr);\n      return new Array(size[1]).fill(0).map((_, j) => new Array(size[0]).fill(0).map((_, i) => arr[i][j]));\n    }\n    return _transpose(_1dFft(_transpose(arr), 1));\n  }\n  /**\n   * Perform an 1-dimensional non-power-of-2 Fourier transform using Chirp-Z Transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n  function _czt(arr) {\n    var n = arr.length;\n    var w = exp(divideScalar(multiplyScalar(-1, multiplyScalar(I, tau)), n));\n    var chirp = [];\n    for (var i = 1 - n; i < n; i++) {\n      chirp.push(pow(w, divideScalar(pow(i, 2), 2)));\n    }\n    var N2 = pow(2, ceil(log2(n + n - 1)));\n    var xp = [...new Array(n).fill(0).map((_, i) => multiplyScalar(arr[i], chirp[n - 1 + i])), ...new Array(N2 - n).fill(0)];\n    var ichirp = [...new Array(n + n - 1).fill(0).map((_, i) => divideScalar(1, chirp[i])), ...new Array(N2 - (n + n - 1)).fill(0)];\n    var fftXp = _fft(xp);\n    var fftIchirp = _fft(ichirp);\n    var fftProduct = new Array(N2).fill(0).map((_, i) => multiplyScalar(fftXp[i], fftIchirp[i]));\n    var ifftProduct = dotDivide(conj(_ndFft(conj(fftProduct))), N2);\n    var ret = [];\n    for (var _i = n - 1; _i < n + n - 1; _i++) {\n      ret.push(multiplyScalar(ifftProduct[_i], chirp[_i]));\n    }\n    return ret;\n  }\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n  function _fft(arr) {\n    var len = arr.length;\n    if (len === 1) return [arr[0]];\n    if (len % 2 === 0) {\n      var ret = [..._fft(arr.filter((_, i) => i % 2 === 0), len / 2), ..._fft(arr.filter((_, i) => i % 2 === 1), len / 2)];\n      for (var k = 0; k < len / 2; k++) {\n        var p = ret[k];\n        var q = multiplyScalar(ret[k + len / 2], exp(multiplyScalar(multiplyScalar(tau, I), divideScalar(-k, len))));\n        ret[k] = addScalar(p, q);\n        ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));\n      }\n      return ret;\n    } else {\n      // use chirp-z transform for non-power-of-2 FFT\n      return _czt(arr);\n    }\n    // throw new Error('Can only calculate FFT of power-of-two size')\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3558, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/ifft.js"],"sourcesContent":["import { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { isMatrix } from '../../utils/is.js';\nvar name = 'ifft';\nvar dependencies = ['typed', 'fft', 'dotDivide', 'conj'];\nexport var createIfft = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    fft,\n    dotDivide,\n    conj\n  } = _ref;\n  /**\n   * Calculate N-dimensional inverse Fourier transform\n   *\n   * Syntax:\n   *\n   *     math.ifft(arr)\n   *\n   * Examples:\n   *\n   *    math.ifft([[2, 2], [0, 0]]) // returns [[{re:1, im:0}, {re:0, im:0}], [{re:1, im:0}, {re:0, im:0}]]\n   *\n   * See Also:\n   *\n   *      fft\n   *\n   * @param {Array | Matrix} arr    An array or matrix\n   * @return {Array | Matrix}       N-dimensional Fourier transformation of the array\n   */\n  return typed(name, {\n    'Array | Matrix': function Array__Matrix(arr) {\n      var size = isMatrix(arr) ? arr.size() : arraySize(arr);\n      return dotDivide(conj(fft(conj(arr))), size.reduce((acc, curr) => acc * curr, 1));\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAO;IAAa;CAAO;AACjD,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACL,GAAG,EACH,SAAS,EACT,IAAI,EACL,GAAG;IACJ;;;;;;;;;;;;;;;;;GAiBC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB,SAAS,cAAc,GAAG;YAC1C,IAAI,OAAO,CAAA,GAAA,mJAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,IAAI,IAAI,KAAK,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE;YAClD,OAAO,UAAU,KAAK,IAAI,KAAK,QAAQ,KAAK,MAAM,CAAC,CAAC,KAAK,OAAS,MAAM,MAAM;QAChF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3606, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { isInteger } from '../../utils/number.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'partitionSelect';\nvar dependencies = ['typed', 'isNumeric', 'isNaN', 'compare'];\nexport var createPartitionSelect = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    isNumeric,\n    isNaN,\n    compare\n  } = _ref;\n  var asc = compare;\n  var desc = (a, b) => -compare(a, b);\n\n  /**\n   * Partition-based selection of an array or 1D matrix.\n   * Will find the kth smallest value, and mutates the input array.\n   * Uses Quickselect.\n   *\n   * Syntax:\n   *\n   *    math.partitionSelect(x, k)\n   *    math.partitionSelect(x, k, compare)\n   *\n   * Examples:\n   *\n   *    math.partitionSelect([5, 10, 1], 2)                               // returns 10\n   *    math.partitionSelect(['C', 'B', 'A', 'D'], 1, math.compareText)   // returns 'B'\n   *\n   *    function sortByLength (a, b) {\n   *      return a.length - b.length\n   *    }\n   *    math.partitionSelect(['Langdon', 'Tom', 'Sara'], 2, sortByLength) // returns 'Langdon'\n   *\n   *    // the input array is mutated\n   *    arr = [5, 2, 1]\n   *    math.partitionSelect(arr, 0) // returns 1, arr is now: [1, 2, 5]\n   *    math.partitionSelect(arr, 1, 'desc') // returns 2, arr is now: [5, 2, 1]\n   *\n   * See also:\n   *\n   *    sort\n   *\n   * @param {Matrix | Array} x    A one dimensional matrix or array to sort\n   * @param {Number} k            The kth smallest value to be retrieved zero-based index\n   * @param {Function | 'asc' | 'desc'} [compare='asc']\n   *        An optional comparator function. The function is called as\n   *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,\n   *        and 0 when a == b.\n   * @return {*} Returns the kth lowest value.\n   */\n  return typed(name, {\n    'Array | Matrix, number': function Array__Matrix_number(x, k) {\n      return _partitionSelect(x, k, asc);\n    },\n    'Array | Matrix, number, string': function Array__Matrix_number_string(x, k, compare) {\n      if (compare === 'asc') {\n        return _partitionSelect(x, k, asc);\n      } else if (compare === 'desc') {\n        return _partitionSelect(x, k, desc);\n      } else {\n        throw new Error('Compare string must be \"asc\" or \"desc\"');\n      }\n    },\n    'Array | Matrix, number, function': _partitionSelect\n  });\n  function _partitionSelect(x, k, compare) {\n    if (!isInteger(k) || k < 0) {\n      throw new Error('k must be a non-negative integer');\n    }\n    if (isMatrix(x)) {\n      var size = x.size();\n      if (size.length > 1) {\n        throw new Error('Only one dimensional matrices supported');\n      }\n      return quickSelect(x.valueOf(), k, compare);\n    }\n    if (Array.isArray(x)) {\n      return quickSelect(x, k, compare);\n    }\n  }\n\n  /**\n   * Quickselect algorithm.\n   * Code adapted from:\n   * https://blog.teamleadnet.com/2012/07/quick-select-algorithm-find-kth-element.html\n   *\n   * @param {Array} arr\n   * @param {Number} k\n   * @param {Function} compare\n   * @private\n   */\n  function quickSelect(arr, k, compare) {\n    if (k >= arr.length) {\n      throw new Error('k out of bounds');\n    }\n\n    // check for NaN values since these can cause an infinite while loop\n    for (var i = 0; i < arr.length; i++) {\n      if (isNumeric(arr[i]) && isNaN(arr[i])) {\n        return arr[i]; // return NaN\n      }\n    }\n    var from = 0;\n    var to = arr.length - 1;\n\n    // if from == to we reached the kth element\n    while (from < to) {\n      var r = from;\n      var w = to;\n      var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];\n\n      // stop if the reader and writer meets\n      while (r < w) {\n        // arr[r] >= pivot\n        if (compare(arr[r], pivot) >= 0) {\n          // put the large values at the end\n          var tmp = arr[w];\n          arr[w] = arr[r];\n          arr[r] = tmp;\n          --w;\n        } else {\n          // the value is smaller than the pivot, skip\n          ++r;\n        }\n      }\n\n      // if we stepped up (r++) we need to step one down (arr[r] > pivot)\n      if (compare(arr[r], pivot) > 0) {\n        --r;\n      }\n\n      // the r pointer is on the end of the first k elements\n      if (k <= r) {\n        to = r;\n      } else {\n        from = r + 1;\n      }\n    }\n    return arr[k];\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAa;IAAS;CAAU;AACtD,IAAI,wBAAwB,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAC5E,IAAI,EACF,KAAK,EACL,SAAS,EACT,KAAK,EACL,OAAO,EACR,GAAG;IACJ,IAAI,MAAM;IACV,IAAI,OAAO,CAAC,GAAG,IAAM,CAAC,QAAQ,GAAG;IAEjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoCC,GACD,OAAO,MAAM,MAAM;QACjB,0BAA0B,SAAS,qBAAqB,CAAC,EAAE,CAAC;YAC1D,OAAO,iBAAiB,GAAG,GAAG;QAChC;QACA,kCAAkC,SAAS,4BAA4B,CAAC,EAAE,CAAC,EAAE,OAAO;YAClF,IAAI,YAAY,OAAO;gBACrB,OAAO,iBAAiB,GAAG,GAAG;YAChC,OAAO,IAAI,YAAY,QAAQ;gBAC7B,OAAO,iBAAiB,GAAG,GAAG;YAChC,OAAO;gBACL,MAAM,IAAI,MAAM;YAClB;QACF;QACA,oCAAoC;IACtC;;IACA,SAAS,iBAAiB,CAAC,EAAE,CAAC,EAAE,OAAO;QACrC,IAAI,CAAC,CAAA,GAAA,uJAAA,CAAA,YAAS,AAAD,EAAE,MAAM,IAAI,GAAG;YAC1B,MAAM,IAAI,MAAM;QAClB;QACA,IAAI,CAAA,GAAA,mJAAA,CAAA,WAAQ,AAAD,EAAE,IAAI;YACf,IAAI,OAAO,EAAE,IAAI;YACjB,IAAI,KAAK,MAAM,GAAG,GAAG;gBACnB,MAAM,IAAI,MAAM;YAClB;YACA,OAAO,YAAY,EAAE,OAAO,IAAI,GAAG;QACrC;QACA,IAAI,MAAM,OAAO,CAAC,IAAI;YACpB,OAAO,YAAY,GAAG,GAAG;QAC3B;IACF;IAEA;;;;;;;;;GASC,GACD,SAAS,YAAY,GAAG,EAAE,CAAC,EAAE,OAAO;QAClC,IAAI,KAAK,IAAI,MAAM,EAAE;YACnB,MAAM,IAAI,MAAM;QAClB;QAEA,oEAAoE;QACpE,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAK;YACnC,IAAI,UAAU,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,CAAC,EAAE,GAAG;gBACtC,OAAO,GAAG,CAAC,EAAE,EAAE,aAAa;YAC9B;QACF;QACA,IAAI,OAAO;QACX,IAAI,KAAK,IAAI,MAAM,GAAG;QAEtB,2CAA2C;QAC3C,MAAO,OAAO,GAAI;YAChB,IAAI,IAAI;YACR,IAAI,IAAI;YACR,IAAI,QAAQ,GAAG,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,CAAC,KAAK,OAAO,CAAC,KAAK,KAAK;YAEnE,sCAAsC;YACtC,MAAO,IAAI,EAAG;gBACZ,kBAAkB;gBAClB,IAAI,QAAQ,GAAG,CAAC,EAAE,EAAE,UAAU,GAAG;oBAC/B,kCAAkC;oBAClC,IAAI,MAAM,GAAG,CAAC,EAAE;oBAChB,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE;oBACf,GAAG,CAAC,EAAE,GAAG;oBACT,EAAE;gBACJ,OAAO;oBACL,4CAA4C;oBAC5C,EAAE;gBACJ;YACF;YAEA,mEAAmE;YACnE,IAAI,QAAQ,GAAG,CAAC,EAAE,EAAE,SAAS,GAAG;gBAC9B,EAAE;YACJ;YAEA,sDAAsD;YACtD,IAAI,KAAK,GAAG;gBACV,KAAK;YACP,OAAO;gBACL,OAAO,IAAI;YACb;QACF;QACA,OAAO,GAAG,CAAC,EAAE;IACf;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3753, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/sort.js"],"sourcesContent":["import { arraySize as size } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'sort';\nvar dependencies = ['typed', 'matrix', 'compare', 'compareNatural'];\nexport var createSort = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    compare,\n    compareNatural\n  } = _ref;\n  var compareAsc = compare;\n  var compareDesc = (a, b) => -compare(a, b);\n\n  /**\n   * Sort the items in a matrix.\n   *\n   * Syntax:\n   *\n   *    math.sort(x)\n   *    math.sort(x, compare)\n   *\n   * Examples:\n   *\n   *    math.sort([5, 10, 1]) // returns [1, 5, 10]\n   *    math.sort(['C', 'B', 'A', 'D'], math.compareNatural)\n   *    // returns ['A', 'B', 'C', 'D']\n   *\n   *    function sortByLength (a, b) {\n   *      return a.length - b.length\n   *    }\n   *    math.sort(['Langdon', 'Tom', 'Sara'], sortByLength)\n   *    // returns ['Tom', 'Sara', 'Langdon']\n   *\n   * See also:\n   *\n   *    filter, forEach, map, compare, compareNatural\n   *\n   * @param {Matrix | Array} x    A one dimensional matrix or array to sort\n   * @param {Function | 'asc' | 'desc' | 'natural'} [compare='asc']\n   *        An optional _comparator function or name. The function is called as\n   *        `compare(a, b)`, and must return 1 when a > b, -1 when a < b,\n   *        and 0 when a == b.\n   * @return {Matrix | Array} Returns the sorted matrix.\n   */\n  return typed(name, {\n    Array: function Array(x) {\n      _arrayIsVector(x);\n      return x.sort(compareAsc);\n    },\n    Matrix: function Matrix(x) {\n      _matrixIsVector(x);\n      return matrix(x.toArray().sort(compareAsc), x.storage());\n    },\n    'Array, function': function Array_function(x, _comparator) {\n      _arrayIsVector(x);\n      return x.sort(_comparator);\n    },\n    'Matrix, function': function Matrix_function(x, _comparator) {\n      _matrixIsVector(x);\n      return matrix(x.toArray().sort(_comparator), x.storage());\n    },\n    'Array, string': function Array_string(x, order) {\n      _arrayIsVector(x);\n      return x.sort(_comparator(order));\n    },\n    'Matrix, string': function Matrix_string(x, order) {\n      _matrixIsVector(x);\n      return matrix(x.toArray().sort(_comparator(order)), x.storage());\n    }\n  });\n\n  /**\n   * Get the comparator for given order ('asc', 'desc', 'natural')\n   * @param {'asc' | 'desc' | 'natural'} order\n   * @return {Function} Returns a _comparator function\n   */\n  function _comparator(order) {\n    if (order === 'asc') {\n      return compareAsc;\n    } else if (order === 'desc') {\n      return compareDesc;\n    } else if (order === 'natural') {\n      return compareNatural;\n    } else {\n      throw new Error('String \"asc\", \"desc\", or \"natural\" expected');\n    }\n  }\n\n  /**\n   * Validate whether an array is one dimensional\n   * Throws an error when this is not the case\n   * @param {Array} array\n   * @private\n   */\n  function _arrayIsVector(array) {\n    if (size(array).length !== 1) {\n      throw new Error('One dimensional array expected');\n    }\n  }\n\n  /**\n   * Validate whether a matrix is one dimensional\n   * Throws an error when this is not the case\n   * @param {Matrix} matrix\n   * @private\n   */\n  function _matrixIsVector(matrix) {\n    if (matrix.size().length !== 1) {\n      throw new Error('One dimensional matrix expected');\n    }\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAW;CAAiB;AAC5D,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACL,MAAM,EACN,OAAO,EACP,cAAc,EACf,GAAG;IACJ,IAAI,aAAa;IACjB,IAAI,cAAc,CAAC,GAAG,IAAM,CAAC,QAAQ,GAAG;IAExC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8BC,GACD,OAAO,MAAM,MAAM;QACjB,OAAO,SAAS,MAAM,CAAC;YACrB,eAAe;YACf,OAAO,EAAE,IAAI,CAAC;QAChB;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,gBAAgB;YAChB,OAAO,OAAO,EAAE,OAAO,GAAG,IAAI,CAAC,aAAa,EAAE,OAAO;QACvD;QACA,mBAAmB,SAAS,eAAe,CAAC,EAAE,WAAW;YACvD,eAAe;YACf,OAAO,EAAE,IAAI,CAAC;QAChB;QACA,oBAAoB,SAAS,gBAAgB,CAAC,EAAE,WAAW;YACzD,gBAAgB;YAChB,OAAO,OAAO,EAAE,OAAO,GAAG,IAAI,CAAC,cAAc,EAAE,OAAO;QACxD;QACA,iBAAiB,SAAS,aAAa,CAAC,EAAE,KAAK;YAC7C,eAAe;YACf,OAAO,EAAE,IAAI,CAAC,YAAY;QAC5B;QACA,kBAAkB,SAAS,cAAc,CAAC,EAAE,KAAK;YAC/C,gBAAgB;YAChB,OAAO,OAAO,EAAE,OAAO,GAAG,IAAI,CAAC,YAAY,SAAS,EAAE,OAAO;QAC/D;IACF;;IAEA;;;;GAIC,GACD,SAAS,YAAY,KAAK;QACxB,IAAI,UAAU,OAAO;YACnB,OAAO;QACT,OAAO,IAAI,UAAU,QAAQ;YAC3B,OAAO;QACT,OAAO,IAAI,UAAU,WAAW;YAC9B,OAAO;QACT,OAAO;YACL,MAAM,IAAI,MAAM;QAClB;IACF;IAEA;;;;;GAKC,GACD,SAAS,eAAe,KAAK;QAC3B,IAAI,CAAA,GAAA,sJAAA,CAAA,YAAI,AAAD,EAAE,OAAO,MAAM,KAAK,GAAG;YAC5B,MAAM,IAAI,MAAM;QAClB;IACF;IAEA;;;;;GAKC,GACD,SAAS,gBAAgB,MAAM;QAC7B,IAAI,OAAO,IAAI,GAAG,MAAM,KAAK,GAAG;YAC9B,MAAM,IAAI,MAAM;QAClB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3870, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/dot.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { isMatrix } from '../../utils/is.js';\nvar name = 'dot';\nvar dependencies = ['typed', 'addScalar', 'multiplyScalar', 'conj', 'size'];\nexport var createDot = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    addScalar,\n    multiplyScalar,\n    conj,\n    size\n  } = _ref;\n  /**\n   * Calculate the dot product of two vectors. The dot product of\n   * `A = [a1, a2, ..., an]` and `B = [b1, b2, ..., bn]` is defined as:\n   *\n   *    dot(A, B) = conj(a1) * b1 + conj(a2) * b2 + ... + conj(an) * bn\n   *\n   * Syntax:\n   *\n   *    math.dot(x, y)\n   *\n   * Examples:\n   *\n   *    math.dot([2, 4, 1], [2, 2, 3])       // returns number 15\n   *    math.multiply([2, 4, 1], [2, 2, 3])  // returns number 15\n   *\n   * See also:\n   *\n   *    multiply, cross\n   *\n   * @param  {Array | Matrix} x     First vector\n   * @param  {Array | Matrix} y     Second vector\n   * @return {number}               Returns the dot product of `x` and `y`\n   */\n  return typed(name, {\n    'Array | DenseMatrix, Array | DenseMatrix': _denseDot,\n    'SparseMatrix, SparseMatrix': _sparseDot\n  });\n  function _validateDim(x, y) {\n    var xSize = _size(x);\n    var ySize = _size(y);\n    var xLen, yLen;\n    if (xSize.length === 1) {\n      xLen = xSize[0];\n    } else if (xSize.length === 2 && xSize[1] === 1) {\n      xLen = xSize[0];\n    } else {\n      throw new RangeError('Expected a column vector, instead got a matrix of size (' + xSize.join(', ') + ')');\n    }\n    if (ySize.length === 1) {\n      yLen = ySize[0];\n    } else if (ySize.length === 2 && ySize[1] === 1) {\n      yLen = ySize[0];\n    } else {\n      throw new RangeError('Expected a column vector, instead got a matrix of size (' + ySize.join(', ') + ')');\n    }\n    if (xLen !== yLen) throw new RangeError('Vectors must have equal length (' + xLen + ' != ' + yLen + ')');\n    if (xLen === 0) throw new RangeError('Cannot calculate the dot product of empty vectors');\n    return xLen;\n  }\n  function _denseDot(a, b) {\n    var N = _validateDim(a, b);\n    var adata = isMatrix(a) ? a._data : a;\n    var adt = isMatrix(a) ? a._datatype || a.getDataType() : undefined;\n    var bdata = isMatrix(b) ? b._data : b;\n    var bdt = isMatrix(b) ? b._datatype || b.getDataType() : undefined;\n\n    // are these 2-dimensional column vectors? (as opposed to 1-dimensional vectors)\n    var aIsColumn = _size(a).length === 2;\n    var bIsColumn = _size(b).length === 2;\n    var add = addScalar;\n    var mul = multiplyScalar;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      var dt = adt;\n      // find signatures that matches (dt, dt)\n      add = typed.find(addScalar, [dt, dt]);\n      mul = typed.find(multiplyScalar, [dt, dt]);\n    }\n\n    // both vectors 1-dimensional\n    if (!aIsColumn && !bIsColumn) {\n      var c = mul(conj(adata[0]), bdata[0]);\n      for (var i = 1; i < N; i++) {\n        c = add(c, mul(conj(adata[i]), bdata[i]));\n      }\n      return c;\n    }\n\n    // a is 1-dim, b is column\n    if (!aIsColumn && bIsColumn) {\n      var _c = mul(conj(adata[0]), bdata[0][0]);\n      for (var _i = 1; _i < N; _i++) {\n        _c = add(_c, mul(conj(adata[_i]), bdata[_i][0]));\n      }\n      return _c;\n    }\n\n    // a is column, b is 1-dim\n    if (aIsColumn && !bIsColumn) {\n      var _c2 = mul(conj(adata[0][0]), bdata[0]);\n      for (var _i2 = 1; _i2 < N; _i2++) {\n        _c2 = add(_c2, mul(conj(adata[_i2][0]), bdata[_i2]));\n      }\n      return _c2;\n    }\n\n    // both vectors are column\n    if (aIsColumn && bIsColumn) {\n      var _c3 = mul(conj(adata[0][0]), bdata[0][0]);\n      for (var _i3 = 1; _i3 < N; _i3++) {\n        _c3 = add(_c3, mul(conj(adata[_i3][0]), bdata[_i3][0]));\n      }\n      return _c3;\n    }\n  }\n  function _sparseDot(x, y) {\n    _validateDim(x, y);\n    var xindex = x._index;\n    var xvalues = x._values;\n    var yindex = y._index;\n    var yvalues = y._values;\n\n    // TODO optimize add & mul using datatype\n    var c = 0;\n    var add = addScalar;\n    var mul = multiplyScalar;\n    var i = 0;\n    var j = 0;\n    while (i < xindex.length && j < yindex.length) {\n      var I = xindex[i];\n      var J = yindex[j];\n      if (I < J) {\n        i++;\n        continue;\n      }\n      if (I > J) {\n        j++;\n        continue;\n      }\n      if (I === J) {\n        c = add(c, mul(xvalues[i], yvalues[j]));\n        i++;\n        j++;\n      }\n    }\n    return c;\n  }\n\n  // TODO remove this once #1771 is fixed\n  function _size(x) {\n    return isMatrix(x) ? x.size() : size(x);\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4035, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/trace.js"],"sourcesContent":["import { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'trace';\nvar dependencies = ['typed', 'matrix', 'add'];\nexport var createTrace = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    add\n  } = _ref;\n  /**\n   * Calculate the trace of a matrix: the sum of the elements on the main\n   * diagonal of a square matrix.\n   *\n   * Syntax:\n   *\n   *    math.trace(x)\n   *\n   * Examples:\n   *\n   *    math.trace([[1, 2], [3, 4]]) // returns 5\n   *\n   *    const A = [\n   *      [1, 2, 3],\n   *      [-1, 2, 3],\n   *      [2, 0, 3]\n   *    ]\n   *    math.trace(A) // returns 6\n   *\n   * See also:\n   *\n   *    diag\n   *\n   * @param {Array | Matrix} x  A matrix\n   *\n   * @return {number} The trace of `x`\n   */\n  return typed('trace', {\n    Array: function _arrayTrace(x) {\n      // use dense matrix implementation\n      return _denseTrace(matrix(x));\n    },\n    SparseMatrix: _sparseTrace,\n    DenseMatrix: _denseTrace,\n    any: clone\n  });\n  function _denseTrace(m) {\n    // matrix size & data\n    var size = m._size;\n    var data = m._data;\n\n    // process dimensions\n    switch (size.length) {\n      case 1:\n        // vector\n        if (size[0] === 1) {\n          // return data[0]\n          return clone(data[0]);\n        }\n        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n      case 2:\n        {\n          // two dimensional\n          var rows = size[0];\n          var cols = size[1];\n          if (rows === cols) {\n            // calulate sum\n            var sum = 0;\n            // loop diagonal\n            for (var i = 0; i < rows; i++) {\n              sum = add(sum, data[i][i]);\n            }\n            // return trace\n            return sum;\n          } else {\n            throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n          }\n        }\n      default:\n        // multi dimensional\n        throw new RangeError('Matrix must be two dimensional (size: ' + format(size) + ')');\n    }\n  }\n  function _sparseTrace(m) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n    var size = m._size;\n    // check dimensions\n    var rows = size[0];\n    var columns = size[1];\n    // matrix must be square\n    if (rows === columns) {\n      // calulate sum\n      var sum = 0;\n      // check we have data (avoid looping columns)\n      if (values.length > 0) {\n        // loop columns\n        for (var j = 0; j < columns; j++) {\n          // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n          var k0 = ptr[j];\n          var k1 = ptr[j + 1];\n          // loop k within [k0, k1[\n          for (var k = k0; k < k1; k++) {\n            // row index\n            var i = index[k];\n            // check row\n            if (i === j) {\n              // accumulate value\n              sum = add(sum, values[k]);\n              // exit loop\n              break;\n            }\n            if (i > j) {\n              // exit loop, no value on the diagonal for column j\n              break;\n            }\n          }\n        }\n      }\n      // return trace\n      return sum;\n    }\n    throw new RangeError('Matrix must be square (size: ' + format(size) + ')');\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;CAAM;AACtC,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,KAAK,EACL,MAAM,EACN,GAAG,EACJ,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BC,GACD,OAAO,MAAM,SAAS;QACpB,OAAO,SAAS,YAAY,CAAC;YAC3B,kCAAkC;YAClC,OAAO,YAAY,OAAO;QAC5B;QACA,cAAc;QACd,aAAa;QACb,KAAK,uJAAA,CAAA,QAAK;IACZ;;IACA,SAAS,YAAY,CAAC;QACpB,qBAAqB;QACrB,IAAI,OAAO,EAAE,KAAK;QAClB,IAAI,OAAO,EAAE,KAAK;QAElB,qBAAqB;QACrB,OAAQ,KAAK,MAAM;YACjB,KAAK;gBACH,SAAS;gBACT,IAAI,IAAI,CAAC,EAAE,KAAK,GAAG;oBACjB,iBAAiB;oBACjB,OAAO,CAAA,GAAA,uJAAA,CAAA,QAAK,AAAD,EAAE,IAAI,CAAC,EAAE;gBACtB;gBACA,MAAM,IAAI,WAAW,kCAAkC,CAAA,GAAA,uJAAA,CAAA,SAAM,AAAD,EAAE,QAAQ;YACxE,KAAK;gBACH;oBACE,kBAAkB;oBAClB,IAAI,OAAO,IAAI,CAAC,EAAE;oBAClB,IAAI,OAAO,IAAI,CAAC,EAAE;oBAClB,IAAI,SAAS,MAAM;wBACjB,eAAe;wBACf,IAAI,MAAM;wBACV,gBAAgB;wBAChB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,IAAK;4BAC7B,MAAM,IAAI,KAAK,IAAI,CAAC,EAAE,CAAC,EAAE;wBAC3B;wBACA,eAAe;wBACf,OAAO;oBACT,OAAO;wBACL,MAAM,IAAI,WAAW,kCAAkC,CAAA,GAAA,uJAAA,CAAA,SAAM,AAAD,EAAE,QAAQ;oBACxE;gBACF;YACF;gBACE,oBAAoB;gBACpB,MAAM,IAAI,WAAW,2CAA2C,CAAA,GAAA,uJAAA,CAAA,SAAM,AAAD,EAAE,QAAQ;QACnF;IACF;IACA,SAAS,aAAa,CAAC;QACrB,gBAAgB;QAChB,IAAI,SAAS,EAAE,OAAO;QACtB,IAAI,QAAQ,EAAE,MAAM;QACpB,IAAI,MAAM,EAAE,IAAI;QAChB,IAAI,OAAO,EAAE,KAAK;QAClB,mBAAmB;QACnB,IAAI,OAAO,IAAI,CAAC,EAAE;QAClB,IAAI,UAAU,IAAI,CAAC,EAAE;QACrB,wBAAwB;QACxB,IAAI,SAAS,SAAS;YACpB,eAAe;YACf,IAAI,MAAM;YACV,6CAA6C;YAC7C,IAAI,OAAO,MAAM,GAAG,GAAG;gBACrB,eAAe;gBACf,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,IAAK;oBAChC,oDAAoD;oBACpD,IAAI,KAAK,GAAG,CAAC,EAAE;oBACf,IAAI,KAAK,GAAG,CAAC,IAAI,EAAE;oBACnB,yBAAyB;oBACzB,IAAK,IAAI,IAAI,IAAI,IAAI,IAAI,IAAK;wBAC5B,YAAY;wBACZ,IAAI,IAAI,KAAK,CAAC,EAAE;wBAChB,YAAY;wBACZ,IAAI,MAAM,GAAG;4BACX,mBAAmB;4BACnB,MAAM,IAAI,KAAK,MAAM,CAAC,EAAE;4BAExB;wBACF;wBACA,IAAI,IAAI,GAAG;4BAET;wBACF;oBACF;gBACF;YACF;YACA,eAAe;YACf,OAAO;QACT;QACA,MAAM,IAAI,WAAW,kCAAkC,CAAA,GAAA,uJAAA,CAAA,SAAM,AAAD,EAAE,QAAQ;IACxE;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4172, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/det.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'det';\nvar dependencies = ['typed', 'matrix', 'subtractScalar', 'multiply', 'divideScalar', 'isZero', 'unaryMinus'];\nexport var createDet = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    subtractScalar,\n    multiply,\n    divideScalar,\n    isZero,\n    unaryMinus\n  } = _ref;\n  /**\n   * Calculate the determinant of a matrix.\n   *\n   * Syntax:\n   *\n   *    math.det(x)\n   *\n   * Examples:\n   *\n   *    math.det([[1, 2], [3, 4]]) // returns -2\n   *\n   *    const A = [\n   *      [-2, 2, 3],\n   *      [-1, 1, 3],\n   *      [2, 0, -1]\n   *    ]\n   *    math.det(A) // returns 6\n   *\n   * See also:\n   *\n   *    inv\n   *\n   * @param {Array | Matrix} x  A matrix\n   * @return {number} The determinant of `x`\n   */\n  return typed(name, {\n    any: function any(x) {\n      return clone(x);\n    },\n    'Array | Matrix': function det(x) {\n      var size;\n      if (isMatrix(x)) {\n        size = x.size();\n      } else if (Array.isArray(x)) {\n        x = matrix(x);\n        size = x.size();\n      } else {\n        // a scalar\n        size = [];\n      }\n      switch (size.length) {\n        case 0:\n          // scalar\n          return clone(x);\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            return clone(x.valueOf()[0]);\n          }\n          if (size[0] === 0) {\n            return 1; // det of an empty matrix is per definition 1\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n        case 2:\n          {\n            // two-dimensional array\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              return _det(x.clone().valueOf(), rows, cols);\n            }\n            if (cols === 0) {\n              return 1; // det of an empty matrix is per definition 1\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n\n  /**\n   * Calculate the determinant of a matrix\n   * @param {Array[]} matrix  A square, two dimensional matrix\n   * @param {number} rows     Number of rows of the matrix (zero-based)\n   * @param {number} cols     Number of columns of the matrix (zero-based)\n   * @returns {number} det\n   * @private\n   */\n  function _det(matrix, rows, cols) {\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      return clone(matrix[0][0]);\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12\n      return subtractScalar(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));\n    } else {\n      // Bareiss algorithm\n      // this algorithm have same complexity as LUP decomposition (O(n^3))\n      // but it preserve precision of floating point more relative to the LUP decomposition\n      var negated = false;\n      var rowIndices = new Array(rows).fill(0).map((_, i) => i); // matrix index of row i\n      for (var k = 0; k < rows; k++) {\n        var k_ = rowIndices[k];\n        if (isZero(matrix[k_][k])) {\n          var _k = void 0;\n          for (_k = k + 1; _k < rows; _k++) {\n            if (!isZero(matrix[rowIndices[_k]][k])) {\n              k_ = rowIndices[_k];\n              rowIndices[_k] = rowIndices[k];\n              rowIndices[k] = k_;\n              negated = !negated;\n              break;\n            }\n          }\n          if (_k === rows) return matrix[k_][k]; // some zero of the type\n        }\n        var piv = matrix[k_][k];\n        var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];\n        for (var i = k + 1; i < rows; i++) {\n          var i_ = rowIndices[i];\n          for (var j = k + 1; j < rows; j++) {\n            matrix[i_][j] = divideScalar(subtractScalar(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);\n          }\n        }\n      }\n      var det = matrix[rowIndices[rows - 1]][rows - 1];\n      return negated ? unaryMinus(det) : det;\n    }\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4325, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/inv.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { format } from '../../utils/string.js';\nvar name = 'inv';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];\nexport var createInv = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divideScalar,\n    addScalar,\n    multiply,\n    unaryMinus,\n    det,\n    identity,\n    abs\n  } = _ref;\n  /**\n   * Calculate the inverse of a square matrix.\n   *\n   * Syntax:\n   *\n   *     math.inv(x)\n   *\n   * Examples:\n   *\n   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]\n   *     math.inv(4)                 // returns 0.25\n   *     1 / 4                       // returns 0.25\n   *\n   * See also:\n   *\n   *     det, transpose\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n  return typed(name, {\n    'Array | Matrix': function Array__Matrix(x) {\n      var size = isMatrix(x) ? x.size() : arraySize(x);\n      switch (size.length) {\n        case 1:\n          // vector\n          if (size[0] === 1) {\n            if (isMatrix(x)) {\n              return matrix([divideScalar(1, x.valueOf()[0])]);\n            } else {\n              return [divideScalar(1, x[0])];\n            }\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n        case 2:\n          // two dimensional array\n          {\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              if (isMatrix(x)) {\n                return matrix(_inv(x.valueOf(), rows, cols), x.storage());\n              } else {\n                // return an Array\n                return _inv(x, rows, cols);\n              }\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers\n    }\n  });\n\n  /**\n   * Calculate the inverse of a square matrix\n   * @param {Array[]} mat     A square matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns, must equal rows\n   * @return {Array[]} inv    Inverse matrix\n   * @private\n   */\n  function _inv(mat, rows, cols) {\n    var r, s, f, value, temp;\n    if (rows === 1) {\n      // this is a 1 x 1 matrix\n      value = mat[0][0];\n      if (value === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n      return [[divideScalar(1, value)]];\n    } else if (rows === 2) {\n      // this is a 2 x 2 matrix\n      var d = det(mat);\n      if (d === 0) {\n        throw Error('Cannot calculate inverse, determinant is zero');\n      }\n      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];\n    } else {\n      // this is a matrix of 3 x 3 or larger\n      // calculate inverse using gauss-jordan elimination\n      //      https://en.wikipedia.org/wiki/Gaussian_elimination\n      //      http://mathworld.wolfram.com/MatrixInverse.html\n      //      http://math.uww.edu/~mcfarlat/inverse.htm\n\n      // make a copy of the matrix (only the arrays, not of the elements)\n      var A = mat.concat();\n      for (r = 0; r < rows; r++) {\n        A[r] = A[r].concat();\n      }\n\n      // create an identity matrix which in the end will contain the\n      // matrix inverse\n      var B = identity(rows).valueOf();\n\n      // loop over all columns, and perform row reductions\n      for (var c = 0; c < cols; c++) {\n        // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]\n        var ABig = abs(A[c][c]);\n        var rBig = c;\n        r = c + 1;\n        while (r < rows) {\n          if (abs(A[r][c]) > ABig) {\n            ABig = abs(A[r][c]);\n            rBig = r;\n          }\n          r++;\n        }\n        if (ABig === 0) {\n          throw Error('Cannot calculate inverse, determinant is zero');\n        }\n        r = rBig;\n        if (r !== c) {\n          temp = A[c];\n          A[c] = A[r];\n          A[r] = temp;\n          temp = B[c];\n          B[c] = B[r];\n          B[r] = temp;\n        }\n\n        // eliminate non-zero values on the other rows at column c\n        var Ac = A[c];\n        var Bc = B[c];\n        for (r = 0; r < rows; r++) {\n          var Ar = A[r];\n          var Br = B[r];\n          if (r !== c) {\n            // eliminate value at column c and row r\n            if (Ar[c] !== 0) {\n              f = divideScalar(unaryMinus(Ar[c]), Ac[c]);\n\n              // add (f * row c) to row r to eliminate the value\n              // at column c\n              for (s = c; s < cols; s++) {\n                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));\n              }\n              for (s = 0; s < cols; s++) {\n                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));\n              }\n            }\n          } else {\n            // normalize value at Acc to 1,\n            // divide each value on row r with the value at Acc\n            f = Ac[c];\n            for (s = c; s < cols; s++) {\n              Ar[s] = divideScalar(Ar[s], f);\n            }\n            for (s = 0; s < cols; s++) {\n              Br[s] = divideScalar(Br[s], f);\n            }\n          }\n        }\n      }\n      return B;\n    }\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4532, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/pinv.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { format } from '../../utils/string.js';\nimport { clone } from '../../utils/object.js';\nvar name = 'pinv';\nvar dependencies = ['typed', 'matrix', 'inv', 'deepEqual', 'equal', 'dotDivide', 'dot', 'ctranspose', 'divideScalar', 'multiply', 'add', 'Complex'];\nexport var createPinv = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    inv,\n    deepEqual,\n    equal,\n    dotDivide,\n    dot,\n    ctranspose,\n    divideScalar,\n    multiply,\n    add,\n    Complex\n  } = _ref;\n  /**\n   * Calculate the Moore–Penrose inverse of a matrix.\n   *\n   * Syntax:\n   *\n   *     math.pinv(x)\n   *\n   * Examples:\n   *\n   *     math.pinv([[1, 2], [3, 4]])          // returns [[-2, 1], [1.5, -0.5]]\n   *     math.pinv([[1, 0], [0, 1], [0, 1]])  // returns [[1, 0, 0], [0, 0.5, 0.5]]\n   *     math.pinv(4)                         // returns 0.25\n   *\n   * See also:\n   *\n   *     inv\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n  return typed(name, {\n    'Array | Matrix': function Array__Matrix(x) {\n      var size = isMatrix(x) ? x.size() : arraySize(x);\n      switch (size.length) {\n        case 1:\n          // vector\n          if (_isZeros(x)) return ctranspose(x); // null vector\n          if (size[0] === 1) {\n            return inv(x); // invertible matrix\n          } else {\n            return dotDivide(ctranspose(x), dot(x, x));\n          }\n        case 2:\n          // two dimensional array\n          {\n            if (_isZeros(x)) return ctranspose(x); // zero matrixx\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              try {\n                return inv(x); // invertible matrix\n              } catch (err) {\n                if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {\n                  // Expected\n                } else {\n                  throw err;\n                }\n              }\n            }\n            if (isMatrix(x)) {\n              return matrix(_pinv(x.valueOf(), rows, cols), x.storage());\n            } else {\n              // return an Array\n              return _pinv(x, rows, cols);\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      if (equal(x, 0)) return clone(x); // zero\n      return divideScalar(1, x);\n    }\n  });\n\n  /**\n   * Calculate the Moore–Penrose inverse of a matrix\n   * @param {Array[]} mat     A matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns\n   * @return {Array[]} pinv    Pseudoinverse matrix\n   * @private\n   */\n  function _pinv(mat, rows, cols) {\n    var {\n      C,\n      F\n    } = _rankFact(mat, rows, cols); // TODO: Use SVD instead (may improve precision)\n    var Cpinv = multiply(inv(multiply(ctranspose(C), C)), ctranspose(C));\n    var Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))));\n    return multiply(Fpinv, Cpinv);\n  }\n\n  /**\n   * Calculate the reduced row echelon form of a matrix\n   *\n   * Modified from https://rosettacode.org/wiki/Reduced_row_echelon_form\n   *\n   * @param {Array[]} mat     A matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns\n   * @return {Array[]}        Reduced row echelon form\n   * @private\n   */\n  function _rref(mat, rows, cols) {\n    var M = clone(mat);\n    var lead = 0;\n    for (var r = 0; r < rows; r++) {\n      if (cols <= lead) {\n        return M;\n      }\n      var i = r;\n      while (_isZero(M[i][lead])) {\n        i++;\n        if (rows === i) {\n          i = r;\n          lead++;\n          if (cols === lead) {\n            return M;\n          }\n        }\n      }\n      [M[i], M[r]] = [M[r], M[i]];\n      var val = M[r][lead];\n      for (var j = 0; j < cols; j++) {\n        M[r][j] = dotDivide(M[r][j], val);\n      }\n      for (var _i = 0; _i < rows; _i++) {\n        if (_i === r) continue;\n        val = M[_i][lead];\n        for (var _j = 0; _j < cols; _j++) {\n          M[_i][_j] = add(M[_i][_j], multiply(-1, multiply(val, M[r][_j])));\n        }\n      }\n      lead++;\n    }\n    return M;\n  }\n\n  /**\n   * Calculate the rank factorization of a matrix\n   *\n   * @param {Array[]} mat                  A matrix (M)\n   * @param {number} rows                  Number of rows\n   * @param {number} cols                  Number of columns\n   * @return {{C: Array, F: Array}}        rank factorization where M = C F\n   * @private\n   */\n  function _rankFact(mat, rows, cols) {\n    var rref = _rref(mat, rows, cols);\n    var C = mat.map((_, i) => _.filter((_, j) => j < rows && !_isZero(dot(rref[j], rref[j]))));\n    var F = rref.filter((_, i) => !_isZero(dot(rref[i], rref[i])));\n    return {\n      C,\n      F\n    };\n  }\n  function _isZero(x) {\n    return equal(add(x, Complex(1, 1)), add(0, Complex(1, 1)));\n  }\n  function _isZeros(arr) {\n    return deepEqual(add(arr, Complex(1, 1)), add(multiply(arr, 0), Complex(1, 1)));\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4719, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js"],"sourcesContent":["import { clone } from '../../../utils/object.js';\nexport function createComplexEigs(_ref) {\n  var {\n    addScalar,\n    subtract,\n    flatten,\n    multiply,\n    multiplyScalar,\n    divideScalar,\n    sqrt,\n    abs,\n    bignumber,\n    diag,\n    size,\n    reshape,\n    inv,\n    qr,\n    usolve,\n    usolveAll,\n    equal,\n    complex,\n    larger,\n    smaller,\n    matrixFromColumns,\n    dot\n  } = _ref;\n  /**\n   * @param {number[][]} arr the matrix to find eigenvalues of\n   * @param {number} N size of the matrix\n   * @param {number|BigNumber} prec precision, anything lower will be considered zero\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors should we find eigenvectors?\n   *\n   * @returns {{ values: number[], vectors: number[][] }}\n   */\n  function complexEigs(arr, N, prec, type) {\n    var findVectors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    // TODO check if any row/col are zero except the diagonal\n\n    // make sure corresponding rows and columns have similar magnitude\n    // important because of numerical stability\n    // MODIFIES arr by side effect!\n    var R = balance(arr, N, prec, type, findVectors);\n\n    // R is the row transformation matrix\n    // arr = A' = R A R^-1, A is the original matrix\n    // (if findVectors is false, R is undefined)\n    // (And so to return to original matrix: A = R^-1 arr R)\n\n    // TODO if magnitudes of elements vary over many orders,\n    // move greatest elements to the top left corner\n\n    // using similarity transformations, reduce the matrix\n    // to Hessenberg form (upper triangular plus one subdiagonal row)\n    // updates the transformation matrix R with new row operationsq\n    // MODIFIES arr by side effect!\n    reduceToHessenberg(arr, N, prec, type, findVectors, R);\n    // still true that original A = R^-1 arr R)\n\n    // find eigenvalues\n    var {\n      values,\n      C\n    } = iterateUntilTriangular(arr, N, prec, type, findVectors);\n\n    // values is the list of eigenvalues, C is the column\n    // transformation matrix that transforms arr, the hessenberg\n    // matrix, to upper triangular\n    // (So U = C^-1 arr C and the relationship between current arr\n    // and original A is unchanged.)\n\n    if (findVectors) {\n      var eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type);\n      return {\n        values,\n        eigenvectors\n      };\n    }\n    return {\n      values\n    };\n  }\n\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]}\n   */\n  function balance(arr, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var realzero = big ? bignumber(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    var realone = big ? bignumber(1) : 1;\n\n    // base of the floating-point arithmetic\n    var radix = big ? bignumber(10) : 2;\n    var radixSq = multiplyScalar(radix, radix);\n\n    // the diagonal transformation matrix R\n    var Rdiag;\n    if (findVectors) {\n      Rdiag = Array(N).fill(one);\n    }\n\n    // this isn't the only time we loop thru the matrix...\n    var last = false;\n    while (!last) {\n      // ...haha I'm joking! unless...\n      last = true;\n      for (var i = 0; i < N; i++) {\n        // compute the taxicab norm of i-th column and row\n        // TODO optimize for complex numbers\n        var colNorm = realzero;\n        var rowNorm = realzero;\n        for (var j = 0; j < N; j++) {\n          if (i === j) continue;\n          colNorm = addScalar(colNorm, abs(arr[j][i]));\n          rowNorm = addScalar(rowNorm, abs(arr[i][j]));\n        }\n        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {\n          // find integer power closest to balancing the matrix\n          // (we want to scale only by integer powers of radix,\n          // so that we don't lose any precision due to round-off)\n\n          var f = realone;\n          var c = colNorm;\n          var rowDivRadix = divideScalar(rowNorm, radix);\n          var rowMulRadix = multiplyScalar(rowNorm, radix);\n          while (smaller(c, rowDivRadix)) {\n            c = multiplyScalar(c, radixSq);\n            f = multiplyScalar(f, radix);\n          }\n          while (larger(c, rowMulRadix)) {\n            c = divideScalar(c, radixSq);\n            f = divideScalar(f, radix);\n          }\n\n          // check whether balancing is needed\n          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)\n          var condition = smaller(divideScalar(addScalar(c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));\n\n          // apply balancing similarity transformation\n          if (condition) {\n            // we should loop once again to check whether\n            // another rebalancing is needed\n            last = false;\n            var g = divideScalar(1, f);\n            for (var _j = 0; _j < N; _j++) {\n              if (i === _j) {\n                continue;\n              }\n              arr[i][_j] = multiplyScalar(arr[i][_j], g);\n              arr[_j][i] = multiplyScalar(arr[_j][i], f);\n            }\n\n            // keep track of transformations\n            if (findVectors) {\n              Rdiag[i] = multiplyScalar(Rdiag[i], g);\n            }\n          }\n        }\n      }\n    }\n\n    // return the diagonal row transformation matrix\n    return findVectors ? diag(Rdiag) : null;\n  }\n\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors\n   * @param {number[][]} R the row transformation matrix that will be modified\n   */\n  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    if (big) {\n      prec = bignumber(prec);\n    }\n    for (var i = 0; i < N - 2; i++) {\n      // Find the largest subdiag element in the i-th col\n\n      var maxIndex = 0;\n      var max = zero;\n      for (var j = i + 1; j < N; j++) {\n        var el = arr[j][i];\n        if (smaller(abs(max), abs(el))) {\n          max = el;\n          maxIndex = j;\n        }\n      }\n\n      // This col is pivoted, no need to do anything\n      if (smaller(abs(max), prec)) {\n        continue;\n      }\n      if (maxIndex !== i + 1) {\n        // Interchange maxIndex-th and (i+1)-th row\n        var tmp1 = arr[maxIndex];\n        arr[maxIndex] = arr[i + 1];\n        arr[i + 1] = tmp1;\n\n        // Interchange maxIndex-th and (i+1)-th column\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          var tmp2 = arr[_j2][maxIndex];\n          arr[_j2][maxIndex] = arr[_j2][i + 1];\n          arr[_j2][i + 1] = tmp2;\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          var tmp3 = R[maxIndex];\n          R[maxIndex] = R[i + 1];\n          R[i + 1] = tmp3;\n        }\n      }\n\n      // Reduce following rows and columns\n      for (var _j3 = i + 2; _j3 < N; _j3++) {\n        var n = divideScalar(arr[_j3][i], max);\n        if (n === 0) {\n          continue;\n        }\n\n        // from j-th row subtract n-times (i+1)th row\n        for (var k = 0; k < N; k++) {\n          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));\n        }\n\n        // to (i+1)th column add n-times j-th column\n        for (var _k = 0; _k < N; _k++) {\n          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          for (var _k2 = 0; _k2 < N; _k2++) {\n            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));\n          }\n        }\n      }\n    }\n    return R;\n  }\n\n  /**\n   * @returns {{values: values, C: Matrix}}\n   * @see Press, Wiliams: Numerical recipes in Fortran 77\n   * @see https://en.wikipedia.org/wiki/QR_algorithm\n   */\n  function iterateUntilTriangular(A, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    if (big) {\n      prec = bignumber(prec);\n    }\n\n    // The Francis Algorithm\n    // The core idea of this algorithm is that doing successive\n    // A' = QtAQ transformations will eventually converge to block-\n    // upper-triangular with diagonal blocks either 1x1 or 2x2.\n    // The Q here is the one from the QR decomposition, A = QR.\n    // Since the eigenvalues of a block-upper-triangular matrix are\n    // the eigenvalues of its diagonal blocks and we know how to find\n    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.\n\n    var arr = clone(A);\n\n    // the list of converged eigenvalues\n    var lambdas = [];\n\n    // size of arr, which will get smaller as eigenvalues converge\n    var n = N;\n\n    // the diagonal of the block-diagonal matrix that turns\n    // converged 2x2 matrices into upper triangular matrices\n    var Sdiag = [];\n\n    // N×N matrix describing the overall transformation done during the QR algorithm\n    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined;\n\n    // nxn matrix describing the QR transformations done since last convergence\n    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined;\n\n    // last eigenvalue converged before this many steps\n    var lastConvergenceBefore = 0;\n    while (lastConvergenceBefore <= 100) {\n      lastConvergenceBefore += 1;\n\n      // TODO if the convergence is slow, do something clever\n\n      // Perform the factorization\n\n      var k = arr[n - 1][n - 1]; // TODO this is apparently a somewhat\n      // old-fashioned choice; ideally set close to an eigenvalue, or\n      // perhaps better yet switch to the implicit QR version that is sometimes\n      // specifically called the \"Francis algorithm\" that is alluded to\n      // in the following TODO. (Or perhaps we switch to an independently\n      // optimized third-party package for the linear algebra operations...)\n\n      for (var i = 0; i < n; i++) {\n        arr[i][i] = subtract(arr[i][i], k);\n      }\n\n      // TODO do an implicit QR transformation\n      var {\n        Q,\n        R\n      } = qr(arr);\n      arr = multiply(R, Q);\n      for (var _i = 0; _i < n; _i++) {\n        arr[_i][_i] = addScalar(arr[_i][_i], k);\n      }\n\n      // keep track of transformations\n      if (findVectors) {\n        Qpartial = multiply(Qpartial, Q);\n      }\n\n      // The rightmost diagonal element converged to an eigenvalue\n      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {\n        lastConvergenceBefore = 0;\n        lambdas.push(arr[n - 1][n - 1]);\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift([[1]]);\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 1) {\n            Qpartial = diag(Array(n - 1).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 1;\n        arr.pop();\n        for (var _i2 = 0; _i2 < n; _i2++) {\n          arr[_i2].pop();\n        }\n\n        // The rightmost diagonal 2x2 block converged\n      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {\n        lastConvergenceBefore = 0;\n        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);\n        lambdas.push(...ll);\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 2) {\n            Qpartial = diag(Array(n - 2).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 2;\n        arr.pop();\n        arr.pop();\n        for (var _i3 = 0; _i3 < n; _i3++) {\n          arr[_i3].pop();\n          arr[_i3].pop();\n        }\n      }\n      if (n === 0) {\n        break;\n      }\n    }\n\n    // standard sorting\n    lambdas.sort((a, b) => +subtract(abs(a), abs(b)));\n\n    // the algorithm didn't converge\n    if (lastConvergenceBefore > 100) {\n      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));\n      err.values = lambdas;\n      err.vectors = [];\n      throw err;\n    }\n\n    // combine the overall QR transformation Qtotal with the subsequent\n    // transformation S that turns the diagonal 2x2 blocks to upper triangular\n    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;\n    return {\n      values: lambdas,\n      C\n    };\n  }\n\n  /**\n   * @param {Matrix} A hessenberg-form matrix\n   * @param {number} N size of A\n   * @param {Matrix} C column transformation matrix that turns A into upper triangular\n   * @param {Matrix} R similarity that turns original matrix into A\n   * @param {number[]} values array of eigenvalues of A\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]} eigenvalues\n   */\n  function findEigenvectors(A, N, C, R, values, prec, type) {\n    var Cinv = inv(C);\n    var U = multiply(Cinv, A, C);\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // turn values into a kind of \"multiset\"\n    // this way it is easier to find eigenvectors\n    var uniqueValues = [];\n    var multiplicities = [];\n    for (var lambda of values) {\n      var i = indexOf(uniqueValues, lambda, equal);\n      if (i === -1) {\n        uniqueValues.push(lambda);\n        multiplicities.push(1);\n      } else {\n        multiplicities[i] += 1;\n      }\n    }\n\n    // find eigenvectors by solving U − lambdaE = 0\n    // TODO replace with an iterative eigenvector algorithm\n    // (this one might fail for imprecise eigenvalues)\n\n    var vectors = [];\n    var len = uniqueValues.length;\n    var b = Array(N).fill(zero);\n    var E = diag(Array(N).fill(one));\n    var _loop = function _loop() {\n      var lambda = uniqueValues[_i4];\n      var S = subtract(U, multiply(lambda, E)); // the characteristic matrix\n\n      var solutions = usolveAll(S, b);\n      solutions.shift(); // ignore the null vector\n\n      // looks like we missed something, try inverse iteration\n      // But if that fails, just presume that the original matrix truly\n      // was defective.\n      while (solutions.length < multiplicities[_i4]) {\n        var approxVec = inverseIterate(S, N, solutions, prec, type);\n        if (approxVec === null) {\n          break;\n        } // no more vectors were found\n        solutions.push(approxVec);\n      }\n\n      // Transform back into original array coordinates\n      var correction = multiply(inv(R), C);\n      solutions = solutions.map(v => multiply(correction, v));\n      vectors.push(...solutions.map(v => ({\n        value: lambda,\n        vector: flatten(v)\n      })));\n    };\n    for (var _i4 = 0; _i4 < len; _i4++) {\n      _loop();\n    }\n    return vectors;\n  }\n\n  /**\n   * Compute the eigenvalues of an 2x2 matrix\n   * @return {[number,number]}\n   */\n  function eigenvalues2x2(a, b, c, d) {\n    // lambda_+- = 1/2 trA +- 1/2 sqrt( tr^2 A - 4 detA )\n    var trA = addScalar(a, d);\n    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));\n    var x = multiplyScalar(trA, 0.5);\n    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);\n    return [addScalar(x, y), subtract(x, y)];\n  }\n\n  /**\n   * For an 2x2 matrix compute the transformation matrix S,\n   * so that SAS^-1 is an upper triangular matrix\n   * @return {[[number,number],[number,number]]}\n   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf\n   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n   */\n  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // matrix is already upper triangular\n    // return an identity matrix\n    if (smaller(abs(c), prec)) {\n      return [[one, zero], [zero, one]];\n    }\n\n    // matrix is diagonalizable\n    // return its eigenvectors as columns\n    if (larger(abs(subtract(l1, l2)), prec)) {\n      return [[subtract(l1, d), subtract(l2, d)], [c, c]];\n    }\n\n    // matrix is not diagonalizable\n    // compute diagonal elements of N = A - lambdaI\n    var na = subtract(a, l1);\n    var nd = subtract(d, l1);\n\n    // col(N,2) = 0  implies  S = ( col(N,1), e_1 )\n    // col(N,2) != 0 implies  S = ( col(N,2), e_2 )\n\n    if (smaller(abs(b), prec) && smaller(abs(nd), prec)) {\n      return [[na, one], [c, zero]];\n    } else {\n      return [[b, zero], [nd, one]];\n    }\n  }\n\n  /**\n   * Enlarge the matrix from nxn to NxN, setting the new\n   * elements to 1 on diagonal and 0 elsewhere\n   */\n  function inflateMatrix(arr, N) {\n    // add columns\n    for (var i = 0; i < arr.length; i++) {\n      arr[i].push(...Array(N - arr[i].length).fill(0));\n    }\n\n    // add rows\n    for (var _i5 = arr.length; _i5 < N; _i5++) {\n      arr.push(Array(N).fill(0));\n      arr[_i5][_i5] = 1;\n    }\n    return arr;\n  }\n\n  /**\n   * Create a block-diagonal matrix with the given square matrices on the diagonal\n   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal\n   * @param {number} N the size of the resulting matrix\n   */\n  function blockDiag(arr, N) {\n    var M = [];\n    for (var i = 0; i < N; i++) {\n      M[i] = Array(N).fill(0);\n    }\n    var I = 0;\n    for (var sub of arr) {\n      var n = sub.length;\n      for (var _i6 = 0; _i6 < n; _i6++) {\n        for (var j = 0; j < n; j++) {\n          M[I + _i6][I + j] = sub[_i6][j];\n        }\n      }\n      I += n;\n    }\n    return M;\n  }\n\n  /**\n   * Finds the index of an element in an array using a custom equality function\n   * @template T\n   * @param {Array<T>} arr array in which to search\n   * @param {T} el the element to find\n   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`\n   * @returns {number} the index of `el`, or -1 when it's not in `arr`\n   */\n  function indexOf(arr, el, fn) {\n    for (var i = 0; i < arr.length; i++) {\n      if (fn(arr[i], el)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Provided a near-singular upper-triangular matrix A and a list of vectors,\n   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal\n   * to each vector in the list\n   * @template T\n   * @param {T[][]} A near-singular square matrix\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {number} prec epsilon\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @return {T[] | null} eigenvector\n   *\n   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration\n   */\n  function inverseIterate(A, N, orthog, prec, type) {\n    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;\n    var b; // the vector\n\n    // you better choose a random vector before I count to five\n    var i = 0;\n    for (; i < 5; ++i) {\n      b = randomOrthogonalVector(N, orthog, type);\n      try {\n        b = usolve(A, b);\n      } catch (_unused) {\n        // That direction didn't work, likely because the original matrix\n        // was defective. But still make the full number of tries...\n        continue;\n      }\n      if (larger(norm(b), largeNum)) {\n        break;\n      }\n    }\n    if (i >= 5) {\n      return null; // couldn't find any orthogonal vector in the image\n    }\n\n    // you better converge before I count to ten\n    i = 0;\n    while (true) {\n      var c = usolve(A, b);\n      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {\n        break;\n      }\n      if (++i >= 10) {\n        return null;\n      }\n      b = normalize(c);\n    }\n    return b;\n  }\n\n  /**\n   * Generates a random unit vector of dimension N, orthogonal to each vector in the list\n   * @template T\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} random vector\n   */\n  function randomOrthogonalVector(N, orthog, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n\n    // generate random vector with the correct type\n    var v = Array(N).fill(0).map(_ => 2 * Math.random() - 1);\n    if (big) {\n      v = v.map(n => bignumber(n));\n    }\n    if (cplx) {\n      v = v.map(n => complex(n));\n    }\n\n    // project to orthogonal complement\n    v = orthogonalComplement(v, orthog);\n\n    // normalize\n    return normalize(v, type);\n  }\n\n  /**\n   * Project vector v to the orthogonal complement of an array of vectors\n   */\n  function orthogonalComplement(v, orthog) {\n    var vectorShape = size(v);\n    for (var w of orthog) {\n      w = reshape(w, vectorShape); // make sure this is just a vector computation\n      // v := v − (w, v)/|w|^2 w\n      v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));\n    }\n    return v;\n  }\n\n  /**\n   * Calculate the norm of a vector.\n   * We can't use math.norm because factory can't handle circular dependency.\n   * Seriously, I'm really fed up with factory.\n   */\n  function norm(v) {\n    return abs(sqrt(dot(v, v)));\n  }\n\n  /**\n   * Normalize a vector\n   * @template T\n   * @param {T[]} v\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} normalized vec\n   */\n  function normalize(v, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    return multiply(divideScalar(one, norm(v)), v);\n  }\n  return complexEigs;\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5349, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/eigs/realSymmetric.js"],"sourcesContent":["import { clone } from '../../../utils/object.js';\nexport function createRealSymmetric(_ref) {\n  var {\n    config,\n    addScalar,\n    subtract,\n    abs,\n    atan,\n    cos,\n    sin,\n    multiplyScalar,\n    inv,\n    bignumber,\n    multiply,\n    add\n  } = _ref;\n  /**\n   * @param {number[] | BigNumber[]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number' | 'BigNumber'} type\n   */\n  function main(arr, N) {\n    var prec = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : config.relTol;\n    var type = arguments.length > 3 ? arguments[3] : undefined;\n    var computeVectors = arguments.length > 4 ? arguments[4] : undefined;\n    if (type === 'number') {\n      return diag(arr, prec, computeVectors);\n    }\n    if (type === 'BigNumber') {\n      return diagBig(arr, prec, computeVectors);\n    }\n    throw TypeError('Unsupported data type: ' + type);\n  }\n\n  // diagonalization implementation for number (efficient)\n  function diag(x, precision, computeVectors) {\n    var N = x.length;\n    var e0 = Math.abs(precision / N);\n    var psi;\n    var Sij;\n    if (computeVectors) {\n      Sij = new Array(N);\n      // Sij is Identity Matrix\n      for (var i = 0; i < N; i++) {\n        Sij[i] = Array(N).fill(0);\n        Sij[i][i] = 1.0;\n      }\n    }\n    // initial error\n    var Vab = getAij(x);\n    while (Math.abs(Vab[1]) >= Math.abs(e0)) {\n      var _i = Vab[0][0];\n      var j = Vab[0][1];\n      psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);\n      x = x1(x, psi, _i, j);\n      if (computeVectors) Sij = Sij1(Sij, psi, _i, j);\n      Vab = getAij(x);\n    }\n    var Ei = Array(N).fill(0); // eigenvalues\n    for (var _i2 = 0; _i2 < N; _i2++) {\n      Ei[_i2] = x[_i2][_i2];\n    }\n    return sorting(clone(Ei), Sij, computeVectors);\n  }\n\n  // diagonalization implementation for bigNumber\n  function diagBig(x, precision, computeVectors) {\n    var N = x.length;\n    var e0 = abs(precision / N);\n    var psi;\n    var Sij;\n    if (computeVectors) {\n      Sij = new Array(N);\n      // Sij is Identity Matrix\n      for (var i = 0; i < N; i++) {\n        Sij[i] = Array(N).fill(0);\n        Sij[i][i] = 1.0;\n      }\n    }\n    // initial error\n    var Vab = getAijBig(x);\n    while (abs(Vab[1]) >= abs(e0)) {\n      var _i3 = Vab[0][0];\n      var j = Vab[0][1];\n      psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);\n      x = x1Big(x, psi, _i3, j);\n      if (computeVectors) Sij = Sij1Big(Sij, psi, _i3, j);\n      Vab = getAijBig(x);\n    }\n    var Ei = Array(N).fill(0); // eigenvalues\n    for (var _i4 = 0; _i4 < N; _i4++) {\n      Ei[_i4] = x[_i4][_i4];\n    }\n    // return [clone(Ei), clone(Sij)]\n    return sorting(clone(Ei), Sij, computeVectors);\n  }\n\n  // get angle\n  function getTheta(aii, ajj, aij) {\n    var denom = ajj - aii;\n    if (Math.abs(denom) <= config.relTol) {\n      return Math.PI / 4.0;\n    } else {\n      return 0.5 * Math.atan(2.0 * aij / (ajj - aii));\n    }\n  }\n\n  // get angle\n  function getThetaBig(aii, ajj, aij) {\n    var denom = subtract(ajj, aii);\n    if (abs(denom) <= config.relTol) {\n      return bignumber(-1).acos().div(4);\n    } else {\n      return multiplyScalar(0.5, atan(multiply(2.0, aij, inv(denom))));\n    }\n  }\n\n  // update eigvec\n  function Sij1(Sij, theta, i, j) {\n    var N = Sij.length;\n    var c = Math.cos(theta);\n    var s = Math.sin(theta);\n    var Ski = Array(N).fill(0);\n    var Skj = Array(N).fill(0);\n    for (var k = 0; k < N; k++) {\n      Ski[k] = c * Sij[k][i] - s * Sij[k][j];\n      Skj[k] = s * Sij[k][i] + c * Sij[k][j];\n    }\n    for (var _k = 0; _k < N; _k++) {\n      Sij[_k][i] = Ski[_k];\n      Sij[_k][j] = Skj[_k];\n    }\n    return Sij;\n  }\n  // update eigvec for overlap\n  function Sij1Big(Sij, theta, i, j) {\n    var N = Sij.length;\n    var c = cos(theta);\n    var s = sin(theta);\n    var Ski = Array(N).fill(bignumber(0));\n    var Skj = Array(N).fill(bignumber(0));\n    for (var k = 0; k < N; k++) {\n      Ski[k] = subtract(multiplyScalar(c, Sij[k][i]), multiplyScalar(s, Sij[k][j]));\n      Skj[k] = addScalar(multiplyScalar(s, Sij[k][i]), multiplyScalar(c, Sij[k][j]));\n    }\n    for (var _k2 = 0; _k2 < N; _k2++) {\n      Sij[_k2][i] = Ski[_k2];\n      Sij[_k2][j] = Skj[_k2];\n    }\n    return Sij;\n  }\n\n  // update matrix\n  function x1Big(Hij, theta, i, j) {\n    var N = Hij.length;\n    var c = bignumber(cos(theta));\n    var s = bignumber(sin(theta));\n    var c2 = multiplyScalar(c, c);\n    var s2 = multiplyScalar(s, s);\n    var Aki = Array(N).fill(bignumber(0));\n    var Akj = Array(N).fill(bignumber(0));\n    // 2cs Hij\n    var csHij = multiply(bignumber(2), c, s, Hij[i][j]);\n    //  Aii\n    var Aii = addScalar(subtract(multiplyScalar(c2, Hij[i][i]), csHij), multiplyScalar(s2, Hij[j][j]));\n    var Ajj = add(multiplyScalar(s2, Hij[i][i]), csHij, multiplyScalar(c2, Hij[j][j]));\n    // 0  to i\n    for (var k = 0; k < N; k++) {\n      Aki[k] = subtract(multiplyScalar(c, Hij[i][k]), multiplyScalar(s, Hij[j][k]));\n      Akj[k] = addScalar(multiplyScalar(s, Hij[i][k]), multiplyScalar(c, Hij[j][k]));\n    }\n    // Modify Hij\n    Hij[i][i] = Aii;\n    Hij[j][j] = Ajj;\n    Hij[i][j] = bignumber(0);\n    Hij[j][i] = bignumber(0);\n    // 0  to i\n    for (var _k3 = 0; _k3 < N; _k3++) {\n      if (_k3 !== i && _k3 !== j) {\n        Hij[i][_k3] = Aki[_k3];\n        Hij[_k3][i] = Aki[_k3];\n        Hij[j][_k3] = Akj[_k3];\n        Hij[_k3][j] = Akj[_k3];\n      }\n    }\n    return Hij;\n  }\n\n  // update matrix\n  function x1(Hij, theta, i, j) {\n    var N = Hij.length;\n    var c = Math.cos(theta);\n    var s = Math.sin(theta);\n    var c2 = c * c;\n    var s2 = s * s;\n    var Aki = Array(N).fill(0);\n    var Akj = Array(N).fill(0);\n    //  Aii\n    var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];\n    var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j];\n    // 0  to i\n    for (var k = 0; k < N; k++) {\n      Aki[k] = c * Hij[i][k] - s * Hij[j][k];\n      Akj[k] = s * Hij[i][k] + c * Hij[j][k];\n    }\n    // Modify Hij\n    Hij[i][i] = Aii;\n    Hij[j][j] = Ajj;\n    Hij[i][j] = 0;\n    Hij[j][i] = 0;\n    // 0  to i\n    for (var _k4 = 0; _k4 < N; _k4++) {\n      if (_k4 !== i && _k4 !== j) {\n        Hij[i][_k4] = Aki[_k4];\n        Hij[_k4][i] = Aki[_k4];\n        Hij[j][_k4] = Akj[_k4];\n        Hij[_k4][j] = Akj[_k4];\n      }\n    }\n    return Hij;\n  }\n\n  // get max off-diagonal value from Upper Diagonal\n  function getAij(Mij) {\n    var N = Mij.length;\n    var maxMij = 0;\n    var maxIJ = [0, 1];\n    for (var i = 0; i < N; i++) {\n      for (var j = i + 1; j < N; j++) {\n        if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {\n          maxMij = Math.abs(Mij[i][j]);\n          maxIJ = [i, j];\n        }\n      }\n    }\n    return [maxIJ, maxMij];\n  }\n\n  // get max off-diagonal value from Upper Diagonal\n  function getAijBig(Mij) {\n    var N = Mij.length;\n    var maxMij = 0;\n    var maxIJ = [0, 1];\n    for (var i = 0; i < N; i++) {\n      for (var j = i + 1; j < N; j++) {\n        if (abs(maxMij) < abs(Mij[i][j])) {\n          maxMij = abs(Mij[i][j]);\n          maxIJ = [i, j];\n        }\n      }\n    }\n    return [maxIJ, maxMij];\n  }\n\n  // sort results\n  function sorting(E, S, computeVectors) {\n    var N = E.length;\n    var values = Array(N);\n    var vecs;\n    if (computeVectors) {\n      vecs = Array(N);\n      for (var k = 0; k < N; k++) {\n        vecs[k] = Array(N);\n      }\n    }\n    for (var i = 0; i < N; i++) {\n      var minID = 0;\n      var minE = E[0];\n      for (var j = 0; j < E.length; j++) {\n        if (abs(E[j]) < abs(minE)) {\n          minID = j;\n          minE = E[minID];\n        }\n      }\n      values[i] = E.splice(minID, 1)[0];\n      if (computeVectors) {\n        for (var _k5 = 0; _k5 < N; _k5++) {\n          vecs[i][_k5] = S[_k5][minID];\n          S[_k5].splice(minID, 1);\n        }\n      }\n    }\n    if (!computeVectors) return {\n      values\n    };\n    var eigenvectors = vecs.map((vector, i) => ({\n      value: values[i],\n      vector\n    }));\n    return {\n      values,\n      eigenvectors\n    };\n  }\n  return main;\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5650, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/eigs.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport { factory } from '../../utils/factory.js';\nimport { format } from '../../utils/string.js';\nimport { createComplexEigs } from './eigs/complexEigs.js';\nimport { createRealSymmetric } from './eigs/realSymmetric.js';\nimport { typeOf, isNumber, isBigNumber, isComplex, isFraction } from '../../utils/is.js';\nvar name = 'eigs';\n\n// The absolute state of math.js's dependency system:\nvar dependencies = ['config', 'typed', 'matrix', 'addScalar', 'equal', 'subtract', 'abs', 'atan', 'cos', 'sin', 'multiplyScalar', 'divideScalar', 'inv', 'bignumber', 'multiply', 'add', 'larger', 'column', 'flatten', 'number', 'complex', 'sqrt', 'diag', 'size', 'reshape', 'qr', 'usolve', 'usolveAll', 'im', 're', 'smaller', 'matrixFromColumns', 'dot'];\nexport var createEigs = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    matrix,\n    addScalar,\n    subtract,\n    equal,\n    abs,\n    atan,\n    cos,\n    sin,\n    multiplyScalar,\n    divideScalar,\n    inv,\n    bignumber,\n    multiply,\n    add,\n    larger,\n    column,\n    flatten,\n    number,\n    complex,\n    sqrt,\n    diag,\n    size,\n    reshape,\n    qr,\n    usolve,\n    usolveAll,\n    im,\n    re,\n    smaller,\n    matrixFromColumns,\n    dot\n  } = _ref;\n  var doRealSymmetric = createRealSymmetric({\n    config,\n    addScalar,\n    subtract,\n    column,\n    flatten,\n    equal,\n    abs,\n    atan,\n    cos,\n    sin,\n    multiplyScalar,\n    inv,\n    bignumber,\n    complex,\n    multiply,\n    add\n  });\n  var doComplexEigs = createComplexEigs({\n    config,\n    addScalar,\n    subtract,\n    multiply,\n    multiplyScalar,\n    flatten,\n    divideScalar,\n    sqrt,\n    abs,\n    bignumber,\n    diag,\n    size,\n    reshape,\n    qr,\n    inv,\n    usolve,\n    usolveAll,\n    equal,\n    complex,\n    larger,\n    smaller,\n    matrixFromColumns,\n    dot\n  });\n\n  /**\n   * Compute eigenvalues and optionally eigenvectors of a square matrix.\n   * The eigenvalues are sorted by their absolute value, ascending, and\n   * returned as a vector in the `values` property of the returned project.\n   * An eigenvalue with algebraic multiplicity k will be listed k times, so\n   * that the returned `values` vector always has length equal to the size\n   * of the input matrix.\n   *\n   * The `eigenvectors` property of the return value provides the eigenvectors.\n   * It is an array of plain objects: the `value` property of each gives the\n   * associated eigenvalue, and the `vector` property gives the eigenvector\n   * itself. Note that the same `value` property will occur as many times in\n   * the list provided by `eigenvectors` as the geometric multiplicity of\n   * that value.\n   *\n   * If the algorithm fails to converge, it will throw an error –\n   * in that case, however, you may still find useful information\n   * in `err.values` and `err.vectors`.\n   *\n   * Note that the 'precision' option does not directly specify the _accuracy_\n   * of the returned eigenvalues. Rather, it determines how small an entry\n   * of the iterative approximations to an upper triangular matrix must be\n   * in order to be considered zero. The actual accuracy of the returned\n   * eigenvalues may be greater or less than the precision, depending on the\n   * conditioning of the matrix and how far apart or close the actual\n   * eigenvalues are. Note that currently, relatively simple, \"traditional\"\n   * methods of eigenvalue computation are being used; this is not a modern,\n   * high-precision eigenvalue computation. That said, it should typically\n   * produce fairly reasonable results.\n   *\n   * Syntax:\n   *\n   *     math.eigs(x, [prec])\n   *     math.eigs(x, {options})\n   *\n   * Examples:\n   *\n   *     const { eigs, multiply, column, transpose, matrixFromColumns } = math\n   *     const H = [[5, 2.3], [2.3, 1]]\n   *     const ans = eigs(H) // returns {values: [E1,E2...sorted], eigenvectors: [{value: E1, vector: v2}, {value: e, vector: v2}, ...]\n   *     const E = ans.values\n   *     const V = ans.eigenvectors\n   *     multiply(H, V[0].vector)) // returns multiply(E[0], V[0].vector))\n   *     const U = matrixFromColumns(...V.map(obj => obj.vector))\n   *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H if possible\n   *     E[0] == UTxHxU[0][0]  // returns true always\n   *\n   *     // Compute only approximate eigenvalues:\n   *     const {values} = eigs(H, {eigenvectors: false, precision: 1e-6})\n   *\n   * See also:\n   *\n   *     inv\n   *\n   * @param {Array | Matrix} x  Matrix to be diagonalized\n   *\n   * @param {number | BigNumber | OptsObject} [opts] Object with keys `precision`, defaulting to config.relTol, and `eigenvectors`, defaulting to true and specifying whether to compute eigenvectors. If just a number, specifies precision.\n   * @return {{values: Array|Matrix, eigenvectors?: Array<EVobj>}} Object containing an array of eigenvalues and an array of {value: number|BigNumber, vector: Array|Matrix} objects. The eigenvectors property is undefined if eigenvectors were not requested.\n   *\n   */\n  return typed('eigs', {\n    // The conversion to matrix in the first two implementations,\n    // just to convert back to an array right away in\n    // computeValuesAndVectors, is unfortunate, and should perhaps be\n    // streamlined. It is done because the Matrix object carries some\n    // type information about its entries, and so constructing the matrix\n    // is a roundabout way of doing type detection.\n    Array: function Array(x) {\n      return doEigs(matrix(x));\n    },\n    'Array, number|BigNumber': function Array_numberBigNumber(x, prec) {\n      return doEigs(matrix(x), {\n        precision: prec\n      });\n    },\n    'Array, Object'(x, opts) {\n      return doEigs(matrix(x), opts);\n    },\n    Matrix: function Matrix(mat) {\n      return doEigs(mat, {\n        matricize: true\n      });\n    },\n    'Matrix, number|BigNumber': function Matrix_numberBigNumber(mat, prec) {\n      return doEigs(mat, {\n        precision: prec,\n        matricize: true\n      });\n    },\n    'Matrix, Object': function Matrix_Object(mat, opts) {\n      var useOpts = {\n        matricize: true\n      };\n      _extends(useOpts, opts);\n      return doEigs(mat, useOpts);\n    }\n  });\n  function doEigs(mat) {\n    var _opts$precision;\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var computeVectors = 'eigenvectors' in opts ? opts.eigenvectors : true;\n    var prec = (_opts$precision = opts.precision) !== null && _opts$precision !== void 0 ? _opts$precision : config.relTol;\n    var result = computeValuesAndVectors(mat, prec, computeVectors);\n    if (opts.matricize) {\n      result.values = matrix(result.values);\n      if (computeVectors) {\n        result.eigenvectors = result.eigenvectors.map(_ref2 => {\n          var {\n            value,\n            vector\n          } = _ref2;\n          return {\n            value,\n            vector: matrix(vector)\n          };\n        });\n      }\n    }\n    if (computeVectors) {\n      Object.defineProperty(result, 'vectors', {\n        enumerable: false,\n        // to make sure that the eigenvectors can still be\n        // converted to string.\n        get: () => {\n          throw new Error('eigs(M).vectors replaced with eigs(M).eigenvectors');\n        }\n      });\n    }\n    return result;\n  }\n  function computeValuesAndVectors(mat, prec, computeVectors) {\n    var arr = mat.toArray(); // NOTE: arr is guaranteed to be unaliased\n    // and so safe to modify in place\n    var asize = mat.size();\n    if (asize.length !== 2 || asize[0] !== asize[1]) {\n      throw new RangeError(\"Matrix must be square (size: \".concat(format(asize), \")\"));\n    }\n    var N = asize[0];\n    if (isReal(arr, N, prec)) {\n      coerceReal(arr, N); // modifies arr by side effect\n\n      if (isSymmetric(arr, N, prec)) {\n        var _type = coerceTypes(mat, arr, N); // modifies arr by side effect\n        return doRealSymmetric(arr, N, prec, _type, computeVectors);\n      }\n    }\n    var type = coerceTypes(mat, arr, N); // modifies arr by side effect\n    return doComplexEigs(arr, N, prec, type, computeVectors);\n  }\n\n  /** @return {boolean} */\n  function isSymmetric(arr, N, prec) {\n    for (var i = 0; i < N; i++) {\n      for (var j = i; j < N; j++) {\n        // TODO proper comparison of bignum and frac\n        if (larger(bignumber(abs(subtract(arr[i][j], arr[j][i]))), prec)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /** @return {boolean} */\n  function isReal(arr, N, prec) {\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        // TODO proper comparison of bignum and frac\n        if (larger(bignumber(abs(im(arr[i][j]))), prec)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  function coerceReal(arr, N) {\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        arr[i][j] = re(arr[i][j]);\n      }\n    }\n  }\n\n  /** @return {'number' | 'BigNumber' | 'Complex'} */\n  function coerceTypes(mat, arr, N) {\n    /** @type {string} */\n    var type = mat.datatype();\n    if (type === 'number' || type === 'BigNumber' || type === 'Complex') {\n      return type;\n    }\n    var hasNumber = false;\n    var hasBig = false;\n    var hasComplex = false;\n    for (var i = 0; i < N; i++) {\n      for (var j = 0; j < N; j++) {\n        var el = arr[i][j];\n        if (isNumber(el) || isFraction(el)) {\n          hasNumber = true;\n        } else if (isBigNumber(el)) {\n          hasBig = true;\n        } else if (isComplex(el)) {\n          hasComplex = true;\n        } else {\n          throw TypeError('Unsupported type in Matrix: ' + typeOf(el));\n        }\n      }\n    }\n    if (hasBig && hasComplex) {\n      console.warn('Complex BigNumbers not supported, this operation will lose precission.');\n    }\n    if (hasComplex) {\n      for (var _i = 0; _i < N; _i++) {\n        for (var _j = 0; _j < N; _j++) {\n          arr[_i][_j] = complex(arr[_i][_j]);\n        }\n      }\n      return 'Complex';\n    }\n    if (hasBig) {\n      for (var _i2 = 0; _i2 < N; _i2++) {\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          arr[_i2][_j2] = bignumber(arr[_i2][_j2]);\n        }\n      }\n      return 'BigNumber';\n    }\n    if (hasNumber) {\n      for (var _i3 = 0; _i3 < N; _i3++) {\n        for (var _j3 = 0; _j3 < N; _j3++) {\n          arr[_i3][_j3] = number(arr[_i3][_j3]);\n        }\n      }\n      return 'number';\n    } else {\n      throw TypeError('Matrix contains unsupported types only.');\n    }\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5980, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/expm.js"],"sourcesContent":["import { isSparseMatrix } from '../../utils/is.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'expm';\nvar dependencies = ['typed', 'abs', 'add', 'identity', 'inv', 'multiply'];\nexport var createExpm = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    abs,\n    add,\n    identity,\n    inv,\n    multiply\n  } = _ref;\n  /**\n   * Compute the matrix exponential, expm(A) = e^A. The matrix must be square.\n   * Not to be confused with exp(a), which performs element-wise\n   * exponentiation.\n   *\n   * The exponential is calculated using the Padé approximant with scaling and\n   * squaring; see \"Nineteen Dubious Ways to Compute the Exponential of a\n   * Matrix,\" by Moler and Van Loan.\n   *\n   * Syntax:\n   *\n   *     math.expm(x)\n   *\n   * Examples:\n   *\n   *     const A = [[0,2],[0,0]]\n   *     math.expm(A)        // returns [[1,2],[0,1]]\n   *\n   * See also:\n   *\n   *     exp\n   *\n   * @param {Matrix} x  A square Matrix\n   * @return {Matrix}   The exponential of x\n   */\n  return typed(name, {\n    Matrix: function Matrix(A) {\n      // Check matrix size\n      var size = A.size();\n      if (size.length !== 2 || size[0] !== size[1]) {\n        throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n      }\n      var n = size[0];\n\n      // Desired accuracy of the approximant (The actual accuracy\n      // will be affected by round-off error)\n      var eps = 1e-15;\n\n      // The Padé approximant is not so accurate when the values of A\n      // are \"large\", so scale A by powers of two. Then compute the\n      // exponential, and square the result repeatedly according to\n      // the identity e^A = (e^(A/m))^m\n\n      // Compute infinity-norm of A, ||A||, to see how \"big\" it is\n      var infNorm = infinityNorm(A);\n\n      // Find the optimal scaling factor and number of terms in the\n      // Padé approximant to reach the desired accuracy\n      var params = findParams(infNorm, eps);\n      var q = params.q;\n      var j = params.j;\n\n      // The Pade approximation to e^A is:\n      // Rqq(A) = Dqq(A) ^ -1 * Nqq(A)\n      // where\n      // Nqq(A) = sum(i=0, q, (2q-i)!p! / [ (2q)!i!(q-i)! ] A^i\n      // Dqq(A) = sum(i=0, q, (2q-i)!q! / [ (2q)!i!(q-i)! ] (-A)^i\n\n      // Scale A by 1 / 2^j\n      var Apos = multiply(A, Math.pow(2, -j));\n\n      // The i=0 term is just the identity matrix\n      var N = identity(n);\n      var D = identity(n);\n\n      // Initialization (i=0)\n      var factor = 1;\n\n      // Initialization (i=1)\n      var AposToI = Apos; // Cloning not necessary\n      var alternate = -1;\n      for (var i = 1; i <= q; i++) {\n        if (i > 1) {\n          AposToI = multiply(AposToI, Apos);\n          alternate = -alternate;\n        }\n        factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);\n        N = add(N, multiply(factor, AposToI));\n        D = add(D, multiply(factor * alternate, AposToI));\n      }\n      var R = multiply(inv(D), N);\n\n      // Square j times\n      for (var _i = 0; _i < j; _i++) {\n        R = multiply(R, R);\n      }\n      return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;\n    }\n  });\n  function infinityNorm(A) {\n    var n = A.size()[0];\n    var infNorm = 0;\n    for (var i = 0; i < n; i++) {\n      var rowSum = 0;\n      for (var j = 0; j < n; j++) {\n        rowSum += abs(A.get([i, j]));\n      }\n      infNorm = Math.max(rowSum, infNorm);\n    }\n    return infNorm;\n  }\n\n  /**\n   * Find the best parameters for the Pade approximant given\n   * the matrix norm and desired accuracy. Returns the first acceptable\n   * combination in order of increasing computational load.\n   */\n  function findParams(infNorm, eps) {\n    var maxSearchSize = 30;\n    for (var k = 0; k < maxSearchSize; k++) {\n      for (var q = 0; q <= k; q++) {\n        var j = k - q;\n        if (errorEstimate(infNorm, q, j) < eps) {\n          return {\n            q,\n            j\n          };\n        }\n      }\n    }\n    throw new Error('Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)');\n  }\n\n  /**\n   * Returns the estimated error of the Pade approximant for the given\n   * parameters.\n   */\n  function errorEstimate(infNorm, q, j) {\n    var qfac = 1;\n    for (var i = 2; i <= q; i++) {\n      qfac *= i;\n    }\n    var twoqfac = qfac;\n    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {\n      twoqfac *= _i2;\n    }\n    var twoqp1fac = twoqfac * (2 * q + 1);\n    return 8.0 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6135, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/matrix/sqrtm.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { format } from '../../utils/string.js';\nimport { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'sqrtm';\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'map', 'sqrt', 'subtract', 'inv', 'size', 'max', 'identity'];\nexport var createSqrtm = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    abs,\n    add,\n    multiply,\n    map,\n    sqrt,\n    subtract,\n    inv,\n    size,\n    max,\n    identity\n  } = _ref;\n  var _maxIterations = 1e3;\n  var _tolerance = 1e-6;\n\n  /**\n   * Calculate the principal square root matrix using the Denman–Beavers iterative method\n   *\n   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix#By_Denman–Beavers_iteration\n   *\n   * @param  {Array | Matrix} A   The square matrix `A`\n   * @return {Array | Matrix}     The principal square root of matrix `A`\n   * @private\n   */\n  function _denmanBeavers(A) {\n    var error;\n    var iterations = 0;\n    var Y = A;\n    var Z = identity(size(A));\n    do {\n      var Yk = Y;\n      Y = multiply(0.5, add(Yk, inv(Z)));\n      Z = multiply(0.5, add(Z, inv(Yk)));\n      error = max(abs(subtract(Y, Yk)));\n      if (error > _tolerance && ++iterations > _maxIterations) {\n        throw new Error('computing square root of matrix: iterative method could not converge');\n      }\n    } while (error > _tolerance);\n    return Y;\n  }\n\n  /**\n   * Calculate the principal square root of a square matrix.\n   * The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.\n   *\n   * https://en.wikipedia.org/wiki/Square_root_of_a_matrix\n   *\n   * Syntax:\n   *\n   *     math.sqrtm(A)\n   *\n   * Examples:\n   *\n   *     math.sqrtm([[33, 24], [48, 57]]) // returns [[5, 2], [4, 7]]\n   *\n   * See also:\n   *\n   *     sqrt, pow\n   *\n   * @param  {Array | Matrix} A   The square matrix `A`\n   * @return {Array | Matrix}     The principal square root of matrix `A`\n   */\n  return typed(name, {\n    'Array | Matrix': function Array__Matrix(A) {\n      var size = isMatrix(A) ? A.size() : arraySize(A);\n      switch (size.length) {\n        case 1:\n          // Single element Array | Matrix\n          if (size[0] === 1) {\n            return map(A, sqrt);\n          } else {\n            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n          }\n        case 2:\n          {\n            // Two-dimensional Array | Matrix\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              return _denmanBeavers(A);\n            } else {\n              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');\n            }\n          }\n        default:\n          // Multi dimensional array\n          throw new RangeError('Matrix must be at most two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAO;IAAO;IAAY;IAAO;IAAQ;IAAY;IAAO;IAAQ;IAAO;CAAW;AAC5G,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,KAAK,EACL,GAAG,EACH,GAAG,EACH,QAAQ,EACR,GAAG,EACH,IAAI,EACJ,QAAQ,EACR,GAAG,EACH,IAAI,EACJ,GAAG,EACH,QAAQ,EACT,GAAG;IACJ,IAAI,iBAAiB;IACrB,IAAI,aAAa;IAEjB;;;;;;;;GAQC,GACD,SAAS,eAAe,CAAC;QACvB,IAAI;QACJ,IAAI,aAAa;QACjB,IAAI,IAAI;QACR,IAAI,IAAI,SAAS,KAAK;QACtB,GAAG;YACD,IAAI,KAAK;YACT,IAAI,SAAS,KAAK,IAAI,IAAI,IAAI;YAC9B,IAAI,SAAS,KAAK,IAAI,GAAG,IAAI;YAC7B,QAAQ,IAAI,IAAI,SAAS,GAAG;YAC5B,IAAI,QAAQ,cAAc,EAAE,aAAa,gBAAgB;gBACvD,MAAM,IAAI,MAAM;YAClB;QACF,QAAS,QAAQ,WAAY;QAC7B,OAAO;IACT;IAEA;;;;;;;;;;;;;;;;;;;;GAoBC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB,SAAS,cAAc,CAAC;YACxC,IAAI,OAAO,CAAA,GAAA,mJAAA,CAAA,WAAQ,AAAD,EAAE,KAAK,EAAE,IAAI,KAAK,CAAA,GAAA,sJAAA,CAAA,YAAS,AAAD,EAAE;YAC9C,OAAQ,KAAK,MAAM;gBACjB,KAAK;oBACH,gCAAgC;oBAChC,IAAI,IAAI,CAAC,EAAE,KAAK,GAAG;wBACjB,OAAO,IAAI,GAAG;oBAChB,OAAO;wBACL,MAAM,IAAI,WAAW,2BAA2B,YAAY,CAAA,GAAA,uJAAA,CAAA,SAAM,AAAD,EAAE,QAAQ;oBAC7E;gBACF,KAAK;oBACH;wBACE,iCAAiC;wBACjC,IAAI,OAAO,IAAI,CAAC,EAAE;wBAClB,IAAI,OAAO,IAAI,CAAC,EAAE;wBAClB,IAAI,SAAS,MAAM;4BACjB,OAAO,eAAe;wBACxB,OAAO;4BACL,MAAM,IAAI,WAAW,2BAA2B,YAAY,CAAA,GAAA,uJAAA,CAAA,SAAM,AAAD,EAAE,QAAQ;wBAC7E;oBACF;gBACF;oBACE,0BAA0B;oBAC1B,MAAM,IAAI,WAAW,4CAA4C,YAAY,CAAA,GAAA,uJAAA,CAAA,SAAM,AAAD,EAAE,QAAQ;YAChG;QACF;IACF;AACF","ignoreList":[0],"debugId":null}}]
}