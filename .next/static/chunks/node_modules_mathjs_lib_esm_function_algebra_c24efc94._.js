(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_mathjs_lib_esm_function_algebra_c24efc94._.js", {

"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSolveValidation": (()=>createSolveValidation)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/string.js [app-client] (ecmascript)");
;
;
;
function createSolveValidation(_ref) {
    var { DenseMatrix } = _ref;
    /**
   * Validates matrix and column vector b for backward/forward substitution algorithms.
   *
   * @param {Matrix} m            An N x N matrix
   * @param {Array | Matrix} b    A column vector
   * @param {Boolean} copy        Return a copy of vector b
   *
   * @return {DenseMatrix}        Dense column vector b
   */ return function solveValidation(m, b, copy) {
        var mSize = m.size();
        if (mSize.length !== 2) {
            throw new RangeError('Matrix must be two dimensional (size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(mSize) + ')');
        }
        var rows = mSize[0];
        var columns = mSize[1];
        if (rows !== columns) {
            throw new RangeError('Matrix must be square (size: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(mSize) + ')');
        }
        var data = [];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(b)) {
            var bSize = b.size();
            var bdata = b._data;
            // 1-dim vector
            if (bSize.length === 1) {
                if (bSize[0] !== rows) {
                    throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
                }
                for(var i = 0; i < rows; i++){
                    data[i] = [
                        bdata[i]
                    ];
                }
                return new DenseMatrix({
                    data,
                    size: [
                        rows,
                        1
                    ],
                    datatype: b._datatype
                });
            }
            // 2-dim column
            if (bSize.length === 2) {
                if (bSize[0] !== rows || bSize[1] !== 1) {
                    throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDenseMatrix"])(b)) {
                    if (copy) {
                        data = [];
                        for(var _i = 0; _i < rows; _i++){
                            data[_i] = [
                                bdata[_i][0]
                            ];
                        }
                        return new DenseMatrix({
                            data,
                            size: [
                                rows,
                                1
                            ],
                            datatype: b._datatype
                        });
                    }
                    return b;
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSparseMatrix"])(b)) {
                    for(var _i2 = 0; _i2 < rows; _i2++){
                        data[_i2] = [
                            0
                        ];
                    }
                    var values = b._values;
                    var index = b._index;
                    var ptr = b._ptr;
                    for(var k1 = ptr[1], k = ptr[0]; k < k1; k++){
                        var _i3 = index[k];
                        data[_i3][0] = values[k];
                    }
                    return new DenseMatrix({
                        data,
                        size: [
                            rows,
                            1
                        ],
                        datatype: b._datatype
                    });
                }
            }
            throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(b)) {
            var bsize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraySize"])(b);
            if (bsize.length === 1) {
                if (bsize[0] !== rows) {
                    throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
                }
                for(var _i4 = 0; _i4 < rows; _i4++){
                    data[_i4] = [
                        b[_i4]
                    ];
                }
                return new DenseMatrix({
                    data,
                    size: [
                        rows,
                        1
                    ]
                });
            }
            if (bsize.length === 2) {
                if (bsize[0] !== rows || bsize[1] !== 1) {
                    throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
                }
                for(var _i5 = 0; _i5 < rows; _i5++){
                    data[_i5] = [
                        b[_i5][0]
                    ];
                }
                return new DenseMatrix({
                    data,
                    size: [
                        rows,
                        1
                    ]
                });
            }
            throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
        }
    };
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLsolve": (()=>createLsolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-client] (ecmascript)");
;
;
var name = 'lsolve';
var dependencies = [
    'typed',
    'matrix',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'equalScalar',
    'DenseMatrix'
];
var createLsolve = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, divideScalar, multiplyScalar, subtractScalar, equalScalar, DenseMatrix } = _ref;
    var solveValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSolveValidation"])({
        DenseMatrix
    });
    /**
   * Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there's no solution.
   *
   * `L * x = b`
   *
   * Syntax:
   *
   *    math.lsolve(L, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = lsolve(a, b)  // [[-5.5], [20]]
   *
   * See also:
   *
   *    lsolveAll, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} L       A N x N matrix or array (L)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
   */ return typed(name, {
        'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {
            return _sparseForwardSubstitution(m, b);
        },
        'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {
            return _denseForwardSubstitution(m, b);
        },
        'Array, Array | Matrix': function Array_Array__Matrix(a, b) {
            var m = matrix(a);
            var r = _denseForwardSubstitution(m, b);
            return r.valueOf();
        }
    });
    "TURBOPACK unreachable";
    function _denseForwardSubstitution(m, b) {
        // validate matrix and vector, return copy of column vector b
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        // result
        var x = [];
        var mdata = m._data;
        // loop columns
        for(var j = 0; j < columns; j++){
            var bj = bdata[j][0] || 0;
            var xj = void 0;
            if (!equalScalar(bj, 0)) {
                // non-degenerate row, find solution
                var vjj = mdata[j][j];
                if (equalScalar(vjj, 0)) {
                    throw new Error('Linear system cannot be solved since matrix is singular');
                }
                xj = divideScalar(bj, vjj);
                // loop rows
                for(var i = j + 1; i < rows; i++){
                    bdata[i] = [
                        subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))
                    ];
                }
            } else {
                // degenerate row, we can choose any value
                xj = 0;
            }
            x[j] = [
                xj
            ];
        }
        return new DenseMatrix({
            data: x,
            size: [
                rows,
                1
            ]
        });
    }
    function _sparseForwardSubstitution(m, b) {
        // validate matrix and vector, return copy of column vector b
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // result
        var x = [];
        // loop columns
        for(var j = 0; j < columns; j++){
            var bj = bdata[j][0] || 0;
            if (!equalScalar(bj, 0)) {
                // non-degenerate row, find solution
                var vjj = 0;
                // matrix values & indices (column j)
                var jValues = [];
                var jIndices = [];
                // first and last index in the column
                var firstIndex = ptr[j];
                var lastIndex = ptr[j + 1];
                // values in column, find value at [j, j]
                for(var k = firstIndex; k < lastIndex; k++){
                    var i = index[k];
                    // check row (rows are not sorted!)
                    if (i === j) {
                        vjj = values[k];
                    } else if (i > j) {
                        // store lower triangular
                        jValues.push(values[k]);
                        jIndices.push(i);
                    }
                }
                // at this point we must have a value in vjj
                if (equalScalar(vjj, 0)) {
                    throw new Error('Linear system cannot be solved since matrix is singular');
                }
                var xj = divideScalar(bj, vjj);
                for(var _k = 0, l = jIndices.length; _k < l; _k++){
                    var _i = jIndices[_k];
                    bdata[_i] = [
                        subtractScalar(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))
                    ];
                }
                x[j] = [
                    xj
                ];
            } else {
                // degenerate row, we can choose any value
                x[j] = [
                    0
                ];
            }
        }
        return new DenseMatrix({
            data: x,
            size: [
                rows,
                1
            ]
        });
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUsolve": (()=>createUsolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-client] (ecmascript)");
;
;
var name = 'usolve';
var dependencies = [
    'typed',
    'matrix',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'equalScalar',
    'DenseMatrix'
];
var createUsolve = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, divideScalar, multiplyScalar, subtractScalar, equalScalar, DenseMatrix } = _ref;
    var solveValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSolveValidation"])({
        DenseMatrix
    });
    /**
   * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.
   *
   * `U * x = b`
   *
   * Syntax:
   *
   *    math.usolve(U, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = usolve(a, b)  // [[8], [9]]
   *
   * See also:
   *
   *    usolveAll, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} U       A N x N matrix or array (U)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
   */ return typed(name, {
        'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {
            return _sparseBackwardSubstitution(m, b);
        },
        'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {
            return _denseBackwardSubstitution(m, b);
        },
        'Array, Array | Matrix': function Array_Array__Matrix(a, b) {
            var m = matrix(a);
            var r = _denseBackwardSubstitution(m, b);
            return r.valueOf();
        }
    });
    "TURBOPACK unreachable";
    function _denseBackwardSubstitution(m, b) {
        // make b into a column vector
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        // result
        var x = [];
        var mdata = m._data;
        // loop columns backwards
        for(var j = columns - 1; j >= 0; j--){
            // b[j]
            var bj = bdata[j][0] || 0;
            // x[j]
            var xj = void 0;
            if (!equalScalar(bj, 0)) {
                // value at [j, j]
                var vjj = mdata[j][j];
                if (equalScalar(vjj, 0)) {
                    // system cannot be solved
                    throw new Error('Linear system cannot be solved since matrix is singular');
                }
                xj = divideScalar(bj, vjj);
                // loop rows
                for(var i = j - 1; i >= 0; i--){
                    // update copy of b
                    bdata[i] = [
                        subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))
                    ];
                }
            } else {
                // zero value at j
                xj = 0;
            }
            // update x
            x[j] = [
                xj
            ];
        }
        return new DenseMatrix({
            data: x,
            size: [
                rows,
                1
            ]
        });
    }
    function _sparseBackwardSubstitution(m, b) {
        // make b into a column vector
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // result
        var x = [];
        // loop columns backwards
        for(var j = columns - 1; j >= 0; j--){
            var bj = bdata[j][0] || 0;
            if (!equalScalar(bj, 0)) {
                // non-degenerate row, find solution
                var vjj = 0;
                // upper triangular matrix values & index (column j)
                var jValues = [];
                var jIndices = [];
                // first & last indeces in column
                var firstIndex = ptr[j];
                var lastIndex = ptr[j + 1];
                // values in column, find value at [j, j], loop backwards
                for(var k = lastIndex - 1; k >= firstIndex; k--){
                    var i = index[k];
                    // check row (rows are not sorted!)
                    if (i === j) {
                        vjj = values[k];
                    } else if (i < j) {
                        // store upper triangular
                        jValues.push(values[k]);
                        jIndices.push(i);
                    }
                }
                // at this point we must have a value in vjj
                if (equalScalar(vjj, 0)) {
                    throw new Error('Linear system cannot be solved since matrix is singular');
                }
                var xj = divideScalar(bj, vjj);
                for(var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++){
                    var _i = jIndices[_k];
                    bdata[_i] = [
                        subtractScalar(bdata[_i][0], multiplyScalar(xj, jValues[_k]))
                    ];
                }
                x[j] = [
                    xj
                ];
            } else {
                // degenerate row, we can choose any value
                x[j] = [
                    0
                ];
            }
        }
        return new DenseMatrix({
            data: x,
            size: [
                rows,
                1
            ]
        });
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLsolveAll": (()=>createLsolveAll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-client] (ecmascript)");
;
;
var name = 'lsolveAll';
var dependencies = [
    'typed',
    'matrix',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'equalScalar',
    'DenseMatrix'
];
var createLsolveAll = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, divideScalar, multiplyScalar, subtractScalar, equalScalar, DenseMatrix } = _ref;
    var solveValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSolveValidation"])({
        DenseMatrix
    });
    /**
   * Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.
   *
   * `L * x = b`
   *
   * Syntax:
   *
   *    math.lsolveAll(L, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]
   *
   * See also:
   *
   *    lsolve, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} L       A N x N matrix or array (L)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system
   */ return typed(name, {
        'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {
            return _sparseForwardSubstitution(m, b);
        },
        'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {
            return _denseForwardSubstitution(m, b);
        },
        'Array, Array | Matrix': function Array_Array__Matrix(a, b) {
            var m = matrix(a);
            var R = _denseForwardSubstitution(m, b);
            return R.map((r)=>r.valueOf());
        }
    });
    "TURBOPACK unreachable";
    function _denseForwardSubstitution(m, b_) {
        // the algorithm is derived from
        // https://www.overleaf.com/read/csvgqdxggyjv
        // array of right-hand sides
        var B = [
            solveValidation(m, b_, true)._data.map((e)=>e[0])
        ];
        var M = m._data;
        var rows = m._size[0];
        var columns = m._size[1];
        // loop columns
        for(var i = 0; i < columns; i++){
            var L = B.length;
            // loop right-hand sides
            for(var k = 0; k < L; k++){
                var b = B[k];
                if (!equalScalar(M[i][i], 0)) {
                    // non-singular row
                    b[i] = divideScalar(b[i], M[i][i]);
                    for(var j = i + 1; j < columns; j++){
                        // b[j] -= b[i] * M[j,i]
                        b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));
                    }
                } else if (!equalScalar(b[i], 0)) {
                    // singular row, nonzero RHS
                    if (k === 0) {
                        // There is no valid solution
                        return [];
                    } else {
                        // This RHS is invalid but other solutions may still exist
                        B.splice(k, 1);
                        k -= 1;
                        L -= 1;
                    }
                } else if (k === 0) {
                    // singular row, RHS is zero
                    var bNew = [
                        ...b
                    ];
                    bNew[i] = 1;
                    for(var _j = i + 1; _j < columns; _j++){
                        bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);
                    }
                    B.push(bNew);
                }
            }
        }
        return B.map((x)=>new DenseMatrix({
                data: x.map((e)=>[
                        e
                    ]),
                size: [
                    rows,
                    1
                ]
            }));
    }
    function _sparseForwardSubstitution(m, b_) {
        // array of right-hand sides
        var B = [
            solveValidation(m, b_, true)._data.map((e)=>e[0])
        ];
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // loop columns
        for(var i = 0; i < columns; i++){
            var L = B.length;
            // loop right-hand sides
            for(var k = 0; k < L; k++){
                var b = B[k];
                // values & indices (column i)
                var iValues = [];
                var iIndices = [];
                // first & last indeces in column
                var firstIndex = ptr[i];
                var lastIndex = ptr[i + 1];
                // find the value at [i, i]
                var Mii = 0;
                for(var j = firstIndex; j < lastIndex; j++){
                    var J = index[j];
                    // check row
                    if (J === i) {
                        Mii = values[j];
                    } else if (J > i) {
                        // store lower triangular
                        iValues.push(values[j]);
                        iIndices.push(J);
                    }
                }
                if (!equalScalar(Mii, 0)) {
                    // non-singular row
                    b[i] = divideScalar(b[i], Mii);
                    for(var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++){
                        var _J = iIndices[_j2];
                        b[_J] = subtractScalar(b[_J], multiplyScalar(b[i], iValues[_j2]));
                    }
                } else if (!equalScalar(b[i], 0)) {
                    // singular row, nonzero RHS
                    if (k === 0) {
                        // There is no valid solution
                        return [];
                    } else {
                        // This RHS is invalid but other solutions may still exist
                        B.splice(k, 1);
                        k -= 1;
                        L -= 1;
                    }
                } else if (k === 0) {
                    // singular row, RHS is zero
                    var bNew = [
                        ...b
                    ];
                    bNew[i] = 1;
                    for(var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++){
                        var _J2 = iIndices[_j3];
                        bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);
                    }
                    B.push(bNew);
                }
            }
        }
        return B.map((x)=>new DenseMatrix({
                data: x.map((e)=>[
                        e
                    ]),
                size: [
                    rows,
                    1
                ]
            }));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUsolveAll": (()=>createUsolveAll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-client] (ecmascript)");
;
;
var name = 'usolveAll';
var dependencies = [
    'typed',
    'matrix',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'equalScalar',
    'DenseMatrix'
];
var createUsolveAll = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, divideScalar, multiplyScalar, subtractScalar, equalScalar, DenseMatrix } = _ref;
    var solveValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSolveValidation"])({
        DenseMatrix
    });
    /**
   * Finds all solutions of a linear equation system by backward substitution. Matrix must be an upper triangular matrix.
   *
   * `U * x = b`
   *
   * Syntax:
   *
   *    math.usolveAll(U, b)
   *
   * Examples:
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = usolveAll(a, b)  // [ [[8], [9]] ]
   *
   * See also:
   *
   *    usolve, lup, slu, usolve, lusolve
   *
   * @param {Matrix, Array} U       A N x N matrix or array (U)
   * @param {Matrix, Array} b       A column vector with the b values
   *
   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system
   */ return typed(name, {
        'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {
            return _sparseBackwardSubstitution(m, b);
        },
        'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {
            return _denseBackwardSubstitution(m, b);
        },
        'Array, Array | Matrix': function Array_Array__Matrix(a, b) {
            var m = matrix(a);
            var R = _denseBackwardSubstitution(m, b);
            return R.map((r)=>r.valueOf());
        }
    });
    "TURBOPACK unreachable";
    function _denseBackwardSubstitution(m, b_) {
        // the algorithm is derived from
        // https://www.overleaf.com/read/csvgqdxggyjv
        // array of right-hand sides
        var B = [
            solveValidation(m, b_, true)._data.map((e)=>e[0])
        ];
        var M = m._data;
        var rows = m._size[0];
        var columns = m._size[1];
        // loop columns backwards
        for(var i = columns - 1; i >= 0; i--){
            var L = B.length;
            // loop right-hand sides
            for(var k = 0; k < L; k++){
                var b = B[k];
                if (!equalScalar(M[i][i], 0)) {
                    // non-singular row
                    b[i] = divideScalar(b[i], M[i][i]);
                    for(var j = i - 1; j >= 0; j--){
                        // b[j] -= b[i] * M[j,i]
                        b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));
                    }
                } else if (!equalScalar(b[i], 0)) {
                    // singular row, nonzero RHS
                    if (k === 0) {
                        // There is no valid solution
                        return [];
                    } else {
                        // This RHS is invalid but other solutions may still exist
                        B.splice(k, 1);
                        k -= 1;
                        L -= 1;
                    }
                } else if (k === 0) {
                    // singular row, RHS is zero
                    var bNew = [
                        ...b
                    ];
                    bNew[i] = 1;
                    for(var _j = i - 1; _j >= 0; _j--){
                        bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);
                    }
                    B.push(bNew);
                }
            }
        }
        return B.map((x)=>new DenseMatrix({
                data: x.map((e)=>[
                        e
                    ]),
                size: [
                    rows,
                    1
                ]
            }));
    }
    function _sparseBackwardSubstitution(m, b_) {
        // array of right-hand sides
        var B = [
            solveValidation(m, b_, true)._data.map((e)=>e[0])
        ];
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // loop columns backwards
        for(var i = columns - 1; i >= 0; i--){
            var L = B.length;
            // loop right-hand sides
            for(var k = 0; k < L; k++){
                var b = B[k];
                // values & indices (column i)
                var iValues = [];
                var iIndices = [];
                // first & last indeces in column
                var firstIndex = ptr[i];
                var lastIndex = ptr[i + 1];
                // find the value at [i, i]
                var Mii = 0;
                for(var j = lastIndex - 1; j >= firstIndex; j--){
                    var J = index[j];
                    // check row
                    if (J === i) {
                        Mii = values[j];
                    } else if (J < i) {
                        // store upper triangular
                        iValues.push(values[j]);
                        iIndices.push(J);
                    }
                }
                if (!equalScalar(Mii, 0)) {
                    // non-singular row
                    b[i] = divideScalar(b[i], Mii);
                    // loop upper triangular
                    for(var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++){
                        var _J = iIndices[_j2];
                        b[_J] = subtractScalar(b[_J], multiplyScalar(b[i], iValues[_j2]));
                    }
                } else if (!equalScalar(b[i], 0)) {
                    // singular row, nonzero RHS
                    if (k === 0) {
                        // There is no valid solution
                        return [];
                    } else {
                        // This RHS is invalid but other solutions may still exist
                        B.splice(k, 1);
                        k -= 1;
                        L -= 1;
                    }
                } else if (k === 0) {
                    // singular row, RHS is zero
                    var bNew = [
                        ...b
                    ];
                    bNew[i] = 1;
                    // loop upper triangular
                    for(var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++){
                        var _J2 = iIndices[_j3];
                        bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);
                    }
                    B.push(bNew);
                }
            }
        }
        return B.map((x)=>new DenseMatrix({
                data: x.map((e)=>[
                        e
                    ]),
                size: [
                    rows,
                    1
                ]
            }));
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLup": (()=>createLup)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
var name = 'lup';
var dependencies = [
    'typed',
    'matrix',
    'abs',
    'addScalar',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'larger',
    'equalScalar',
    'unaryMinus',
    'DenseMatrix',
    'SparseMatrix',
    'Spa'
];
var createLup = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, abs, addScalar, divideScalar, multiplyScalar, subtractScalar, larger, equalScalar, unaryMinus, DenseMatrix, SparseMatrix, Spa } = _ref;
    /**
   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a
   * row permutation vector `p` where `A[p,:] = L * U`
   *
   * Syntax:
   *
   *    math.lup(A)
   *
   * Example:
   *
   *    const m = [[2, 1], [1, 4]]
   *    const r = math.lup(m)
   *    // r = {
   *    //   L: [[1, 0], [0.5, 1]],
   *    //   U: [[2, 1], [0, 3.5]],
   *    //   P: [0, 1]
   *    // }
   *
   * See also:
   *
   *    slu, lsolve, lusolve, usolve
   *
   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.
   *
   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.
   */ return typed(name, {
        DenseMatrix: function DenseMatrix(m) {
            return _denseLUP(m);
        },
        SparseMatrix: function SparseMatrix(m) {
            return _sparseLUP(m);
        },
        Array: function Array(a) {
            // create dense matrix from array
            var m = matrix(a);
            // lup, use matrix implementation
            var r = _denseLUP(m);
            // result
            return {
                L: r.L.valueOf(),
                U: r.U.valueOf(),
                p: r.p
            };
        }
    });
    "TURBOPACK unreachable";
    function _denseLUP(m) {
        // rows & columns
        var rows = m._size[0];
        var columns = m._size[1];
        // minimum rows and columns
        var n = Math.min(rows, columns);
        // matrix array, clone original data
        var data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(m._data);
        // l matrix arrays
        var ldata = [];
        var lsize = [
            rows,
            n
        ];
        // u matrix arrays
        var udata = [];
        var usize = [
            n,
            columns
        ];
        // vars
        var i, j, k;
        // permutation vector
        var p = [];
        for(i = 0; i < rows; i++){
            p[i] = i;
        }
        // loop columns
        for(j = 0; j < columns; j++){
            // skip first column in upper triangular matrix
            if (j > 0) {
                // loop rows
                for(i = 0; i < rows; i++){
                    // min i,j
                    var min = Math.min(i, j);
                    // v[i, j]
                    var s = 0;
                    // loop up to min
                    for(k = 0; k < min; k++){
                        // s = l[i, k] - data[k, j]
                        s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));
                    }
                    data[i][j] = subtractScalar(data[i][j], s);
                }
            }
            // row with larger value in cvector, row >= j
            var pi = j;
            var pabsv = 0;
            var vjj = 0;
            // loop rows
            for(i = j; i < rows; i++){
                // data @ i, j
                var v = data[i][j];
                // absolute value
                var absv = abs(v);
                // value is greater than pivote value
                if (larger(absv, pabsv)) {
                    // store row
                    pi = i;
                    // update max value
                    pabsv = absv;
                    // value @ [j, j]
                    vjj = v;
                }
            }
            // swap rows (j <-> pi)
            if (j !== pi) {
                // swap values j <-> pi in p
                p[j] = [
                    p[pi],
                    p[pi] = p[j]
                ][0];
                // swap j <-> pi in data
                DenseMatrix._swapRows(j, pi, data);
            }
            // check column is in lower triangular matrix
            if (j < rows) {
                // loop rows (lower triangular matrix)
                for(i = j + 1; i < rows; i++){
                    // value @ i, j
                    var vij = data[i][j];
                    if (!equalScalar(vij, 0)) {
                        // update data
                        data[i][j] = divideScalar(data[i][j], vjj);
                    }
                }
            }
        }
        // loop columns
        for(j = 0; j < columns; j++){
            // loop rows
            for(i = 0; i < rows; i++){
                // initialize row in arrays
                if (j === 0) {
                    // check row exists in upper triangular matrix
                    if (i < columns) {
                        // U
                        udata[i] = [];
                    }
                    // L
                    ldata[i] = [];
                }
                // check we are in the upper triangular matrix
                if (i < j) {
                    // check row exists in upper triangular matrix
                    if (i < columns) {
                        // U
                        udata[i][j] = data[i][j];
                    }
                    // check column exists in lower triangular matrix
                    if (j < rows) {
                        // L
                        ldata[i][j] = 0;
                    }
                    continue;
                }
                // diagonal value
                if (i === j) {
                    // check row exists in upper triangular matrix
                    if (i < columns) {
                        // U
                        udata[i][j] = data[i][j];
                    }
                    // check column exists in lower triangular matrix
                    if (j < rows) {
                        // L
                        ldata[i][j] = 1;
                    }
                    continue;
                }
                // check row exists in upper triangular matrix
                if (i < columns) {
                    // U
                    udata[i][j] = 0;
                }
                // check column exists in lower triangular matrix
                if (j < rows) {
                    // L
                    ldata[i][j] = data[i][j];
                }
            }
        }
        // l matrix
        var l = new DenseMatrix({
            data: ldata,
            size: lsize
        });
        // u matrix
        var u = new DenseMatrix({
            data: udata,
            size: usize
        });
        // p vector
        var pv = [];
        for(i = 0, n = p.length; i < n; i++){
            pv[p[i]] = i;
        }
        // return matrices
        return {
            L: l,
            U: u,
            p: pv,
            toString: function toString() {
                return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\nP: ' + this.p;
            }
        };
    }
    function _sparseLUP(m) {
        // rows & columns
        var rows = m._size[0];
        var columns = m._size[1];
        // minimum rows and columns
        var n = Math.min(rows, columns);
        // matrix arrays (will not be modified, thanks to permutation vector)
        var values = m._values;
        var index = m._index;
        var ptr = m._ptr;
        // l matrix arrays
        var lvalues = [];
        var lindex = [];
        var lptr = [];
        var lsize = [
            rows,
            n
        ];
        // u matrix arrays
        var uvalues = [];
        var uindex = [];
        var uptr = [];
        var usize = [
            n,
            columns
        ];
        // vars
        var i, j, k;
        // permutation vectors, (current index -> original index) and (original index -> current index)
        var pvCo = [];
        var pvOc = [];
        for(i = 0; i < rows; i++){
            pvCo[i] = i;
            pvOc[i] = i;
        }
        // swap indices in permutation vectors (condition x < y)!
        var swapIndeces = function swapIndeces(x, y) {
            // find pv indeces getting data from x and y
            var kx = pvOc[x];
            var ky = pvOc[y];
            // update permutation vector current -> original
            pvCo[kx] = y;
            pvCo[ky] = x;
            // update permutation vector original -> current
            pvOc[x] = ky;
            pvOc[y] = kx;
        };
        // loop columns
        var _loop = function _loop() {
            // sparse accumulator
            var spa = new Spa();
            // check lower triangular matrix has a value @ column j
            if (j < rows) {
                // update ptr
                lptr.push(lvalues.length);
                // first value in j column for lower triangular matrix
                lvalues.push(1);
                lindex.push(j);
            }
            // update ptr
            uptr.push(uvalues.length);
            // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
            var k0 = ptr[j];
            var k1 = ptr[j + 1];
            // copy column j into sparse accumulator
            for(k = k0; k < k1; k++){
                // row
                i = index[k];
                // copy column values into sparse accumulator (use permutation vector)
                spa.set(pvCo[i], values[k]);
            }
            // skip first column in upper triangular matrix
            if (j > 0) {
                // loop rows in column j (above diagonal)
                spa.forEach(0, j - 1, function(k, vkj) {
                    // loop rows in column k (L)
                    SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function(i, vik) {
                        // check row is below k
                        if (i > k) {
                            // update spa value
                            spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));
                        }
                    });
                });
            }
            // row with larger value in spa, row >= j
            var pi = j;
            var vjj = spa.get(j);
            var pabsv = abs(vjj);
            // loop values in spa (order by row, below diagonal)
            spa.forEach(j + 1, rows - 1, function(x, v) {
                // absolute value
                var absv = abs(v);
                // value is greater than pivote value
                if (larger(absv, pabsv)) {
                    // store row
                    pi = x;
                    // update max value
                    pabsv = absv;
                    // value @ [j, j]
                    vjj = v;
                }
            });
            // swap rows (j <-> pi)
            if (j !== pi) {
                // swap values j <-> pi in L
                SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr);
                // swap values j <-> pi in U
                SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr);
                // swap values in spa
                spa.swap(j, pi);
                // update permutation vector (swap values @ j, pi)
                swapIndeces(j, pi);
            }
            // loop values in spa (order by row)
            spa.forEach(0, rows - 1, function(x, v) {
                // check we are above diagonal
                if (x <= j) {
                    // update upper triangular matrix
                    uvalues.push(v);
                    uindex.push(x);
                } else {
                    // update value
                    v = divideScalar(v, vjj);
                    // check value is non zero
                    if (!equalScalar(v, 0)) {
                        // update lower triangular matrix
                        lvalues.push(v);
                        lindex.push(x);
                    }
                }
            });
        };
        for(j = 0; j < columns; j++){
            _loop();
        }
        // update ptrs
        uptr.push(uvalues.length);
        lptr.push(lvalues.length);
        // return matrices
        return {
            L: new SparseMatrix({
                values: lvalues,
                index: lindex,
                ptr: lptr,
                size: lsize
            }),
            U: new SparseMatrix({
                values: uvalues,
                index: uindex,
                ptr: uptr,
                size: usize
            }),
            p: pvCo,
            toString: function toString() {
                return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\nP: ' + this.p;
            }
        };
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createQr": (()=>createQr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
var name = 'qr';
var dependencies = [
    'typed',
    'matrix',
    'zeros',
    'identity',
    'isZero',
    'equal',
    'sign',
    'sqrt',
    'conj',
    'unaryMinus',
    'addScalar',
    'divideScalar',
    'multiplyScalar',
    'subtractScalar',
    'complex'
];
var createQr = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, zeros, identity, isZero, equal, sign, sqrt, conj, unaryMinus, addScalar, divideScalar, multiplyScalar, subtractScalar, complex } = _ref;
    /**
   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in
   * two matrices (`Q`, `R`) where `Q` is an
   * orthogonal matrix and `R` is an upper triangular matrix.
   *
   * Syntax:
   *
   *    math.qr(A)
   *
   * Example:
   *
   *    const m = [
   *      [1, -1,  4],
   *      [1,  4, -2],
   *      [1,  4,  2],
   *      [1,  -1, 0]
   *    ]
   *    const result = math.qr(m)
   *    // r = {
   *    //   Q: [
   *    //     [0.5, -0.5,   0.5],
   *    //     [0.5,  0.5,  -0.5],
   *    //     [0.5,  0.5,   0.5],
   *    //     [0.5, -0.5,  -0.5],
   *    //   ],
   *    //   R: [
   *    //     [2, 3,  2],
   *    //     [0, 5, -2],
   *    //     [0, 0,  4],
   *    //     [0, 0,  0]
   *    //   ]
   *    // }
   *
   * See also:
   *
   *    lup, lusolve
   *
   * @param {Matrix | Array} A    A two dimensional matrix or array
   * for which to get the QR decomposition.
   *
   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal
   * matrix and R: the upper triangular matrix
   */ return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(typed(name, {
        DenseMatrix: function DenseMatrix(m) {
            return _denseQR(m);
        },
        SparseMatrix: function SparseMatrix(m) {
            return _sparseQR(m);
        },
        Array: function Array(a) {
            // create dense matrix from array
            var m = matrix(a);
            // lup, use matrix implementation
            var r = _denseQR(m);
            // result
            return {
                Q: r.Q.valueOf(),
                R: r.R.valueOf()
            };
        }
    }), {
        _denseQRimpl
    });
    "TURBOPACK unreachable";
    function _denseQRimpl(m) {
        // rows & columns (m x n)
        var rows = m._size[0]; // m
        var cols = m._size[1]; // n
        var Q = identity([
            rows
        ], 'dense');
        var Qdata = Q._data;
        var R = m.clone();
        var Rdata = R._data;
        // vars
        var i, j, k;
        var w = zeros([
            rows
        ], '');
        for(k = 0; k < Math.min(cols, rows); ++k){
            /*
       * **k-th Household matrix**
       *
       * The matrix I - 2*v*transpose(v)
       * x     = first column of A
       * x1    = first element of x
       * alpha = x1 / |x1| * |x|
       * e1    = tranpose([1, 0, 0, ...])
       * u     = x - alpha * e1
       * v     = u / |u|
       *
       * Household matrix = I - 2 * v * tranpose(v)
       *
       *  * Initially Q = I and R = A.
       *  * Household matrix is a reflection in a plane normal to v which
       *    will zero out all but the top right element in R.
       *  * Appplying reflection to both Q and R will not change product.
       *  * Repeat this process on the (1,1) minor to get R as an upper
       *    triangular matrix.
       *  * Reflections leave the magnitude of the columns of Q unchanged
       *    so Q remains othoganal.
       *
       */ var pivot = Rdata[k][k];
            var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));
            var conjSgn = conj(sgn);
            var alphaSquared = 0;
            for(i = k; i < rows; i++){
                alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));
            }
            var alpha = multiplyScalar(sgn, sqrt(alphaSquared));
            if (!isZero(alpha)) {
                // first element in vector u
                var u1 = subtractScalar(pivot, alpha);
                // w = v * u1 / |u|    (only elements k to (rows-1) are used)
                w[k] = 1;
                for(i = k + 1; i < rows; i++){
                    w[i] = divideScalar(Rdata[i][k], u1);
                }
                // tau = - conj(u1 / alpha)
                var tau = unaryMinus(conj(divideScalar(u1, alpha)));
                var s = void 0;
                /*
         * tau and w have been choosen so that
         *
         * 2 * v * tranpose(v) = tau * w * tranpose(w)
         */ /*
         * -- calculate R = R - tau * w * tranpose(w) * R --
         * Only do calculation with rows k to (rows-1)
         * Additionally columns 0 to (k-1) will not be changed by this
         *   multiplication so do not bother recalculating them
         */ for(j = k; j < cols; j++){
                    s = 0.0;
                    // calculate jth element of [tranpose(w) * R]
                    for(i = k; i < rows; i++){
                        s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
                    }
                    // calculate the jth element of [tau * transpose(w) * R]
                    s = multiplyScalar(s, tau);
                    for(i = k; i < rows; i++){
                        Rdata[i][j] = multiplyScalar(subtractScalar(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);
                    }
                }
                /*
         * -- calculate Q = Q - tau * Q * w * transpose(w) --
         * Q is a square matrix (rows x rows)
         * Only do calculation with columns k to (rows-1)
         * Additionally rows 0 to (k-1) will not be changed by this
         *   multiplication so do not bother recalculating them
         */ for(i = 0; i < rows; i++){
                    s = 0.0;
                    // calculate ith element of [Q * w]
                    for(j = k; j < rows; j++){
                        s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
                    }
                    // calculate the ith element of [tau * Q * w]
                    s = multiplyScalar(s, tau);
                    for(j = k; j < rows; ++j){
                        Qdata[i][j] = divideScalar(subtractScalar(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);
                    }
                }
            }
        }
        // return matrices
        return {
            Q,
            R,
            toString: function toString() {
                return 'Q: ' + this.Q.toString() + '\nR: ' + this.R.toString();
            }
        };
    }
    function _denseQR(m) {
        var ret = _denseQRimpl(m);
        var Rdata = ret.R._data;
        if (m._data.length > 0) {
            var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;
            for(var i = 0; i < Rdata.length; ++i){
                for(var j = 0; j < i && j < (Rdata[0] || []).length; ++j){
                    Rdata[i][j] = zero;
                }
            }
        }
        return ret;
    }
    function _sparseQR(m) {
        throw new Error('qr not implemented for sparse matrices yet');
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Permutes a sparse matrix C = P * A * Q
 *
 * @param {SparseMatrix}  a         The Matrix A
 * @param {Array}   pinv            The row permutation vector
 * @param {Array}   q               The column permutation vector
 * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise
 *
 * @return {Matrix}                 C = P * A * Q, null on error
 */ __turbopack_context__.s({
    "csPermute": (()=>csPermute)
});
function csPermute(a, pinv, q, values) {
    // a arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    // rows & columns
    var m = asize[0];
    var n = asize[1];
    // c arrays
    var cvalues = values && a._values ? [] : null;
    var cindex = []; // (aptr[n])
    var cptr = []; // (n + 1)
    // initialize vars
    var nz = 0;
    // loop columns
    for(var k = 0; k < n; k++){
        // column k of C is column q[k] of A
        cptr[k] = nz;
        // apply column permutation
        var j = q ? q[k] : k;
        // loop values in column j of A
        for(var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++){
            // row i of A is row pinv[i] of C
            var r = pinv ? pinv[aindex[t]] : aindex[t];
            // index
            cindex[nz] = r;
            // check we need to populate values
            if (cvalues) {
                cvalues[nz] = avalues[t];
            }
            // increment number of nonzero elements
            nz++;
        }
    }
    // finalize the last column of C
    cptr[n] = nz;
    // return C matrix
    return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [
            m,
            n
        ],
        datatype: adt
    });
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Depth-first search and postorder of a tree rooted at node j
 *
 * @param {Number}  j               The tree node
 * @param {Number}  k
 * @param {Array}   w               The workspace array
 * @param {Number}  head            The index offset within the workspace for the head array
 * @param {Number}  next            The index offset within the workspace for the next array
 * @param {Array}   post            The post ordering array
 * @param {Number}  stack           The index offset within the workspace for the stack array
 */ __turbopack_context__.s({
    "csTdfs": (()=>csTdfs)
});
function csTdfs(j, k, w, head, next, post, stack) {
    // variables
    var top = 0;
    // place j on the stack
    w[stack] = j;
    // while (stack is not empty)
    while(top >= 0){
        // p = top of stack
        var p = w[stack + top];
        // i = youngest child of p
        var i = w[head + p];
        if (i === -1) {
            // p has no unordered children left
            top--;
            // node p is the kth postordered node
            post[k++] = p;
        } else {
            // remove i from children of p
            w[head + p] = w[next + i];
            // increment top
            ++top;
            // start dfs on child node i
            w[stack + top] = i;
        }
    }
    return k;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "csPost": (()=>csPost)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csTdfs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js [app-client] (ecmascript)");
;
function csPost(parent, n) {
    // check inputs
    if (!parent) {
        return null;
    }
    // vars
    var k = 0;
    var j;
    // allocate result
    var post = []; // (n)
    // workspace, head: first n entries, next: next n entries, stack: last n entries
    var w = []; // (3 * n)
    var head = 0;
    var next = n;
    var stack = 2 * n;
    // initialize workspace
    for(j = 0; j < n; j++){
        // empty linked lists
        w[head + j] = -1;
    }
    // traverse nodes in reverse order
    for(j = n - 1; j >= 0; j--){
        // check j is a root
        if (parent[j] === -1) {
            continue;
        }
        // add j to list of its parent
        w[next + j] = w[head + parent[j]];
        w[head + parent[j]] = j;
    }
    // loop nodes
    for(j = 0; j < n; j++){
        // skip j if it is not a root
        if (parent[j] !== -1) {
            continue;
        }
        // depth-first search
        k = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csTdfs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csTdfs"])(j, k, w, head, next, post, stack);
    }
    return post;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Computes the elimination tree of Matrix A (using triu(A)) or the
 * elimination tree of A'A without forming A'A.
 *
 * @param {Matrix}  a               The A Matrix
 * @param {boolean} ata             A value of true the function computes the etree of A'A
 */ __turbopack_context__.s({
    "csEtree": (()=>csEtree)
});
function csEtree(a, ata) {
    // check inputs
    if (!a) {
        return null;
    }
    // a arrays
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    // rows & columns
    var m = asize[0];
    var n = asize[1];
    // allocate result
    var parent = []; // (n)
    // allocate workspace
    var w = []; // (n + (ata ? m : 0))
    var ancestor = 0; // first n entries in w
    var prev = n; // last m entries (ata = true)
    var i, inext;
    // check we are calculating A'A
    if (ata) {
        // initialize workspace
        for(i = 0; i < m; i++){
            w[prev + i] = -1;
        }
    }
    // loop columns
    for(var k = 0; k < n; k++){
        // node k has no parent yet
        parent[k] = -1;
        // nor does k have an ancestor
        w[ancestor + k] = -1;
        // values in column k
        for(var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++){
            // row
            var r = aindex[p];
            // node
            i = ata ? w[prev + r] : r;
            // traverse from i to k
            for(; i !== -1 && i < k; i = inext){
                // inext = ancestor of i
                inext = w[ancestor + i];
                // path compression
                w[ancestor + i] = k;
                // check no anc., parent is k
                if (inext === -1) {
                    parent[i] = k;
                }
            }
            if (ata) {
                w[prev + r] = k;
            }
        }
    }
    return parent;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Keeps entries in the matrix when the callback function returns true, removes the entry otherwise
 *
 * @param {Matrix}   a              The sparse matrix
 * @param {function} callback       The callback function, function will be invoked with the following args:
 *                                    - The entry row
 *                                    - The entry column
 *                                    - The entry value
 *                                    - The state parameter
 * @param {any}      other          The state
 *
 * @return                          The number of nonzero elements in the matrix
 */ __turbopack_context__.s({
    "csFkeep": (()=>csFkeep)
});
function csFkeep(a, callback, other) {
    // a arrays
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    // columns
    var n = asize[1];
    // nonzero items
    var nz = 0;
    // loop columns
    for(var j = 0; j < n; j++){
        // get current location of col j
        var p = aptr[j];
        // record new location of col j
        aptr[j] = nz;
        for(; p < aptr[j + 1]; p++){
            // check we need to keep this item
            if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
                // keep A(i,j)
                aindex[nz] = aindex[p];
                // check we need to process values (pattern only)
                if (avalues) {
                    avalues[nz] = avalues[p];
                }
                // increment nonzero items
                nz++;
            }
        }
    }
    // finalize A
    aptr[n] = nz;
    // trim arrays
    aindex.splice(nz, aindex.length - nz);
    // check we need to process values (pattern only)
    if (avalues) {
        avalues.splice(nz, avalues.length - nz);
    }
    // return number of nonzero items
    return nz;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * This function "flips" its input about the integer -1.
 *
 * @param {Number}  i               The value to flip
 */ __turbopack_context__.s({
    "csFlip": (()=>csFlip)
});
function csFlip(i) {
    // flip the value
    return -i - 2;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "createCsAmd": (()=>createCsAmd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFkeep$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csTdfs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js [app-client] (ecmascript)");
;
;
;
;
var name = 'csAmd';
var dependencies = [
    'add',
    'multiply',
    'transpose'
];
var createCsAmd = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { add, multiply, transpose } = _ref;
    /**
   * Approximate minimum degree ordering. The minimum degree algorithm is a widely used
   * heuristic for finding a permutation P so that P*A*P' has fewer nonzeros in its factorization
   * than A. It is a gready method that selects the sparsest pivot row and column during the course
   * of a right looking sparse Cholesky factorization.
   *
   * @param {Number} order    0: Natural, 1: Cholesky, 2: LU, 3: QR
   * @param {Matrix} m        Sparse Matrix
   */ return function csAmd(order, a) {
        // check input parameters
        if (!a || order <= 0 || order > 3) {
            return null;
        }
        // a matrix arrays
        var asize = a._size;
        // rows and columns
        var m = asize[0];
        var n = asize[1];
        // initialize vars
        var lemax = 0;
        // dense threshold
        var dense = Math.max(16, 10 * Math.sqrt(n));
        dense = Math.min(n - 2, dense);
        // create target matrix C
        var cm = _createTargetMatrix(order, a, m, n, dense);
        // drop diagonal entries
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFkeep$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csFkeep"])(cm, _diag, null);
        // C matrix arrays
        var cindex = cm._index;
        var cptr = cm._ptr;
        // number of nonzero elements in C
        var cnz = cptr[n];
        // allocate result (n+1)
        var P = [];
        // create workspace (8 * (n + 1))
        var W = [];
        var len = 0; // first n + 1 entries
        var nv = n + 1; // next n + 1 entries
        var next = 2 * (n + 1); // next n + 1 entries
        var head = 3 * (n + 1); // next n + 1 entries
        var elen = 4 * (n + 1); // next n + 1 entries
        var degree = 5 * (n + 1); // next n + 1 entries
        var w = 6 * (n + 1); // next n + 1 entries
        var hhead = 7 * (n + 1); // last n + 1 entries
        // use P as workspace for last
        var last = P;
        // initialize quotient graph
        var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
        // initialize degree lists
        var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
        // minimum degree node
        var mindeg = 0;
        // vars
        var i, j, k, k1, k2, e, pj, ln, nvi, pk, eln, p1, p2, pn, h, d;
        // while (selecting pivots) do
        while(nel < n){
            // select node of minimum approximate degree. amd() is now ready to start eliminating the graph. It first
            // finds a node k of minimum degree and removes it from its degree list. The variable nel keeps track of thow
            // many nodes have been eliminated.
            for(k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++);
            if (W[next + k] !== -1) {
                last[W[next + k]] = -1;
            }
            // remove k from degree list
            W[head + mindeg] = W[next + k];
            // elenk = |Ek|
            var elenk = W[elen + k];
            // # of nodes k represents
            var nvk = W[nv + k];
            // W[nv + k] nodes of A eliminated
            nel += nvk;
            // Construct a new element. The new element Lk is constructed in place if |Ek| = 0. nv[i] is
            // negated for all nodes i in Lk to flag them as members of this set. Each node i is removed from the
            // degree lists. All elements e in Ek are absorved into element k.
            var dk = 0;
            // flag k as in Lk
            W[nv + k] = -nvk;
            var p = cptr[k];
            // do in place if W[elen + k] === 0
            var pk1 = elenk === 0 ? p : cnz;
            var pk2 = pk1;
            for(k1 = 1; k1 <= elenk + 1; k1++){
                if (k1 > elenk) {
                    // search the nodes in k
                    e = k;
                    // list of nodes starts at cindex[pj]
                    pj = p;
                    // length of list of nodes in k
                    ln = W[len + k] - elenk;
                } else {
                    // search the nodes in e
                    e = cindex[p++];
                    pj = cptr[e];
                    // length of list of nodes in e
                    ln = W[len + e];
                }
                for(k2 = 1; k2 <= ln; k2++){
                    i = cindex[pj++];
                    // check  node i dead, or seen
                    if ((nvi = W[nv + i]) <= 0) {
                        continue;
                    }
                    // W[degree + Lk] += size of node i
                    dk += nvi;
                    // negate W[nv + i] to denote i in Lk
                    W[nv + i] = -nvi;
                    // place i in Lk
                    cindex[pk2++] = i;
                    if (W[next + i] !== -1) {
                        last[W[next + i]] = last[i];
                    }
                    // check we need to remove i from degree list
                    if (last[i] !== -1) {
                        W[next + last[i]] = W[next + i];
                    } else {
                        W[head + W[degree + i]] = W[next + i];
                    }
                }
                if (e !== k) {
                    // absorb e into k
                    cptr[e] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csFlip"])(k);
                    // e is now a dead element
                    W[w + e] = 0;
                }
            }
            // cindex[cnz...nzmax] is free
            if (elenk !== 0) {
                cnz = pk2;
            }
            // external degree of k - |Lk\i|
            W[degree + k] = dk;
            // element k is in cindex[pk1..pk2-1]
            cptr[k] = pk1;
            W[len + k] = pk2 - pk1;
            // k is now an element
            W[elen + k] = -2;
            // Find set differences. The scan1 function now computes the set differences |Le \ Lk| for all elements e. At the start of the
            // scan, no entry in the w array is greater than or equal to mark.
            // clear w if necessary
            mark = _wclear(mark, lemax, W, w, n);
            // scan 1: find |Le\Lk|
            for(pk = pk1; pk < pk2; pk++){
                i = cindex[pk];
                // check if W[elen + i] empty, skip it
                if ((eln = W[elen + i]) <= 0) {
                    continue;
                }
                // W[nv + i] was negated
                nvi = -W[nv + i];
                var wnvi = mark - nvi;
                // scan Ei
                for(p = cptr[i], p1 = cptr[i] + eln - 1; p <= p1; p++){
                    e = cindex[p];
                    if (W[w + e] >= mark) {
                        // decrement |Le\Lk|
                        W[w + e] -= nvi;
                    } else if (W[w + e] !== 0) {
                        // ensure e is a live element, 1st time e seen in scan 1
                        W[w + e] = W[degree + e] + wnvi;
                    }
                }
            }
            // degree update
            // The second pass computes the approximate degree di, prunes the sets Ei and Ai, and computes a hash
            // function h(i) for all nodes in Lk.
            // scan2: degree update
            for(pk = pk1; pk < pk2; pk++){
                // consider node i in Lk
                i = cindex[pk];
                p1 = cptr[i];
                p2 = p1 + W[elen + i] - 1;
                pn = p1;
                // scan Ei
                for(h = 0, d = 0, p = p1; p <= p2; p++){
                    e = cindex[p];
                    // check e is an unabsorbed element
                    if (W[w + e] !== 0) {
                        // dext = |Le\Lk|
                        var dext = W[w + e] - mark;
                        if (dext > 0) {
                            // sum up the set differences
                            d += dext;
                            // keep e in Ei
                            cindex[pn++] = e;
                            // compute the hash of node i
                            h += e;
                        } else {
                            // aggressive absorb. e->k
                            cptr[e] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csFlip"])(k);
                            // e is a dead element
                            W[w + e] = 0;
                        }
                    }
                }
                // W[elen + i] = |Ei|
                W[elen + i] = pn - p1 + 1;
                var p3 = pn;
                var p4 = p1 + W[len + i];
                // prune edges in Ai
                for(p = p2 + 1; p < p4; p++){
                    j = cindex[p];
                    // check node j dead or in Lk
                    var nvj = W[nv + j];
                    if (nvj <= 0) {
                        continue;
                    }
                    // degree(i) += |j|
                    d += nvj;
                    // place j in node list of i
                    cindex[pn++] = j;
                    // compute hash for node i
                    h += j;
                }
                // check for mass elimination
                if (d === 0) {
                    // absorb i into k
                    cptr[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csFlip"])(k);
                    nvi = -W[nv + i];
                    // |Lk| -= |i|
                    dk -= nvi;
                    // |k| += W[nv + i]
                    nvk += nvi;
                    nel += nvi;
                    W[nv + i] = 0;
                    // node i is dead
                    W[elen + i] = -1;
                } else {
                    // update degree(i)
                    W[degree + i] = Math.min(W[degree + i], d);
                    // move first node to end
                    cindex[pn] = cindex[p3];
                    // move 1st el. to end of Ei
                    cindex[p3] = cindex[p1];
                    // add k as 1st element in of Ei
                    cindex[p1] = k;
                    // new len of adj. list of node i
                    W[len + i] = pn - p1 + 1;
                    // finalize hash of i
                    h = (h < 0 ? -h : h) % n;
                    // place i in hash bucket
                    W[next + i] = W[hhead + h];
                    W[hhead + h] = i;
                    // save hash of i in last[i]
                    last[i] = h;
                }
            }
            // finalize |Lk|
            W[degree + k] = dk;
            lemax = Math.max(lemax, dk);
            // clear w
            mark = _wclear(mark + lemax, lemax, W, w, n);
            // Supernode detection. Supernode detection relies on the hash function h(i) computed for each node i.
            // If two nodes have identical adjacency lists, their hash functions wil be identical.
            for(pk = pk1; pk < pk2; pk++){
                i = cindex[pk];
                // check i is dead, skip it
                if (W[nv + i] >= 0) {
                    continue;
                }
                // scan hash bucket of node i
                h = last[i];
                i = W[hhead + h];
                // hash bucket will be empty
                W[hhead + h] = -1;
                for(; i !== -1 && W[next + i] !== -1; i = W[next + i], mark++){
                    ln = W[len + i];
                    eln = W[elen + i];
                    for(p = cptr[i] + 1; p <= cptr[i] + ln - 1; p++){
                        W[w + cindex[p]] = mark;
                    }
                    var jlast = i;
                    // compare i with all j
                    for(j = W[next + i]; j !== -1;){
                        var ok = W[len + j] === ln && W[elen + j] === eln;
                        for(p = cptr[j] + 1; ok && p <= cptr[j] + ln - 1; p++){
                            // compare i and j
                            if (W[w + cindex[p]] !== mark) {
                                ok = 0;
                            }
                        }
                        // check i and j are identical
                        if (ok) {
                            // absorb j into i
                            cptr[j] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csFlip"])(i);
                            W[nv + i] += W[nv + j];
                            W[nv + j] = 0;
                            // node j is dead
                            W[elen + j] = -1;
                            // delete j from hash bucket
                            j = W[next + j];
                            W[next + jlast] = j;
                        } else {
                            // j and i are different
                            jlast = j;
                            j = W[next + j];
                        }
                    }
                }
            }
            // Finalize new element. The elimination of node k is nearly complete. All nodes i in Lk are scanned one last time.
            // Node i is removed from Lk if it is dead. The flagged status of nv[i] is cleared.
            for(p = pk1, pk = pk1; pk < pk2; pk++){
                i = cindex[pk];
                // check  i is dead, skip it
                if ((nvi = -W[nv + i]) <= 0) {
                    continue;
                }
                // restore W[nv + i]
                W[nv + i] = nvi;
                // compute external degree(i)
                d = W[degree + i] + dk - nvi;
                d = Math.min(d, n - nel - nvi);
                if (W[head + d] !== -1) {
                    last[W[head + d]] = i;
                }
                // put i back in degree list
                W[next + i] = W[head + d];
                last[i] = -1;
                W[head + d] = i;
                // find new minimum degree
                mindeg = Math.min(mindeg, d);
                W[degree + i] = d;
                // place i in Lk
                cindex[p++] = i;
            }
            // # nodes absorbed into k
            W[nv + k] = nvk;
            // length of adj list of element k
            if ((W[len + k] = p - pk1) === 0) {
                // k is a root of the tree
                cptr[k] = -1;
                // k is now a dead element
                W[w + k] = 0;
            }
            if (elenk !== 0) {
                // free unused space in Lk
                cnz = p;
            }
        }
        // Postordering. The elimination is complete, but no permutation has been computed. All that is left
        // of the graph is the assembly tree (ptr) and a set of dead nodes and elements (i is a dead node if
        // nv[i] is zero and a dead element if nv[i] > 0). It is from this information only that the final permutation
        // is computed. The tree is restored by unflipping all of ptr.
        // fix assembly tree
        for(i = 0; i < n; i++){
            cptr[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csFlip"])(cptr[i]);
        }
        for(j = 0; j <= n; j++){
            W[head + j] = -1;
        }
        // place unordered nodes in lists
        for(j = n; j >= 0; j--){
            // skip if j is an element
            if (W[nv + j] > 0) {
                continue;
            }
            // place j in list of its parent
            W[next + j] = W[head + cptr[j]];
            W[head + cptr[j]] = j;
        }
        // place elements in lists
        for(e = n; e >= 0; e--){
            // skip unless e is an element
            if (W[nv + e] <= 0) {
                continue;
            }
            if (cptr[e] !== -1) {
                // place e in list of its parent
                W[next + e] = W[head + cptr[e]];
                W[head + cptr[e]] = e;
            }
        }
        // postorder the assembly tree
        for(k = 0, i = 0; i <= n; i++){
            if (cptr[i] === -1) {
                k = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csTdfs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csTdfs"])(i, k, W, head, next, P, w);
            }
        }
        // remove last item in array
        P.splice(P.length - 1, 1);
        // return P
        return P;
    };
    "TURBOPACK unreachable";
    /**
   * Creates the matrix that will be used by the approximate minimum degree ordering algorithm. The function accepts the matrix M as input and returns a permutation
   * vector P. The amd algorithm operates on a symmetrix matrix, so one of three symmetric matrices is formed.
   *
   * Order: 0
   *   A natural ordering P=null matrix is returned.
   *
   * Order: 1
   *   Matrix must be square. This is appropriate for a Cholesky or LU factorization.
   *   P = M + M'
   *
   * Order: 2
   *   Dense columns from M' are dropped, M recreated from M'. This is appropriatefor LU factorization of unsymmetric matrices.
   *   P = M' * M
   *
   * Order: 3
   *   This is best used for QR factorization or LU factorization is matrix M has no dense rows. A dense row is a row with more than 10*sqr(columns) entries.
   *   P = M' * M
   */ function _createTargetMatrix(order, a, m, n, dense) {
        // compute A'
        var at = transpose(a);
        // check order = 1, matrix must be square
        if (order === 1 && n === m) {
            // C = A + A'
            return add(a, at);
        }
        // check order = 2, drop dense columns from M'
        if (order === 2) {
            // transpose arrays
            var tindex = at._index;
            var tptr = at._ptr;
            // new column index
            var p2 = 0;
            // loop A' columns (rows)
            for(var j = 0; j < m; j++){
                // column j of AT starts here
                var p = tptr[j];
                // new column j starts here
                tptr[j] = p2;
                // skip dense col j
                if (tptr[j + 1] - p > dense) {
                    continue;
                }
                // map rows in column j of A
                for(var p1 = tptr[j + 1]; p < p1; p++){
                    tindex[p2++] = tindex[p];
                }
            }
            // finalize AT
            tptr[m] = p2;
            // recreate A from new transpose matrix
            a = transpose(at);
            // use A' * A
            return multiply(at, a);
        }
        // use A' * A, square or rectangular matrix
        return multiply(at, a);
    }
    /**
   * Initialize quotient graph. There are four kind of nodes and elements that must be represented:
   *
   *  - A live node is a node i (or a supernode) that has not been selected as a pivot nad has not been merged into another supernode.
   *  - A dead node i is one that has been removed from the graph, having been absorved into r = flip(ptr[i]).
   *  - A live element e is one that is in the graph, having been formed when node e was selected as the pivot.
   *  - A dead element e is one that has benn absorved into a subsequent element s = flip(ptr[e]).
   */ function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
        // Initialize quotient graph
        for(var k = 0; k < n; k++){
            W[len + k] = cptr[k + 1] - cptr[k];
        }
        W[len + n] = 0;
        // initialize workspace
        for(var i = 0; i <= n; i++){
            // degree list i is empty
            W[head + i] = -1;
            last[i] = -1;
            W[next + i] = -1;
            // hash list i is empty
            W[hhead + i] = -1;
            // node i is just one node
            W[nv + i] = 1;
            // node i is alive
            W[w + i] = 1;
            // Ek of node i is empty
            W[elen + i] = 0;
            // degree of node i
            W[degree + i] = W[len + i];
        }
        // clear w
        var mark = _wclear(0, 0, W, w, n);
        // n is a dead element
        W[elen + n] = -2;
        // n is a root of assembly tree
        cptr[n] = -1;
        // n is a dead element
        W[w + n] = 0;
        // return mark
        return mark;
    }
    /**
   * Initialize degree lists. Each node is placed in its degree lists. Nodes of zero degree are eliminated immediately. Nodes with
   * degree >= dense are alsol eliminated and merged into a placeholder node n, a dead element. Thes nodes will appera last in the
   * output permutation p.
   */ function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
        // result
        var nel = 0;
        // loop columns
        for(var i = 0; i < n; i++){
            // degree @ i
            var d = W[degree + i];
            // check node i is empty
            if (d === 0) {
                // element i is dead
                W[elen + i] = -2;
                nel++;
                // i is a root of assembly tree
                cptr[i] = -1;
                W[w + i] = 0;
            } else if (d > dense) {
                // absorb i into element n
                W[nv + i] = 0;
                // node i is dead
                W[elen + i] = -1;
                nel++;
                cptr[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csFlip"])(n);
                W[nv + n]++;
            } else {
                var h = W[head + d];
                if (h !== -1) {
                    last[h] = i;
                }
                // put node i in degree list d
                W[next + i] = W[head + d];
                W[head + d] = i;
            }
        }
        return nel;
    }
    function _wclear(mark, lemax, W, w, n) {
        if (mark < 2 || mark + lemax < 0) {
            for(var k = 0; k < n; k++){
                if (W[w + k] !== 0) {
                    W[w + k] = 1;
                }
            }
            mark = 2;
        }
        // at this point, W [0..n-1] < mark holds
        return mark;
    }
    function _diag(i, j) {
        return i !== j;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * This function determines if j is a leaf of the ith row subtree.
 * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)
 *
 * @param {Number}  i               The ith row subtree
 * @param {Number}  j               The node to test
 * @param {Array}   w               The workspace array
 * @param {Number}  first           The index offset within the workspace for the first array
 * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array
 * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array
 * @param {Number}  ancestor        The index offset within the workspace for the ancestor array
 *
 * @return {Object}
 */ __turbopack_context__.s({
    "csLeaf": (()=>csLeaf)
});
function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {
    var s, sparent;
    // our result
    var jleaf = 0;
    var q;
    // check j is a leaf
    if (i <= j || w[first + j] <= w[maxfirst + i]) {
        return -1;
    }
    // update max first[j] seen so far
    w[maxfirst + i] = w[first + j];
    // jprev = previous leaf of ith subtree
    var jprev = w[prevleaf + i];
    w[prevleaf + i] = j;
    // check j is first or subsequent leaf
    if (jprev === -1) {
        // 1st leaf, q = root of ith subtree
        jleaf = 1;
        q = i;
    } else {
        // update jleaf
        jleaf = 2;
        // q = least common ancester (jprev,j)
        for(q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]);
        for(s = jprev; s !== q; s = sparent){
            // path compression
            sparent = w[ancestor + s];
            w[ancestor + s] = q;
        }
    }
    return {
        jleaf,
        q
    };
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "createCsCounts": (()=>createCsCounts)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csLeaf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js [app-client] (ecmascript)");
;
;
var name = 'csCounts';
var dependencies = [
    'transpose'
];
var createCsCounts = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { transpose } = _ref;
    /**
   * Computes the column counts using the upper triangular part of A.
   * It transposes A internally, none of the input parameters are modified.
   *
   * @param {Matrix} a           The sparse matrix A
   *
   * @param {Matrix} ata         Count the columns of A'A instead
   *
   * @return                     An array of size n of the column counts or null on error
   */ return function(a, parent, post, ata) {
        // check inputs
        if (!a || !parent || !post) {
            return null;
        }
        // a matrix arrays
        var asize = a._size;
        // rows and columns
        var m = asize[0];
        var n = asize[1];
        // variables
        var i, j, k, J, p, p0, p1;
        // workspace size
        var s = 4 * n + (ata ? n + m + 1 : 0);
        // allocate workspace
        var w = []; // (s)
        var ancestor = 0; // first n entries
        var maxfirst = n; // next n entries
        var prevleaf = 2 * n; // next n entries
        var first = 3 * n; // next n entries
        var head = 4 * n; // next n + 1 entries (used when ata is true)
        var next = 5 * n + 1; // last entries in workspace
        // clear workspace w[0..s-1]
        for(k = 0; k < s; k++){
            w[k] = -1;
        }
        // allocate result
        var colcount = []; // (n)
        // AT = A'
        var at = transpose(a);
        // at arrays
        var tindex = at._index;
        var tptr = at._ptr;
        // find w[first + j]
        for(k = 0; k < n; k++){
            j = post[k];
            // colcount[j]=1 if j is a leaf
            colcount[j] = w[first + j] === -1 ? 1 : 0;
            for(; j !== -1 && w[first + j] === -1; j = parent[j]){
                w[first + j] = k;
            }
        }
        // initialize ata if needed
        if (ata) {
            // invert post
            for(k = 0; k < n; k++){
                w[post[k]] = k;
            }
            // loop rows (columns in AT)
            for(i = 0; i < m; i++){
                // values in column i of AT
                for(k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++){
                    k = Math.min(k, w[tindex[p]]);
                }
                // place row i in linked list k
                w[next + i] = w[head + k];
                w[head + k] = i;
            }
        }
        // each node in its own set
        for(i = 0; i < n; i++){
            w[ancestor + i] = i;
        }
        for(k = 0; k < n; k++){
            // j is the kth node in postordered etree
            j = post[k];
            // check j is not a root
            if (parent[j] !== -1) {
                colcount[parent[j]]--;
            }
            // J=j for LL'=A case
            for(J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1){
                for(p = tptr[J]; p < tptr[J + 1]; p++){
                    i = tindex[p];
                    var r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csLeaf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csLeaf"])(i, j, w, first, maxfirst, prevleaf, ancestor);
                    // check A(i,j) is in skeleton
                    if (r.jleaf >= 1) {
                        colcount[j]++;
                    }
                    // check account for overlap in q
                    if (r.jleaf === 2) {
                        colcount[r.q]--;
                    }
                }
            }
            if (parent[j] !== -1) {
                w[ancestor + j] = parent[j];
            }
        }
        // sum up colcount's of each child
        for(j = 0; j < n; j++){
            if (parent[j] !== -1) {
                colcount[parent[j]] += colcount[j];
            }
        }
        return colcount;
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "createCsSqr": (()=>createCsSqr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csPermute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csPost$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csEtree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csAmd$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csCounts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
;
;
;
;
var name = 'csSqr';
var dependencies = [
    'add',
    'multiply',
    'transpose'
];
var createCsSqr = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { add, multiply, transpose } = _ref;
    var csAmd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csAmd$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCsAmd"])({
        add,
        multiply,
        transpose
    });
    var csCounts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csCounts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCsCounts"])({
        transpose
    });
    /**
   * Symbolic ordering and analysis for QR and LU decompositions.
   *
   * @param {Number}  order           The ordering strategy (see csAmd for more details)
   * @param {Matrix}  a               The A matrix
   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or
   *                                  symbolic ordering and analysis for LU decomposition (false)
   *
   * @return {Object}                 The Symbolic ordering and analysis for matrix A
   */ return function csSqr(order, a, qr) {
        // a arrays
        var aptr = a._ptr;
        var asize = a._size;
        // columns
        var n = asize[1];
        // vars
        var k;
        // symbolic analysis result
        var s = {};
        // fill-reducing ordering
        s.q = csAmd(order, a);
        // validate results
        if (order && !s.q) {
            return null;
        }
        // QR symbolic analysis
        if (qr) {
            // apply permutations if needed
            var c = order ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csPermute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csPermute"])(a, null, s.q, 0) : a;
            // etree of C'*C, where C=A(:,q)
            s.parent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csEtree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csEtree"])(c, 1);
            // post order elimination tree
            var post = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csPost$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csPost"])(s.parent, n);
            // col counts chol(C'*C)
            s.cp = csCounts(c, s.parent, post, 1);
            // check we have everything needed to calculate number of nonzero elements
            if (c && s.parent && s.cp && _vcount(c, s)) {
                // calculate number of nonzero elements
                for(s.unz = 0, k = 0; k < n; k++){
                    s.unz += s.cp[k];
                }
            }
        } else {
            // for LU factorization only, guess nnz(L) and nnz(U)
            s.unz = 4 * aptr[n] + n;
            s.lnz = s.unz;
        }
        // return result S
        return s;
    };
    "TURBOPACK unreachable";
    /**
   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent
   */ function _vcount(a, s) {
        // a arrays
        var aptr = a._ptr;
        var aindex = a._index;
        var asize = a._size;
        // rows & columns
        var m = asize[0];
        var n = asize[1];
        // initialize s arrays
        s.pinv = []; // (m + n)
        s.leftmost = []; // (m)
        // vars
        var parent = s.parent;
        var pinv = s.pinv;
        var leftmost = s.leftmost;
        // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries
        var w = []; // (m + 3 * n)
        var next = 0;
        var head = m;
        var tail = m + n;
        var nque = m + 2 * n;
        // vars
        var i, k, p, p0, p1;
        // initialize w
        for(k = 0; k < n; k++){
            // queue k is empty
            w[head + k] = -1;
            w[tail + k] = -1;
            w[nque + k] = 0;
        }
        // initialize row arrays
        for(i = 0; i < m; i++){
            leftmost[i] = -1;
        }
        // loop columns backwards
        for(k = n - 1; k >= 0; k--){
            // values & index for column k
            for(p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++){
                // leftmost[i] = min(find(A(i,:)))
                leftmost[aindex[p]] = k;
            }
        }
        // scan rows in reverse order
        for(i = m - 1; i >= 0; i--){
            // row i is not yet ordered
            pinv[i] = -1;
            k = leftmost[i];
            // check row i is empty
            if (k === -1) {
                continue;
            }
            // first row in queue k
            if (w[nque + k]++ === 0) {
                w[tail + k] = i;
            }
            // put i at head of queue k
            w[next + i] = w[head + k];
            w[head + k] = i;
        }
        s.lnz = 0;
        s.m2 = m;
        // find row permutation and nnz(V)
        for(k = 0; k < n; k++){
            // remove row i from queue k
            i = w[head + k];
            // count V(k,k) as nonzero
            s.lnz++;
            // add a fictitious row
            if (i < 0) {
                i = s.m2++;
            }
            // associate row i with V(:,k)
            pinv[i] = k;
            // skip if V(k+1:m,k) is empty
            if (--nque[k] <= 0) {
                continue;
            }
            // nque[k] is nnz (V(k+1:m,k))
            s.lnz += w[nque + k];
            // move all rows to parent of k
            var pa = parent[k];
            if (pa !== -1) {
                if (w[nque + pa] === 0) {
                    w[tail + pa] = w[tail + k];
                }
                w[next + w[tail + k]] = w[head + pa];
                w[head + pa] = w[next + i];
                w[nque + pa] += w[nque + k];
            }
        }
        for(i = 0; i < m; i++){
            if (pinv[i] < 0) {
                pinv[i] = k++;
            }
        }
        return true;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Checks if the node at w[j] is marked
 *
 * @param {Array}   w               The array
 * @param {Number}  j               The array index
 */ __turbopack_context__.s({
    "csMarked": (()=>csMarked)
});
function csMarked(w, j) {
    // check node is marked
    return w[j] < 0;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "csMark": (()=>csMark)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js [app-client] (ecmascript)");
;
function csMark(w, j) {
    // mark w[j]
    w[j] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csFlip"])(w[j]);
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "csUnflip": (()=>csUnflip)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js [app-client] (ecmascript)");
;
function csUnflip(i) {
    // flip the value if it is negative
    return i < 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csFlip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csFlip"])(i) : i;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "csDfs": (()=>csDfs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMarked$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMark$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csUnflip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js [app-client] (ecmascript)");
;
;
;
function csDfs(j, g, top, xi, pinv) {
    // g arrays
    var index = g._index;
    var ptr = g._ptr;
    var size = g._size;
    // columns
    var n = size[1];
    // vars
    var i, p, p2;
    // initialize head
    var head = 0;
    // initialize the recursion stack
    xi[0] = j;
    // loop
    while(head >= 0){
        // get j from the top of the recursion stack
        j = xi[head];
        // apply permutation vector
        var jnew = pinv ? pinv[j] : j;
        // check node j is marked
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMarked$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csMarked"])(ptr, j)) {
            // mark node j as visited
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMark$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csMark"])(ptr, j);
            // update stack (last n entries in xi)
            xi[n + head] = jnew < 0 ? 0 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csUnflip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csUnflip"])(ptr[jnew]);
        }
        // node j done if no unvisited neighbors
        var done = 1;
        // examine all neighbors of j, stack (last n entries in xi)
        for(p = xi[n + head], p2 = jnew < 0 ? 0 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csUnflip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csUnflip"])(ptr[jnew + 1]); p < p2; p++){
            // consider neighbor node i
            i = index[p];
            // check we have visited node i, skip it
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMarked$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csMarked"])(ptr, i)) {
                continue;
            }
            // pause depth-first search of node j, update stack (last n entries in xi)
            xi[n + head] = p;
            // start dfs at node i
            xi[++head] = i;
            // node j is not done
            done = 0;
            break;
        }
        // check depth-first search at node j is done
        if (done) {
            // remove j from the recursion stack
            head--;
            // and place in the output stack
            xi[--top] = j;
        }
    }
    return top;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "csReach": (()=>csReach)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMarked$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMark$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csDfs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js [app-client] (ecmascript)");
;
;
;
function csReach(g, b, k, xi, pinv) {
    // g arrays
    var gptr = g._ptr;
    var gsize = g._size;
    // b arrays
    var bindex = b._index;
    var bptr = b._ptr;
    // columns
    var n = gsize[1];
    // vars
    var p, p0, p1;
    // initialize top
    var top = n;
    // loop column indeces in B
    for(p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++){
        // node i
        var i = bindex[p];
        // check node i is marked
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMarked$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csMarked"])(gptr, i)) {
            // start a dfs at unmarked node i
            top = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csDfs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csDfs"])(i, g, top, xi, pinv);
        }
    }
    // loop columns from top -> n - 1
    for(p = top; p < n; p++){
        // restore G
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csMark$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csMark"])(gptr, xi[p]);
    }
    return top;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "createCsSpsolve": (()=>createCsSpsolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csReach$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
var name = 'csSpsolve';
var dependencies = [
    'divideScalar',
    'multiply',
    'subtract'
];
var createCsSpsolve = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { divideScalar, multiply, subtract } = _ref;
    /**
   * The function csSpsolve() computes the solution to G * x = bk, where bk is the
   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the
   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U
   * is upper triangular with the diagonal entry as the last entry in each column.
   *
   * @param {Matrix}  g               The G matrix
   * @param {Matrix}  b               The B matrix
   * @param {Number}  k               The kth column in B
   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n
   *                                  The first n entries is the nonzero pattern, the last n entries is the stack
   * @param {Array}   x               The soluton to the linear system G * x = b
   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b
   * @param {boolean} lo              The lower (true) upper triangular (false) flag
   *
   * @return {Number}                 The index for the nonzero pattern
   */ return function csSpsolve(g, b, k, xi, x, pinv, lo) {
        // g arrays
        var gvalues = g._values;
        var gindex = g._index;
        var gptr = g._ptr;
        var gsize = g._size;
        // columns
        var n = gsize[1];
        // b arrays
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        // vars
        var p, p0, p1, q;
        // xi[top..n-1] = csReach(B(:,k))
        var top = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csReach$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csReach"])(g, b, k, xi, pinv);
        // clear x
        for(p = top; p < n; p++){
            x[xi[p]] = 0;
        }
        // scatter b
        for(p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++){
            x[bindex[p]] = bvalues[p];
        }
        // loop columns
        for(var px = top; px < n; px++){
            // x array index for px
            var j = xi[px];
            // apply permutation vector (U x = b), j maps to column J of G
            var J = pinv ? pinv[j] : j;
            // check column J is empty
            if (J < 0) {
                continue;
            }
            // column value indeces in G, p0 <= p < p1
            p0 = gptr[J];
            p1 = gptr[J + 1];
            // x(j) /= G(j,j)
            x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]);
            // first entry L(j,j)
            p = lo ? p0 + 1 : p0;
            q = lo ? p1 : p1 - 1;
            // loop
            for(; p < q; p++){
                // row
                var i = gindex[p];
                // x(i) -= G(i,j) * x(j)
                x[i] = subtract(x[i], multiply(gvalues[p], x[j]));
            }
        }
        // return top of stack
        return top;
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
__turbopack_context__.s({
    "createCsLu": (()=>createCsLu)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csSpsolve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js [app-client] (ecmascript)");
;
;
var name = 'csLu';
var dependencies = [
    'abs',
    'divideScalar',
    'multiply',
    'subtract',
    'larger',
    'largerEq',
    'SparseMatrix'
];
var createCsLu = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { abs, divideScalar, multiply, subtract, larger, largerEq, SparseMatrix } = _ref;
    var csSpsolve = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csSpsolve$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCsSpsolve"])({
        divideScalar,
        multiply,
        subtract
    });
    /**
   * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization
   * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L
   * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so
   * L * U = A(p, q), where p is the inverse of pinv.
   *
   * @param {Matrix}  m               The A Matrix to factorize
   * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing
   *                                  column ordering q
   * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)
   *
   * @return {Number}                 The numeric LU factorization of A or null
   */ return function csLu(m, s, tol) {
        // validate input
        if (!m) {
            return null;
        }
        // m arrays
        var size = m._size;
        // columns
        var n = size[1];
        // symbolic analysis result
        var q;
        var lnz = 100;
        var unz = 100;
        // update symbolic analysis parameters
        if (s) {
            q = s.q;
            lnz = s.lnz || lnz;
            unz = s.unz || unz;
        }
        // L arrays
        var lvalues = []; // (lnz)
        var lindex = []; // (lnz)
        var lptr = []; // (n + 1)
        // L
        var L = new SparseMatrix({
            values: lvalues,
            index: lindex,
            ptr: lptr,
            size: [
                n,
                n
            ]
        });
        // U arrays
        var uvalues = []; // (unz)
        var uindex = []; // (unz)
        var uptr = []; // (n + 1)
        // U
        var U = new SparseMatrix({
            values: uvalues,
            index: uindex,
            ptr: uptr,
            size: [
                n,
                n
            ]
        });
        // inverse of permutation vector
        var pinv = []; // (n)
        // vars
        var i, p;
        // allocate arrays
        var x = []; // (n)
        var xi = []; // (2 * n)
        // initialize variables
        for(i = 0; i < n; i++){
            // clear workspace
            x[i] = 0;
            // no rows pivotal yet
            pinv[i] = -1;
            // no cols of L yet
            lptr[i + 1] = 0;
        }
        // reset number of nonzero elements in L and U
        lnz = 0;
        unz = 0;
        // compute L(:,k) and U(:,k)
        for(var k = 0; k < n; k++){
            // update ptr
            lptr[k] = lnz;
            uptr[k] = unz;
            // apply column permutations if needed
            var col = q ? q[k] : k;
            // solve triangular system, x = L\A(:,col)
            var top = csSpsolve(L, m, col, xi, x, pinv, 1);
            // find pivot
            var ipiv = -1;
            var a = -1;
            // loop xi[] from top -> n
            for(p = top; p < n; p++){
                // x[i] is nonzero
                i = xi[p];
                // check row i is not yet pivotal
                if (pinv[i] < 0) {
                    // absolute value of x[i]
                    var xabs = abs(x[i]);
                    // check absoulte value is greater than pivot value
                    if (larger(xabs, a)) {
                        // largest pivot candidate so far
                        a = xabs;
                        ipiv = i;
                    }
                } else {
                    // x(i) is the entry U(pinv[i],k)
                    uindex[unz] = pinv[i];
                    uvalues[unz++] = x[i];
                }
            }
            // validate we found a valid pivot
            if (ipiv === -1 || a <= 0) {
                return null;
            }
            // update actual pivot column, give preference to diagonal value
            if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {
                ipiv = col;
            }
            // the chosen pivot
            var pivot = x[ipiv];
            // last entry in U(:,k) is U(k,k)
            uindex[unz] = k;
            uvalues[unz++] = pivot;
            // ipiv is the kth pivot row
            pinv[ipiv] = k;
            // first entry in L(:,k) is L(k,k) = 1
            lindex[lnz] = ipiv;
            lvalues[lnz++] = 1;
            // L(k+1:n,k) = x / pivot
            for(p = top; p < n; p++){
                // row
                i = xi[p];
                // check x(i) is an entry in L(:,k)
                if (pinv[i] < 0) {
                    // save unpermuted row in L
                    lindex[lnz] = i;
                    // scale pivot column
                    lvalues[lnz++] = divideScalar(x[i], pivot);
                }
                // x[0..n-1] = 0 for next k
                x[i] = 0;
            }
        }
        // update ptr
        lptr[n] = lnz;
        uptr[n] = unz;
        // fix row indices of L for final pinv
        for(p = 0; p < lnz; p++){
            lindex[p] = pinv[lindex[p]];
        }
        // trim arrays
        lvalues.splice(lnz, lvalues.length - lnz);
        lindex.splice(lnz, lindex.length - lnz);
        uvalues.splice(unz, uvalues.length - unz);
        uindex.splice(unz, uindex.length - unz);
        // return LU factor
        return {
            L,
            U,
            pinv
        };
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSlu": (()=>createSlu)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csSqr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csLu$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js [app-client] (ecmascript)");
;
;
;
;
var name = 'slu';
var dependencies = [
    'typed',
    'abs',
    'add',
    'multiply',
    'transpose',
    'divideScalar',
    'subtract',
    'larger',
    'largerEq',
    'SparseMatrix'
];
var createSlu = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, abs, add, multiply, transpose, divideScalar, subtract, larger, largerEq, SparseMatrix } = _ref;
    var csSqr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csSqr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCsSqr"])({
        add,
        multiply,
        transpose
    });
    var csLu = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csLu$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCsLu"])({
        abs,
        divideScalar,
        multiply,
        subtract,
        larger,
        largerEq,
        SparseMatrix
    });
    /**
   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where
   *
   * `P * A * Q = L * U`
   *
   * Syntax:
   *
   *    math.slu(A, order, threshold)
   *
   * Examples:
   *
   *    const A = math.sparse([[4,3], [6, 3]])
   *    math.slu(A, 1, 0.001)
   *    // returns:
   *    // {
   *    //   L: [[1, 0], [1.5, 1]]
   *    //   U: [[4, 3], [0, -1.5]]
   *    //   p: [0, 1]
   *    //   q: [0, 1]
   *    // }
   *
   * See also:
   *
   *    lup, lsolve, usolve, lusolve
   *
   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.
   * @param {Number}       order          The Symbolic Ordering and Analysis order:
   *                                       0 - Natural ordering, no permutation vector q is returned
   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'
   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.
   *                                           This is appropriatefor LU factorization of unsymmetric matrices.
   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.
   *                                           A dense row is a row with more than 10*sqr(columns) entries.
   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)
   *
   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.
   */ return typed(name, {
        'SparseMatrix, number, number': function SparseMatrix_number_number(a, order, threshold) {
            // verify order
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(order) || order < 0 || order > 3) {
                throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');
            }
            // verify threshold
            if (threshold < 0 || threshold > 1) {
                throw new Error('Partial pivoting threshold must be a number from 0 to 1');
            }
            // perform symbolic ordering and analysis
            var s = csSqr(order, a, false);
            // perform lu decomposition
            var f = csLu(a, s, threshold);
            // return decomposition
            return {
                L: f.L,
                U: f.U,
                p: f.pinv,
                q: s.q,
                toString: function toString() {
                    return 'L: ' + this.L.toString() + '\nU: ' + this.U.toString() + '\np: ' + this.p.toString() + (this.q ? '\nq: ' + this.q.toString() : '') + '\n';
                }
            };
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.
// SPDX-License-Identifier: LGPL-2.1+
// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source
/**
 * Permutes a vector; x = P'b. In MATLAB notation, x(p)=b.
 *
 * @param {Array} p           The permutation vector of length n. null value denotes identity
 * @param {Array} b           The input vector
 *
 * @return {Array}            The output vector x = P'b
 */ __turbopack_context__.s({
    "csIpvec": (()=>csIpvec)
});
function csIpvec(p, b) {
    // vars
    var k;
    var n = b.length;
    var x = [];
    // check permutation vector was provided, p = null denotes identity
    if (p) {
        // loop vector
        for(k = 0; k < n; k++){
            // apply permutation
            x[p[k]] = b[k];
        }
    } else {
        // loop vector
        for(k = 0; k < n; k++){
            // x[i] = b[i]
            x[k] = b[k];
        }
    }
    return x;
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLusolve": (()=>createLusolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csIpvec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js [app-client] (ecmascript)");
;
;
;
;
var name = 'lusolve';
var dependencies = [
    'typed',
    'matrix',
    'lup',
    'slu',
    'usolve',
    'lsolve',
    'DenseMatrix'
];
var createLusolve = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, lup, slu, usolve, lsolve, DenseMatrix } = _ref;
    var solveValidation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$solver$2f$utils$2f$solveValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSolveValidation"])({
        DenseMatrix
    });
    /**
   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.
   *
   * Syntax:
   *
   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b
   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)
   *
   * Examples:
   *
   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]
   *
   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]
   *
   *    const f = math.lup(m)
   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]
   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]
   *
   *    const a = [[-2, 3], [2, 1]]
   *    const b = [11, 9]
   *    const x = math.lusolve(a, b)  // [[2], [5]]
   *
   * See also:
   *
   *    lup, slu, lsolve, usolve
   *
   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition
   * @param {Matrix | Array} b               Column Vector
   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix
   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.
   *
   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b
   */ return typed(name, {
        'Array, Array | Matrix': function Array_Array__Matrix(a, b) {
            a = matrix(a);
            var d = lup(a);
            var x = _lusolve(d.L, d.U, d.p, null, b);
            return x.valueOf();
        },
        'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(a, b) {
            var d = lup(a);
            return _lusolve(d.L, d.U, d.p, null, b);
        },
        'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(a, b) {
            var d = lup(a);
            return _lusolve(d.L, d.U, d.p, null, b);
        },
        'SparseMatrix, Array | Matrix, number, number': function SparseMatrix_Array__Matrix_number_number(a, b, order, threshold) {
            var d = slu(a, order, threshold);
            return _lusolve(d.L, d.U, d.p, d.q, b);
        },
        'Object, Array | Matrix': function Object_Array__Matrix(d, b) {
            return _lusolve(d.L, d.U, d.p, d.q, b);
        }
    });
    "TURBOPACK unreachable";
    function _toMatrix(a) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(a)) {
            return a;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(a)) {
            return matrix(a);
        }
        throw new TypeError('Invalid Matrix LU decomposition');
    }
    function _lusolve(l, u, p, q, b) {
        // verify decomposition
        l = _toMatrix(l);
        u = _toMatrix(u);
        // apply row permutations if needed (b is a DenseMatrix)
        if (p) {
            b = solveValidation(l, b, true);
            b._data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csIpvec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csIpvec"])(p, b._data);
        }
        // use forward substitution to resolve L * y = b
        var y = lsolve(l, b);
        // use backward substitution to resolve U * x = y
        var x = usolve(u, y);
        // apply column permutations if needed (x is a DenseMatrix)
        if (q) {
            x._data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$sparse$2f$csIpvec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["csIpvec"])(q, x._data);
        }
        return x;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createPolynomialRoot": (()=>createPolynomialRoot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'polynomialRoot';
var dependencies = [
    'typed',
    'isZero',
    'equalScalar',
    'add',
    'subtract',
    'multiply',
    'divide',
    'sqrt',
    'unaryMinus',
    'cbrt',
    'typeOf',
    'im',
    're'
];
var createPolynomialRoot = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, isZero, equalScalar, add, subtract, multiply, divide, sqrt, unaryMinus, cbrt, typeOf, im, re } = _ref;
    /**
   * Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.
   * Currently operates only on linear, quadratic, and cubic polynomials using the standard
   * formulas for the roots.
   *
   * Syntax:
   *
   *     math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)
   *
   * Examples:
   *     // linear
   *     math.polynomialRoot(6, 3)                                        // [-2]
   *     math.polynomialRoot(math.complex(6,3), 3)                        // [-2 - i]
   *     math.polynomialRoot(math.complex(6,3), math.complex(2,1))        // [-3 + 0i]
   *     // quadratic
   *     math.polynomialRoot(2, -3, 1)                                    // [2, 1]
   *     math.polynomialRoot(8, 8, 2)                                     // [-2]
   *     math.polynomialRoot(-2, 0, 1)                                    // [1.4142135623730951, -1.4142135623730951]
   *     math.polynomialRoot(2, -2, 1)                                    // [1 + i, 1 - i]
   *     math.polynomialRoot(math.complex(1,3), math.complex(-3, -2), 1)  // [2 + i, 1 + i]
   *     // cubic
   *     math.polynomialRoot(-6, 11, -6, 1)                               // [1, 3, 2]
   *     math.polynomialRoot(-8, 0, 0, 1)                                 // [-1 - 1.7320508075688774i, 2, -1 + 1.7320508075688774i]
   *     math.polynomialRoot(0, 8, 8, 2)                                  // [0, -2]
   *     math.polynomialRoot(1, 1, 1, 1)                                  // [-1 + 0i, 0 - i, 0 + i]
   *
   * See also:
   *     cbrt, sqrt
   *
   * @param {... number | Complex} coeffs
   *     The coefficients of the polynomial, starting with with the constant coefficent, followed
   *     by the linear coefficient and subsequent coefficients of increasing powers.
   * @return {Array} The distinct roots of the polynomial
   */ return typed(name, {
        'number|Complex, ...number|Complex': (constant, restCoeffs)=>{
            var coeffs = [
                constant,
                ...restCoeffs
            ];
            while(coeffs.length > 0 && isZero(coeffs[coeffs.length - 1])){
                coeffs.pop();
            }
            if (coeffs.length < 2) {
                throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
            }
            switch(coeffs.length){
                case 2:
                    // linear
                    return [
                        unaryMinus(divide(coeffs[0], coeffs[1]))
                    ];
                case 3:
                    {
                        // quadratic
                        var [c, b, a] = coeffs;
                        var denom = multiply(2, a);
                        var d1 = multiply(b, b);
                        var d2 = multiply(4, a, c);
                        if (equalScalar(d1, d2)) return [
                            divide(unaryMinus(b), denom)
                        ];
                        var discriminant = sqrt(subtract(d1, d2));
                        return [
                            divide(subtract(discriminant, b), denom),
                            divide(subtract(unaryMinus(discriminant), b), denom)
                        ];
                    }
                case 4:
                    {
                        // cubic, cf. https://en.wikipedia.org/wiki/Cubic_equation
                        var [d, _c, _b, _a] = coeffs;
                        var _denom = unaryMinus(multiply(3, _a));
                        var D0_1 = multiply(_b, _b);
                        var D0_2 = multiply(3, _a, _c);
                        var D1_1 = add(multiply(2, _b, _b, _b), multiply(27, _a, _a, d));
                        var D1_2 = multiply(9, _a, _b, _c);
                        if (equalScalar(D0_1, D0_2) && equalScalar(D1_1, D1_2)) {
                            return [
                                divide(_b, _denom)
                            ];
                        }
                        var Delta0 = subtract(D0_1, D0_2);
                        var Delta1 = subtract(D1_1, D1_2);
                        var discriminant1 = add(multiply(18, _a, _b, _c, d), multiply(_b, _b, _c, _c));
                        var discriminant2 = add(multiply(4, _b, _b, _b, d), multiply(4, _a, _c, _c, _c), multiply(27, _a, _a, d, d));
                        if (equalScalar(discriminant1, discriminant2)) {
                            return [
                                divide(subtract(multiply(4, _a, _b, _c), add(multiply(9, _a, _a, d), multiply(_b, _b, _b))), multiply(_a, Delta0)),
                                // simple root
                                divide(subtract(multiply(9, _a, d), multiply(_b, _c)), multiply(2, Delta0)) // double root
                            ];
                        }
                        // OK, we have three distinct roots
                        var Ccubed;
                        if (equalScalar(D0_1, D0_2)) {
                            Ccubed = Delta1;
                        } else {
                            Ccubed = divide(add(Delta1, sqrt(subtract(multiply(Delta1, Delta1), multiply(4, Delta0, Delta0, Delta0)))), 2);
                        }
                        var allRoots = true;
                        var rawRoots = cbrt(Ccubed, allRoots).toArray().map((C)=>divide(add(_b, C, divide(Delta0, C)), _denom));
                        return rawRoots.map((r)=>{
                            if (typeOf(r) === 'Complex' && equalScalar(re(r), re(r) + im(r))) {
                                return re(r);
                            }
                            return r;
                        });
                    }
                default:
                    throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
            }
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/sylvester.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSylvester": (()=>createSylvester)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'sylvester';
var dependencies = [
    'typed',
    'schur',
    'matrixFromColumns',
    'matrix',
    'multiply',
    'range',
    'concat',
    'transpose',
    'index',
    'subset',
    'add',
    'subtract',
    'identity',
    'lusolve',
    'abs'
];
var createSylvester = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, schur, matrixFromColumns, matrix, multiply, range, concat, transpose, index, subset, add, subtract, identity, lusolve, abs } = _ref;
    /**
   *
   * Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are
   * matrices of appropriate dimensions, being A and B squared. Notice that other
   * equivalent definitions for the Sylvester equation exist and this function
   * assumes the one presented in the original publication of the the Bartels-
   * Stewart algorithm, which is implemented by this function.
   * https://en.wikipedia.org/wiki/Sylvester_equation
   *
   * Syntax:
   *
   *     math.sylvester(A, B, C)
   *
   * Examples:
   *
   *     const A = [[-1, -2], [1, 1]]
   *     const B = [[2, -1], [1, -2]]
   *     const C = [[-3, 2], [3, 0]]
   *     math.sylvester(A, B, C)      // returns DenseMatrix [[-0.25, 0.25], [1.5, -1.25]]
   *
   * See also:
   *
   *     schur, lyap
   *
   * @param {Matrix | Array} A  Matrix A
   * @param {Matrix | Array} B  Matrix B
   * @param {Matrix | Array} C  Matrix C
   * @return {Matrix | Array}   Matrix X, solving the Sylvester equation
   */ return typed(name, {
        'Matrix, Matrix, Matrix': _sylvester,
        'Array, Matrix, Matrix': function Array_Matrix_Matrix(A, B, C) {
            return _sylvester(matrix(A), B, C);
        },
        'Array, Array, Matrix': function Array_Array_Matrix(A, B, C) {
            return _sylvester(matrix(A), matrix(B), C);
        },
        'Array, Matrix, Array': function Array_Matrix_Array(A, B, C) {
            return _sylvester(matrix(A), B, matrix(C));
        },
        'Matrix, Array, Matrix': function Matrix_Array_Matrix(A, B, C) {
            return _sylvester(A, matrix(B), C);
        },
        'Matrix, Array, Array': function Matrix_Array_Array(A, B, C) {
            return _sylvester(A, matrix(B), matrix(C));
        },
        'Matrix, Matrix, Array': function Matrix_Matrix_Array(A, B, C) {
            return _sylvester(A, B, matrix(C));
        },
        'Array, Array, Array': function Array_Array_Array(A, B, C) {
            return _sylvester(matrix(A), matrix(B), matrix(C)).toArray();
        }
    });
    "TURBOPACK unreachable";
    function _sylvester(A, B, C) {
        var n = B.size()[0];
        var m = A.size()[0];
        var sA = schur(A);
        var F = sA.T;
        var U = sA.U;
        var sB = schur(multiply(-1, B));
        var G = sB.T;
        var V = sB.U;
        var D = multiply(multiply(transpose(U), C), V);
        var all = range(0, m);
        var y = [];
        var hc = (a, b)=>concat(a, b, 1);
        var vc = (a, b)=>concat(a, b, 0);
        for(var k = 0; k < n; k++){
            if (k < n - 1 && abs(subset(G, index(k + 1, k))) > 1e-5) {
                var RHS = vc(subset(D, index(all, k)), subset(D, index(all, k + 1)));
                for(var j = 0; j < k; j++){
                    RHS = add(RHS, vc(multiply(y[j], subset(G, index(j, k))), multiply(y[j], subset(G, index(j, k + 1)))));
                }
                var gkk = multiply(identity(m), multiply(-1, subset(G, index(k, k))));
                var gmk = multiply(identity(m), multiply(-1, subset(G, index(k + 1, k))));
                var gkm = multiply(identity(m), multiply(-1, subset(G, index(k, k + 1))));
                var gmm = multiply(identity(m), multiply(-1, subset(G, index(k + 1, k + 1))));
                var LHS = vc(hc(add(F, gkk), gmk), hc(gkm, add(F, gmm)));
                var yAux = lusolve(LHS, RHS);
                y[k] = yAux.subset(index(range(0, m), 0));
                y[k + 1] = yAux.subset(index(range(m, 2 * m), 0));
                k++;
            } else {
                var _RHS = subset(D, index(all, k));
                for(var _j = 0; _j < k; _j++){
                    _RHS = add(_RHS, multiply(y[_j], subset(G, index(_j, k))));
                }
                var _gkk = subset(G, index(k, k));
                var _LHS = subtract(F, multiply(_gkk, identity(m)));
                y[k] = lusolve(_LHS, _RHS);
            }
        }
        var Y = matrix(matrixFromColumns(...y));
        var X = multiply(U, multiply(Y, transpose(V)));
        return X;
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSchur": (()=>createSchur)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'schur';
var dependencies = [
    'typed',
    'matrix',
    'identity',
    'multiply',
    'qr',
    'norm',
    'subtract'
];
var createSchur = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, identity, multiply, qr, norm, subtract } = _ref;
    /**
   *
   * Performs a real Schur decomposition of the real matrix A = UTU' where U is orthogonal
   * and T is upper quasi-triangular.
   * https://en.wikipedia.org/wiki/Schur_decomposition
   *
   * Syntax:
   *
   *     math.schur(A)
   *
   * Examples:
   *
   *     const A = [[1, 0], [-4, 3]]
   *     math.schur(A) // returns {T: [[3, 4], [0, 1]], R: [[0, 1], [-1, 0]]}
   *
   * See also:
   *
   *     sylvester, lyap, qr
   *
   * @param {Array | Matrix} A  Matrix A
   * @return {{U: Array | Matrix, T: Array | Matrix}} Object containing both matrix U and T of the Schur Decomposition A=UTU'
   */ return typed(name, {
        Array: function Array(X) {
            var r = _schur(matrix(X));
            return {
                U: r.U.valueOf(),
                T: r.T.valueOf()
            };
        },
        Matrix: function Matrix(X) {
            return _schur(X);
        }
    });
    "TURBOPACK unreachable";
    function _schur(X) {
        var n = X.size()[0];
        var A = X;
        var U = identity(n);
        var k = 0;
        var A0;
        do {
            A0 = A;
            var QR = qr(A);
            var Q = QR.Q;
            var R = QR.R;
            A = multiply(R, Q);
            U = multiply(U, Q);
            if (k++ > 100) {
                break;
            }
        }while (norm(subtract(A, A0)) > 1e-4)
        return {
            U,
            T: A
        };
    }
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/lyap.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLyap": (()=>createLyap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'lyap';
var dependencies = [
    'typed',
    'matrix',
    'sylvester',
    'multiply',
    'transpose'
];
var createLyap = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, matrix, sylvester, multiply, transpose } = _ref;
    /**
   *
   * Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P, where
   * Q is an input matrix. When Q is symmetric, P is also symmetric. Notice
   * that different equivalent definitions exist for the Continuous-time
   * Lyapunov equation.
   * https://en.wikipedia.org/wiki/Lyapunov_equation
   *
   * Syntax:
   *
   *     math.lyap(A, Q)
   *
   * Examples:
   *
   *     const A = [[-2, 0], [1, -4]]
   *     const Q = [[3, 1], [1, 3]]
   *     const P = math.lyap(A, Q)
   *
   * See also:
   *
   *     sylvester, schur
   *
   * @param {Matrix | Array} A  Matrix A
   * @param {Matrix | Array} Q  Matrix Q
   * @return {Matrix | Array} Matrix P solution to the Continuous-time Lyapunov equation AP+PA'=Q
   */ return typed(name, {
        'Matrix, Matrix': function Matrix_Matrix(A, Q) {
            return sylvester(A, transpose(A), multiply(-1, Q));
        },
        'Array, Matrix': function Array_Matrix(A, Q) {
            return sylvester(matrix(A), transpose(matrix(A)), multiply(-1, Q));
        },
        'Matrix, Array': function Matrix_Array(A, Q) {
            return sylvester(A, transpose(matrix(A)), matrix(multiply(-1, Q)));
        },
        'Array, Array': function Array_Array(A, Q) {
            return sylvester(matrix(A), transpose(matrix(A)), matrix(multiply(-1, Q))).toArray();
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/leafCount.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createLeafCount": (()=>createLeafCount)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
var name = 'leafCount';
var dependencies = [
    'parse',
    'typed'
];
var createLeafCount = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { parse, typed } = _ref;
    // This does the real work, but we don't have to recurse through
    // a typed call if we separate it out
    function countLeaves(node) {
        var count = 0;
        node.forEach((n)=>{
            count += countLeaves(n);
        });
        return count || 1;
    }
    /**
   * Gives the number of "leaf nodes" in the parse tree of the given expression
   * A leaf node is one that has no subexpressions, essentially either a
   * symbol or a constant. Note that `5!` has just one leaf, the '5'; the
   * unary factorial operator does not add a leaf. On the other hand,
   * function symbols do add leaves, so `sin(x)/cos(x)` has four leaves.
   *
   * The `simplify()` function should generally not increase the `leafCount()`
   * of an expression, although currently there is no guarantee that it never
   * does so. In many cases, `simplify()` reduces the leaf count.
   *
   * Syntax:
   *
   *     math.leafCount(expr)
   *
   * Examples:
   *
   *     math.leafCount('x') // 1
   *     math.leafCount(math.parse('a*d-b*c')) // 4
   *     math.leafCount('[a,b;c,d][0,1]') // 6
   *
   * See also:
   *
   *     simplify
   *
   * @param {Node|string} expr    The expression to count the leaves of
   *
   * @return {number}  The number of leaves of `expr`
   *
   */ return typed(name, {
        Node: function Node(expr) {
            return countLeaves(expr);
        }
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/simplify/wildcards.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isConstantExpression": (()=>isConstantExpression),
    "isNumericNode": (()=>isNumericNode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
;
;
function isNumericNode(x) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(x) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(x) && x.isUnary() && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(x.args[0]);
}
function isConstantExpression(x) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(x)) {
        // Basic Constant types
        return true;
    }
    if (((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunctionNode"])(x) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(x)) && x.args.every(isConstantExpression)) {
        // Can be constant depending on arguments
        return true;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isParenthesisNode"])(x) && isConstantExpression(x.content)) {
        // Parenthesis are transparent
        return true;
    }
    return false; // Probably missing some edge cases
}
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/simplify/util.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createUtil": (()=>createUtil)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$defineProperty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/defineProperty.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-client] (ecmascript)");
;
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$defineProperty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
;
;
;
var name = 'simplifyUtil';
var dependencies = [
    'FunctionNode',
    'OperatorNode',
    'SymbolNode'
];
var createUtil = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { FunctionNode, OperatorNode, SymbolNode } = _ref;
    // TODO commutative/associative properties rely on the arguments
    // e.g. multiply is not commutative for matrices
    // The properties should be calculated from an argument to simplify, or possibly something in math.config
    // the other option is for typed() to specify a return type so that we can evaluate the type of arguments
    /* So that properties of an operator fit on one line: */ var T = true;
    var F = false;
    var defaultName = 'defaultF';
    var defaultContext = {
        /*      */ add: {
            trivial: T,
            total: T,
            commutative: T,
            associative: T
        },
        /**/ unaryPlus: {
            trivial: T,
            total: T,
            commutative: T,
            associative: T
        },
        /* */ subtract: {
            trivial: F,
            total: T,
            commutative: F,
            associative: F
        },
        /* */ multiply: {
            trivial: T,
            total: T,
            commutative: T,
            associative: T
        },
        /*   */ divide: {
            trivial: F,
            total: T,
            commutative: F,
            associative: F
        },
        /*    */ paren: {
            trivial: T,
            total: T,
            commutative: T,
            associative: F
        },
        /* */ defaultF: {
            trivial: F,
            total: T,
            commutative: F,
            associative: F
        }
    };
    var realContext = {
        divide: {
            total: F
        },
        log: {
            total: F
        }
    };
    var positiveContext = {
        subtract: {
            total: F
        },
        abs: {
            trivial: T
        },
        log: {
            total: T
        }
    };
    function hasProperty(nodeOrName, property) {
        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultContext;
        var name = defaultName;
        if (typeof nodeOrName === 'string') {
            name = nodeOrName;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(nodeOrName)) {
            name = nodeOrName.fn.toString();
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunctionNode"])(nodeOrName)) {
            name = nodeOrName.name;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isParenthesisNode"])(nodeOrName)) {
            name = 'paren';
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(context, name)) {
            var properties = context[name];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(properties, property)) {
                return properties[property];
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(defaultContext, name)) {
                return defaultContext[name][property];
            }
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(context, defaultName)) {
            var _properties = context[defaultName];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(_properties, property)) {
                return _properties[property];
            }
            return defaultContext[defaultName][property];
        }
        /* name not found in context and context has no global default */ /* So use default context. */ if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(defaultContext, name)) {
            var _properties2 = defaultContext[name];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(_properties2, property)) {
                return _properties2[property];
            }
        }
        return defaultContext[defaultName][property];
    }
    function isCommutative(node) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;
        return hasProperty(node, 'commutative', context);
    }
    function isAssociative(node) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;
        return hasProperty(node, 'associative', context);
    }
    /**
   * Merge the given contexts, with primary overriding secondary
   * wherever they might conflict
   */ function mergeContext(primary, secondary) {
        var merged = _objectSpread({}, primary);
        for(var prop in secondary){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(primary, prop)) {
                merged[prop] = _objectSpread(_objectSpread({}, secondary[prop]), primary[prop]);
            } else {
                merged[prop] = secondary[prop];
            }
        }
        return merged;
    }
    /**
   * Flatten all associative operators in an expression tree.
   * Assumes parentheses have already been removed.
   */ function flatten(node, context) {
        if (!node.args || node.args.length === 0) {
            return node;
        }
        node.args = allChildren(node, context);
        for(var i = 0; i < node.args.length; i++){
            flatten(node.args[i], context);
        }
    }
    /**
   * Get the children of a node as if it has been flattened.
   * TODO implement for FunctionNodes
   */ function allChildren(node, context) {
        var op;
        var children = [];
        var _findChildren = function findChildren(node) {
            for(var i = 0; i < node.args.length; i++){
                var child = node.args[i];
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(child) && op === child.op) {
                    _findChildren(child);
                } else {
                    children.push(child);
                }
            }
        };
        if (isAssociative(node, context)) {
            op = node.op;
            _findChildren(node);
            return children;
        } else {
            return node.args;
        }
    }
    /**
   *  Unflatten all flattened operators to a right-heavy binary tree.
   */ function unflattenr(node, context) {
        if (!node.args || node.args.length === 0) {
            return;
        }
        var makeNode = createMakeNodeFunction(node);
        var l = node.args.length;
        for(var i = 0; i < l; i++){
            unflattenr(node.args[i], context);
        }
        if (l > 2 && isAssociative(node, context)) {
            var curnode = node.args.pop();
            while(node.args.length > 0){
                curnode = makeNode([
                    node.args.pop(),
                    curnode
                ]);
            }
            node.args = curnode.args;
        }
    }
    /**
   *  Unflatten all flattened operators to a left-heavy binary tree.
   */ function unflattenl(node, context) {
        if (!node.args || node.args.length === 0) {
            return;
        }
        var makeNode = createMakeNodeFunction(node);
        var l = node.args.length;
        for(var i = 0; i < l; i++){
            unflattenl(node.args[i], context);
        }
        if (l > 2 && isAssociative(node, context)) {
            var curnode = node.args.shift();
            while(node.args.length > 0){
                curnode = makeNode([
                    curnode,
                    node.args.shift()
                ]);
            }
            node.args = curnode.args;
        }
    }
    function createMakeNodeFunction(node) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(node)) {
            return function(args) {
                try {
                    return new OperatorNode(node.op, node.fn, args, node.implicit);
                } catch (err) {
                    console.error(err);
                    return [];
                }
            };
        } else {
            return function(args) {
                return new FunctionNode(new SymbolNode(node.name), args);
            };
        }
    }
    return {
        createMakeNodeFunction,
        hasProperty,
        isCommutative,
        isAssociative,
        mergeContext,
        flatten,
        allChildren,
        unflattenr,
        unflattenl,
        defaultContext,
        realContext,
        positiveContext
    };
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/simplify.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSimplify": (()=>createSimplify)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__isSymbolNode__as__isVariableNode$3e$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript) <export isSymbolNode as isVariableNode>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$simplify$2f$wildcards$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/simplify/wildcards.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$simplify$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/simplify/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/map.js [app-client] (ecmascript)");
;
;
;
;
;
;
var name = 'simplify';
var dependencies = [
    'typed',
    'parse',
    'equal',
    'resolve',
    'simplifyConstant',
    'simplifyCore',
    'AccessorNode',
    'ArrayNode',
    'ConstantNode',
    'FunctionNode',
    'IndexNode',
    'ObjectNode',
    'OperatorNode',
    'ParenthesisNode',
    'SymbolNode'
];
var createSimplify = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, parse, equal, resolve, simplifyConstant, simplifyCore, AccessorNode, ArrayNode, ConstantNode, FunctionNode, IndexNode, ObjectNode, OperatorNode, ParenthesisNode, SymbolNode } = _ref;
    var { hasProperty, isCommutative, isAssociative, mergeContext, flatten, unflattenr, unflattenl, createMakeNodeFunction, defaultContext, realContext, positiveContext } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$simplify$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createUtil"])({
        FunctionNode,
        OperatorNode,
        SymbolNode
    });
    /**
   * Simplify an expression tree.
   *
   * A list of rules are applied to an expression, repeating over the list until
   * no further changes are made.
   * It's possible to pass a custom set of rules to the function as second
   * argument. A rule can be specified as an object, string, or function:
   *
   *     const rules = [
   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },
   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',
   *       function (node) {
   *         // ... return a new node or return the node unchanged
   *         return node
   *       }
   *     ]
   *
   * String and object rules consist of a left and right pattern. The left is
   * used to match against the expression and the right determines what matches
   * are replaced with. The main difference between a pattern and a normal
   * expression is that variables starting with the following characters are
   * interpreted as wildcards:
   *
   * - 'n' - Matches any node [Node]
   * - 'c' - Matches a constant literal (5 or 3.2) [ConstantNode]
   * - 'cl' - Matches a constant literal; same as c [ConstantNode]
   * - 'cd' - Matches a decimal literal (5 or -3.2) [ConstantNode or unaryMinus wrapping a ConstantNode]
   * - 'ce' - Matches a constant expression (-5 or √3) [Expressions consisting of only ConstantNodes, functions, and operators]
   * - 'v' - Matches a variable; anything not matched by c (-5 or x) [Node that is not a ConstantNode]
   * - 'vl' - Matches a variable literal (x or y) [SymbolNode]
   * - 'vd' - Matches a non-decimal expression; anything not matched by cd (x or √3) [Node that is not a ConstantNode or unaryMinus that is wrapping a ConstantNode]
   * - 've' - Matches a variable expression; anything not matched by ce (x or 2x) [Expressions that contain a SymbolNode or other non-constant term]
   *
   * The default list of rules is exposed on the function as `simplify.rules`
   * and can be used as a basis to built a set of custom rules. Note that since
   * the `simplifyCore` function is in the default list of rules, by default
   * simplify will convert any function calls in the expression that have
   * operator equivalents to their operator forms.
   *
   * To specify a rule as a string, separate the left and right pattern by '->'
   * When specifying a rule as an object, the following keys are meaningful:
   * - l - the left pattern
   * - r - the right pattern
   * - s - in lieu of l and r, the string form that is broken at -> to give them
   * - repeat - whether to repeat this rule until the expression stabilizes
   * - assuming - gives a context object, as in the 'context' option to
   *     simplify. Every property in the context object must match the current
   *     context in order, or else the rule will not be applied.
   * - imposeContext - gives a context object, as in the 'context' option to
   *     simplify. Any settings specified will override the incoming context
   *     for all matches of this rule.
   *
   * For more details on the theory, see:
   *
   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)
   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)
   *
   *  An optional `options` argument can be passed as last argument of `simplify`.
   *  Currently available options (defaults in parentheses):
   *  - `consoleDebug` (false): whether to write the expression being simplified
   *    and any changes to it, along with the rule responsible, to console
   *  - `context` (simplify.defaultContext): an object giving properties of
   *    each operator, which determine what simplifications are allowed. The
   *    currently meaningful properties are commutative, associative,
   *    total (whether the operation is defined for all arguments), and
   *    trivial (whether the operation applied to a single argument leaves
   *    that argument unchanged). The default context is very permissive and
   *    allows almost all simplifications. Only properties differing from
   *    the default need to be specified; the default context is used as a
   *    fallback. Additional contexts `simplify.realContext` and
   *    `simplify.positiveContext` are supplied to cause simplify to perform
   *    just simplifications guaranteed to preserve all values of the expression
   *    assuming all variables and subexpressions are real numbers or
   *    positive real numbers, respectively. (Note that these are in some cases
   *    more restrictive than the default context; for example, the default
   *    context will allow `x/x` to simplify to 1, whereas
   *    `simplify.realContext` will not, as `0/0` is not equal to 1.)
   *  - `exactFractions` (true): whether to try to convert all constants to
   *    exact rational numbers.
   *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will
   *    be expressed as fractions only when both numerator and denominator
   *    are smaller than `fractionsLimit`.
   *
   * Syntax:
   *
   *     math.simplify(expr)
   *     math.simplify(expr, rules)
   *     math.simplify(expr, rules)
   *     math.simplify(expr, rules, scope)
   *     math.simplify(expr, rules, scope, options)
   *     math.simplify(expr, scope)
   *     math.simplify(expr, scope, options)
   *
   * Examples:
   *
   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node "2 * x"
   *     math.simplify('2 * 3 * x', {x: 4})        // Node "24"
   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')
   *     math.simplify(f)                          // Node "2 * x"
   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node "x * 2 / 5"
   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node "0.4 * x"
   *
   * See also:
   *
   *     simplifyCore, derivative, evaluate, parse, rationalize, resolve
   *
   * @param {Node | string} expr
   *            The expression to be simplified
   * @param {SimplifyRule[]} [rules]
   *            Optional list with custom rules
   * @param {Object} [scope] Optional scope with variables
   * @param {SimplifyOptions} [options] Optional configuration settings
   * @return {Node} Returns the simplified form of `expr`
   */ typed.addConversion({
        from: 'Object',
        to: 'Map',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createMap"]
    });
    var simplify = typed('simplify', {
        Node: _simplify,
        'Node, Map': (expr, scope)=>_simplify(expr, false, scope),
        'Node, Map, Object': (expr, scope, options)=>_simplify(expr, false, scope, options),
        'Node, Array': _simplify,
        'Node, Array, Map': _simplify,
        'Node, Array, Map, Object': _simplify
    });
    typed.removeConversion({
        from: 'Object',
        to: 'Map',
        convert: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createMap"]
    });
    simplify.defaultContext = defaultContext;
    simplify.realContext = realContext;
    simplify.positiveContext = positiveContext;
    function removeParens(node) {
        return node.transform(function(node) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isParenthesisNode"])(node) ? removeParens(node.content) : node;
        });
    }
    // All constants that are allowed in rules
    var SUPPORTED_CONSTANTS = {
        true: true,
        false: true,
        e: true,
        i: true,
        Infinity: true,
        LN2: true,
        LN10: true,
        LOG2E: true,
        LOG10E: true,
        NaN: true,
        phi: true,
        pi: true,
        SQRT1_2: true,
        SQRT2: true,
        tau: true
    };
    // Array of strings, used to build the ruleSet.
    // Each l (left side) and r (right side) are parsed by
    // the expression parser into a node tree.
    // Left hand sides are matched to subtrees within the
    // expression to be parsed and replaced with the right
    // hand side.
    // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])
    // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.
    // It is possible to get into an infinite loop with conflicting rules
    simplify.rules = [
        simplifyCore,
        // { l: 'n+0', r: 'n' },     // simplifyCore
        // { l: 'n^0', r: '1' },     // simplifyCore
        // { l: '0*n', r: '0' },     // simplifyCore
        // { l: 'n/n', r: '1'},      // simplifyCore
        // { l: 'n^1', r: 'n' },     // simplifyCore
        // { l: '+n1', r:'n1' },     // simplifyCore
        // { l: 'n--n1', r:'n+n1' }, // simplifyCore
        {
            l: 'log(e)',
            r: '1'
        },
        // temporary rules
        // Note initially we tend constants to the right because like-term
        // collection prefers the left, and we would rather collect nonconstants
        {
            s: 'n-n1 -> n+-n1',
            // temporarily replace 'subtract' so we can further flatten the 'add' operator
            assuming: {
                subtract: {
                    total: true
                }
            }
        },
        {
            s: 'n-n -> 0',
            // partial alternative when we can't always subtract
            assuming: {
                subtract: {
                    total: false
                }
            }
        },
        {
            s: '-(cl*v) -> v * (-cl)',
            // make non-constant terms positive
            assuming: {
                multiply: {
                    commutative: true
                },
                subtract: {
                    total: true
                }
            }
        },
        {
            s: '-(cl*v) -> (-cl) * v',
            // non-commutative version, part 1
            assuming: {
                multiply: {
                    commutative: false
                },
                subtract: {
                    total: true
                }
            }
        },
        {
            s: '-(v*cl) -> v * (-cl)',
            // non-commutative version, part 2
            assuming: {
                multiply: {
                    commutative: false
                },
                subtract: {
                    total: true
                }
            }
        },
        {
            l: '-(n1/n2)',
            r: '-n1/n2'
        },
        {
            l: '-v',
            r: 'v * (-1)'
        },
        // finish making non-constant terms positive
        {
            l: '(n1 + n2)*(-1)',
            r: 'n1*(-1) + n2*(-1)',
            repeat: true
        },
        // expand negations to achieve as much sign cancellation as possible
        {
            l: 'n/n1^n2',
            r: 'n*n1^-n2'
        },
        // temporarily replace 'divide' so we can further flatten the 'multiply' operator
        {
            l: 'n/n1',
            r: 'n*n1^-1'
        },
        {
            s: '(n1*n2)^n3 -> n1^n3 * n2^n3',
            assuming: {
                multiply: {
                    commutative: true
                }
            }
        },
        {
            s: '(n1*n2)^(-1) -> n2^(-1) * n1^(-1)',
            assuming: {
                multiply: {
                    commutative: false
                }
            }
        },
        // expand nested exponentiation
        {
            s: '(n ^ n1) ^ n2 -> n ^ (n1 * n2)',
            assuming: {
                divide: {
                    total: true
                }
            } // 1/(1/n) = n needs 1/n to exist
        },
        // collect like factors; into a sum, only do this for nonconstants
        {
            l: ' vd   * ( vd   * n1 + n2)',
            r: 'vd^2       * n1 +  vd   * n2'
        },
        {
            s: ' vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2',
            assuming: {
                divide: {
                    total: true
                }
            } // v*1/v = v^(1+-1) needs 1/v
        },
        {
            s: 'vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2',
            assuming: {
                divide: {
                    total: true
                }
            }
        },
        {
            s: 'vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2',
            assuming: {
                divide: {
                    total: true
                }
            }
        },
        {
            l: 'n*n',
            r: 'n^2'
        },
        {
            s: 'n * n^n1 -> n^(n1+1)',
            assuming: {
                divide: {
                    total: true
                }
            } // n*1/n = n^(-1+1) needs 1/n
        },
        {
            s: 'n^n1 * n^n2 -> n^(n1+n2)',
            assuming: {
                divide: {
                    total: true
                }
            } // ditto for n^2*1/n^2
        },
        // Unfortunately, to deal with more complicated cancellations, it
        // becomes necessary to simplify constants twice per pass. It's not
        // terribly expensive compared to matching rules, so this should not
        // pose a performance problem.
        simplifyConstant,
        // First: before collecting like terms
        // collect like terms
        {
            s: 'n+n -> 2*n',
            assuming: {
                add: {
                    total: true
                }
            } // 2 = 1 + 1 needs to exist
        },
        {
            l: 'n+-n',
            r: '0'
        },
        {
            l: 'vd*n + vd',
            r: 'vd*(n+1)'
        },
        // NOTE: leftmost position is special:
        {
            l: 'n3*n1 + n3*n2',
            r: 'n3*(n1+n2)'
        },
        // All sub-monomials tried there.
        {
            l: 'n3^(-n4)*n1 +   n3  * n2',
            r: 'n3^(-n4)*(n1 + n3^(n4+1) *n2)'
        },
        {
            l: 'n3^(-n4)*n1 + n3^n5 * n2',
            r: 'n3^(-n4)*(n1 + n3^(n4+n5)*n2)'
        },
        // noncommutative additional cases (term collection & factoring)
        {
            s: 'n*vd + vd -> (n+1)*vd',
            assuming: {
                multiply: {
                    commutative: false
                }
            }
        },
        {
            s: 'vd + n*vd -> (1+n)*vd',
            assuming: {
                multiply: {
                    commutative: false
                }
            }
        },
        {
            s: 'n1*n3 + n2*n3 -> (n1+n2)*n3',
            assuming: {
                multiply: {
                    commutative: false
                }
            }
        },
        {
            s: 'n^n1 * n -> n^(n1+1)',
            assuming: {
                divide: {
                    total: true
                },
                multiply: {
                    commutative: false
                }
            }
        },
        {
            s: 'n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)',
            assuming: {
                multiply: {
                    commutative: false
                }
            }
        },
        {
            s: 'n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)',
            assuming: {
                multiply: {
                    commutative: false
                }
            }
        },
        {
            l: 'n*cd + cd',
            r: '(n+1)*cd'
        },
        {
            s: 'cd*n + cd -> cd*(n+1)',
            assuming: {
                multiply: {
                    commutative: false
                }
            }
        },
        {
            s: 'cd + cd*n -> cd*(1+n)',
            assuming: {
                multiply: {
                    commutative: false
                }
            }
        },
        simplifyConstant,
        // Second: before returning expressions to "standard form"
        // make factors positive (and undo 'make non-constant terms positive')
        {
            s: '(-n)*n1 -> -(n*n1)',
            assuming: {
                subtract: {
                    total: true
                }
            }
        },
        {
            s: 'n1*(-n) -> -(n1*n)',
            // in case * non-commutative
            assuming: {
                subtract: {
                    total: true
                },
                multiply: {
                    commutative: false
                }
            }
        },
        // final ordering of constants
        {
            s: 'ce+ve -> ve+ce',
            assuming: {
                add: {
                    commutative: true
                }
            },
            imposeContext: {
                add: {
                    commutative: false
                }
            }
        },
        {
            s: 'vd*cd -> cd*vd',
            assuming: {
                multiply: {
                    commutative: true
                }
            },
            imposeContext: {
                multiply: {
                    commutative: false
                }
            }
        },
        // undo temporary rules
        // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
        {
            l: 'n+-n1',
            r: 'n-n1'
        },
        // undo replace 'subtract'
        {
            l: 'n+-(n1)',
            r: 'n-(n1)'
        },
        {
            s: 'n*(n1^-1) -> n/n1',
            // undo replace 'divide'; for * commutative
            assuming: {
                multiply: {
                    commutative: true
                }
            } // o.w. / not conventional
        },
        {
            s: 'n*n1^-n2 -> n/n1^n2',
            assuming: {
                multiply: {
                    commutative: true
                }
            } // o.w. / not conventional
        },
        {
            s: 'n^-1 -> 1/n',
            assuming: {
                multiply: {
                    commutative: true
                }
            } // o.w. / not conventional
        },
        {
            l: 'n^1',
            r: 'n'
        },
        // can be produced by power cancellation
        {
            s: 'n*(n1/n2) -> (n*n1)/n2',
            // '*' before '/'
            assuming: {
                multiply: {
                    associative: true
                }
            }
        },
        {
            s: 'n-(n1+n2) -> n-n1-n2',
            // '-' before '+'
            assuming: {
                addition: {
                    associative: true,
                    commutative: true
                }
            }
        },
        // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
        // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
        // simplifyConstant can leave an extra factor of 1, which can always
        // be eliminated, since the identity always commutes
        {
            l: '1*n',
            r: 'n',
            imposeContext: {
                multiply: {
                    commutative: true
                }
            }
        },
        {
            s: 'n1/(n2/n3) -> (n1*n3)/n2',
            assuming: {
                multiply: {
                    associative: true
                }
            }
        },
        {
            l: 'n1/(-n2)',
            r: '-n1/n2'
        }
    ];
    /**
   * Takes any rule object as allowed by the specification in simplify
   * and puts it in a standard form used by applyRule
   */ function _canonicalizeRule(ruleObject, context) {
        var newRule = {};
        if (ruleObject.s) {
            var lr = ruleObject.s.split('->');
            if (lr.length === 2) {
                newRule.l = lr[0];
                newRule.r = lr[1];
            } else {
                throw SyntaxError('Could not parse rule: ' + ruleObject.s);
            }
        } else {
            newRule.l = ruleObject.l;
            newRule.r = ruleObject.r;
        }
        newRule.l = removeParens(parse(newRule.l));
        newRule.r = removeParens(parse(newRule.r));
        for (var prop of [
            'imposeContext',
            'repeat',
            'assuming'
        ]){
            if (prop in ruleObject) {
                newRule[prop] = ruleObject[prop];
            }
        }
        if (ruleObject.evaluate) {
            newRule.evaluate = parse(ruleObject.evaluate);
        }
        if (isAssociative(newRule.l, context)) {
            var nonCommutative = !isCommutative(newRule.l, context);
            var leftExpandsym;
            // Gen. the LHS placeholder used in this NC-context specific expansion rules
            if (nonCommutative) leftExpandsym = _getExpandPlaceholderSymbol();
            var makeNode = createMakeNodeFunction(newRule.l);
            var expandsym = _getExpandPlaceholderSymbol();
            newRule.expanded = {};
            newRule.expanded.l = makeNode([
                newRule.l,
                expandsym
            ]);
            // Push the expandsym into the deepest possible branch.
            // This helps to match the newRule against nodes returned from getSplits() later on.
            flatten(newRule.expanded.l, context);
            unflattenr(newRule.expanded.l, context);
            newRule.expanded.r = makeNode([
                newRule.r,
                expandsym
            ]);
            // In and for a non-commutative context, attempting with yet additional expansion rules makes
            // way for more matches cases of multi-arg expressions; such that associative rules (such as
            // 'n*n -> n^2') can be applied to exprs. such as 'a * b * b' and 'a * b * b * a'.
            if (nonCommutative) {
                // 'Non-commutative' 1: LHS (placeholder) only
                newRule.expandedNC1 = {};
                newRule.expandedNC1.l = makeNode([
                    leftExpandsym,
                    newRule.l
                ]);
                newRule.expandedNC1.r = makeNode([
                    leftExpandsym,
                    newRule.r
                ]);
                // 'Non-commutative' 2: farmost LHS and RHS placeholders
                newRule.expandedNC2 = {};
                newRule.expandedNC2.l = makeNode([
                    leftExpandsym,
                    newRule.expanded.l
                ]);
                newRule.expandedNC2.r = makeNode([
                    leftExpandsym,
                    newRule.expanded.r
                ]);
            }
        }
        return newRule;
    }
    /**
   * Parse the string array of rules into nodes
   *
   * Example syntax for rules:
   *
   * Position constants to the left in a product:
   * { l: 'n1 * c1', r: 'c1 * n1' }
   * n1 is any Node, and c1 is a ConstantNode.
   *
   * Apply difference of squares formula:
   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }
   * n1, n2 mean any Node.
   *
   * Short hand notation:
   * 'n1 * c1 -> c1 * n1'
   */ function _buildRules(rules, context) {
        // Array of rules to be used to simplify expressions
        var ruleSet = [];
        for(var i = 0; i < rules.length; i++){
            var rule = rules[i];
            var newRule = void 0;
            var ruleType = typeof rule;
            switch(ruleType){
                case 'string':
                    rule = {
                        s: rule
                    };
                /* falls through */ case 'object':
                    newRule = _canonicalizeRule(rule, context);
                    break;
                case 'function':
                    newRule = rule;
                    break;
                default:
                    throw TypeError('Unsupported type of rule: ' + ruleType);
            }
            // console.log('Adding rule: ' + rules[i])
            // console.log(newRule)
            ruleSet.push(newRule);
        }
        return ruleSet;
    }
    var _lastsym = 0;
    function _getExpandPlaceholderSymbol() {
        return new SymbolNode('_p' + _lastsym++);
    }
    function _simplify(expr, rules) {
        var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEmptyMap"])();
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var debug = options.consoleDebug;
        rules = _buildRules(rules || simplify.rules, options.context);
        var res = resolve(expr, scope);
        res = removeParens(res);
        var visited = {};
        var str = res.toString({
            parenthesis: 'all'
        });
        while(!visited[str]){
            visited[str] = true;
            _lastsym = 0; // counter for placeholder symbols
            var laststr = str;
            if (debug) console.log('Working on: ', str);
            for(var i = 0; i < rules.length; i++){
                var rulestr = '';
                if (typeof rules[i] === 'function') {
                    res = rules[i](res, options);
                    if (debug) rulestr = rules[i].name;
                } else {
                    flatten(res, options.context);
                    res = applyRule(res, rules[i], options.context);
                    if (debug) {
                        rulestr = "".concat(rules[i].l.toString(), " -> ").concat(rules[i].r.toString());
                    }
                }
                if (debug) {
                    var newstr = res.toString({
                        parenthesis: 'all'
                    });
                    if (newstr !== laststr) {
                        console.log('Applying', rulestr, 'produced', newstr);
                        laststr = newstr;
                    }
                }
                /* Use left-heavy binary tree internally,
         * since custom rule functions may expect it
         */ unflattenl(res, options.context);
            }
            str = res.toString({
                parenthesis: 'all'
            });
        }
        return res;
    }
    function mapRule(nodes, rule, context) {
        var resNodes = nodes;
        if (nodes) {
            for(var i = 0; i < nodes.length; ++i){
                var newNode = applyRule(nodes[i], rule, context);
                if (newNode !== nodes[i]) {
                    if (resNodes === nodes) {
                        resNodes = nodes.slice();
                    }
                    resNodes[i] = newNode;
                }
            }
        }
        return resNodes;
    }
    /**
   * Returns a simplfied form of node, or the original node if no simplification was possible.
   *
   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
   * @param  {Object | Function} rule
   * @param  {Object} context -- information about assumed properties of operators
   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.
   */ function applyRule(node, rule, context) {
        //    console.log('Entering applyRule("', rule.l.toString({parenthesis:'all'}), '->', rule.r.toString({parenthesis:'all'}), '",', node.toString({parenthesis:'all'}),')')
        // check that the assumptions for this rule are satisfied by the current
        // context:
        if (rule.assuming) {
            for(var symbol in rule.assuming){
                for(var property in rule.assuming[symbol]){
                    if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
                        return node;
                    }
                }
            }
        }
        var mergedContext = mergeContext(rule.imposeContext, context);
        // Do not clone node unless we find a match
        var res = node;
        // First replace our child nodes with their simplified versions
        // If a child could not be simplified, applying the rule to it
        // will have no effect since the node is returned unchanged
        if (res instanceof OperatorNode || res instanceof FunctionNode) {
            var newArgs = mapRule(res.args, rule, context);
            if (newArgs !== res.args) {
                res = res.clone();
                res.args = newArgs;
            }
        } else if (res instanceof ParenthesisNode) {
            if (res.content) {
                var newContent = applyRule(res.content, rule, context);
                if (newContent !== res.content) {
                    res = new ParenthesisNode(newContent);
                }
            }
        } else if (res instanceof ArrayNode) {
            var newItems = mapRule(res.items, rule, context);
            if (newItems !== res.items) {
                res = new ArrayNode(newItems);
            }
        } else if (res instanceof AccessorNode) {
            var newObj = res.object;
            if (res.object) {
                newObj = applyRule(res.object, rule, context);
            }
            var newIndex = res.index;
            if (res.index) {
                newIndex = applyRule(res.index, rule, context);
            }
            if (newObj !== res.object || newIndex !== res.index) {
                res = new AccessorNode(newObj, newIndex);
            }
        } else if (res instanceof IndexNode) {
            var newDims = mapRule(res.dimensions, rule, context);
            if (newDims !== res.dimensions) {
                res = new IndexNode(newDims);
            }
        } else if (res instanceof ObjectNode) {
            var changed = false;
            var newProps = {};
            for(var prop in res.properties){
                newProps[prop] = applyRule(res.properties[prop], rule, context);
                if (newProps[prop] !== res.properties[prop]) {
                    changed = true;
                }
            }
            if (changed) {
                res = new ObjectNode(newProps);
            }
        }
        // Try to match a rule against this node
        var repl = rule.r;
        var matches = _ruleMatch(rule.l, res, mergedContext)[0];
        // If the rule is associative operator, we can try matching it while allowing additional terms.
        // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.
        if (!matches && rule.expanded) {
            repl = rule.expanded.r;
            matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
        }
        // Additional, non-commutative context expansion-rules
        if (!matches && rule.expandedNC1) {
            repl = rule.expandedNC1.r;
            matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];
            if (!matches) {
                // Existence of NC1 implies NC2
                repl = rule.expandedNC2.r;
                matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];
            }
        }
        if (matches) {
            // const before = res.toString({parenthesis: 'all'})
            // Create a new node by cloning the rhs of the matched rule
            // we keep any implicit multiplication state if relevant
            var implicit = res.implicit;
            res = repl.clone();
            if (implicit && 'implicit' in repl) {
                res.implicit = true;
            }
            // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes
            res = res.transform(function(node) {
                if (node.isSymbolNode && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(matches.placeholders, node.name)) {
                    return matches.placeholders[node.name].clone();
                } else {
                    return node;
                }
            });
        // const after = res.toString({parenthesis: 'all'})
        // console.log('Simplified ' + before + ' to ' + after)
        }
        if (rule.repeat && res !== node) {
            res = applyRule(res, rule, context);
        }
        return res;
    }
    /**
   * Get (binary) combinations of a flattened binary node
   * e.g. +(node1, node2, node3) -> [
   *        +(node1,  +(node2, node3)),
   *        +(node2,  +(node1, node3)),
   *        +(node3,  +(node1, node2))]
   *
   */ function getSplits(node, context) {
        var res = [];
        var right, rightArgs;
        var makeNode = createMakeNodeFunction(node);
        if (isCommutative(node, context)) {
            for(var i = 0; i < node.args.length; i++){
                rightArgs = node.args.slice(0);
                rightArgs.splice(i, 1);
                right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
                res.push(makeNode([
                    node.args[i],
                    right
                ]));
            }
        } else {
            // Keep order, but try all parenthesizations
            for(var _i = 1; _i < node.args.length; _i++){
                var left = node.args[0];
                if (_i > 1) {
                    left = makeNode(node.args.slice(0, _i));
                }
                rightArgs = node.args.slice(_i);
                right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
                res.push(makeNode([
                    left,
                    right
                ]));
            }
        }
        return res;
    }
    /**
   * Returns the set union of two match-placeholders or null if there is a conflict.
   */ function mergeMatch(match1, match2) {
        var res = {
            placeholders: {}
        };
        // Some matches may not have placeholders; this is OK
        if (!match1.placeholders && !match2.placeholders) {
            return res;
        } else if (!match1.placeholders) {
            return match2;
        } else if (!match2.placeholders) {
            return match1;
        }
        // Placeholders with the same key must match exactly
        for(var key in match1.placeholders){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(match1.placeholders, key)) {
                res.placeholders[key] = match1.placeholders[key];
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(match2.placeholders, key)) {
                    if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
                        return null;
                    }
                }
            }
        }
        for(var _key in match2.placeholders){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(match2.placeholders, _key)) {
                res.placeholders[_key] = match2.placeholders[_key];
            }
        }
        return res;
    }
    /**
   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.
   * Each list represents matches found in one child of a node.
   */ function combineChildMatches(list1, list2) {
        var res = [];
        if (list1.length === 0 || list2.length === 0) {
            return res;
        }
        var merged;
        for(var i1 = 0; i1 < list1.length; i1++){
            for(var i2 = 0; i2 < list2.length; i2++){
                merged = mergeMatch(list1[i1], list2[i2]);
                if (merged) {
                    res.push(merged);
                }
            }
        }
        return res;
    }
    /**
   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.
   * Each list represents matches found in one child of a node.
   * Returns a list of unique matches.
   */ function mergeChildMatches(childMatches) {
        if (childMatches.length === 0) {
            return childMatches;
        }
        var sets = childMatches.reduce(combineChildMatches);
        var uniqueSets = [];
        var unique = {};
        for(var i = 0; i < sets.length; i++){
            var s = JSON.stringify(sets[i]);
            if (!unique[s]) {
                unique[s] = true;
                uniqueSets.push(sets[i]);
            }
        }
        return uniqueSets;
    }
    /**
   * Determines whether node matches rule.
   *
   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule
   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
   * @param {Object} context -- provides assumed properties of operators
   * @param {Boolean} isSplit -- whether we are in process of splitting an
   *                    n-ary operator node into possible binary combinations.
   *                    Defaults to false.
   * @return {Object} Information about the match, if it exists.
   */ function _ruleMatch(rule, node, context, isSplit) {
        //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')
        //    console.log('rule = ' + rule)
        //    console.log('node = ' + node)
        //    console.log('Entering _ruleMatch(', rule.toString({parenthesis:'all'}), ', ', node.toString({parenthesis:'all'}), ', ', context, ')')
        var res = [
            {
                placeholders: {}
            }
        ];
        if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {
            // If the rule is an OperatorNode or a FunctionNode, then node must match exactly
            if (rule instanceof OperatorNode) {
                if (rule.op !== node.op || rule.fn !== node.fn) {
                    return [];
                }
            } else if (rule instanceof FunctionNode) {
                if (rule.name !== node.name) {
                    return [];
                }
            }
            // rule and node match. Search the children of rule and node.
            if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
                // Expect non-associative operators to match exactly,
                // except in any order if operator is commutative
                var childMatches = [];
                for(var i = 0; i < rule.args.length; i++){
                    var childMatch = _ruleMatch(rule.args[i], node.args[i], context);
                    if (childMatch.length === 0) {
                        break;
                    }
                    // The child matched, so add the information returned from the child to our result
                    childMatches.push(childMatch);
                }
                if (childMatches.length !== rule.args.length) {
                    if (!isCommutative(node, context) || // exact match in order needed
                    rule.args.length === 1) {
                        // nothing to commute
                        return [];
                    }
                    if (rule.args.length > 2) {
                        /* Need to generate all permutations and try them.
             * It's a bit complicated, and unlikely to come up since there
             * are very few ternary or higher operators. So punt for now.
             */ throw new Error('permuting >2 commutative non-associative rule arguments not yet implemented');
                    }
                    /* Exactly two arguments, try them reversed */ var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
                    if (leftMatch.length === 0) {
                        return [];
                    }
                    var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
                    if (rightMatch.length === 0) {
                        return [];
                    }
                    childMatches = [
                        leftMatch,
                        rightMatch
                    ];
                }
                res = mergeChildMatches(childMatches);
            } else if (node.args.length >= 2 && rule.args.length === 2) {
                // node is flattened, rule is not
                // Associative operators/functions can be split in different ways so we check if the rule
                // matches for each of them and return their union.
                var splits = getSplits(node, context);
                var splitMatches = [];
                for(var _i2 = 0; _i2 < splits.length; _i2++){
                    var matchSet = _ruleMatch(rule, splits[_i2], context, true); // recursing at the same tree depth here
                    splitMatches = splitMatches.concat(matchSet);
                }
                return splitMatches;
            } else if (rule.args.length > 2) {
                throw Error('Unexpected non-binary associative function: ' + rule.toString());
            } else {
                // Incorrect number of arguments in rule and node, so no match
                return [];
            }
        } else if (rule instanceof SymbolNode) {
            // If the rule is a SymbolNode, then it carries a special meaning
            // according to the first one or two characters of the symbol node name.
            // These meanings are expalined in the documentation for simplify()
            if (rule.name.length === 0) {
                throw new Error('Symbol in rule has 0 length...!?');
            }
            if (SUPPORTED_CONSTANTS[rule.name]) {
                // built-in constant must match exactly
                if (rule.name !== node.name) {
                    return [];
                }
            } else {
                // wildcards are composed of up to two alphabetic or underscore characters
                switch(rule.name[1] >= 'a' && rule.name[1] <= 'z' ? rule.name.substring(0, 2) : rule.name[0]){
                    case 'n':
                    case '_p':
                        // rule matches _anything_, so assign this node to the rule.name placeholder
                        // Assign node to the rule.name placeholder.
                        // Our parent will check for matches among placeholders.
                        res[0].placeholders[rule.name] = node;
                        break;
                    case 'c':
                    case 'cl':
                        // rule matches a ConstantNode
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(node)) {
                            res[0].placeholders[rule.name] = node;
                        } else {
                            // mis-match: rule does not encompass current node
                            return [];
                        }
                        break;
                    case 'v':
                        // rule matches anything other than a ConstantNode
                        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(node)) {
                            res[0].placeholders[rule.name] = node;
                        } else {
                            // mis-match: rule does not encompass current node
                            return [];
                        }
                        break;
                    case 'vl':
                        // rule matches VariableNode
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__isSymbolNode__as__isVariableNode$3e$__["isVariableNode"])(node)) {
                            res[0].placeholders[rule.name] = node;
                        } else {
                            // mis-match: rule does not encompass current node
                            return [];
                        }
                        break;
                    case 'cd':
                        // rule matches a ConstantNode or unaryMinus-wrapped ConstantNode
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$simplify$2f$wildcards$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNumericNode"])(node)) {
                            res[0].placeholders[rule.name] = node;
                        } else {
                            // mis-match: rule does not encompass current node
                            return [];
                        }
                        break;
                    case 'vd':
                        // rule matches anything other than a ConstantNode or unaryMinus-wrapped ConstantNode
                        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$simplify$2f$wildcards$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isNumericNode"])(node)) {
                            res[0].placeholders[rule.name] = node;
                        } else {
                            // mis-match: rule does not encompass current node
                            return [];
                        }
                        break;
                    case 'ce':
                        // rule matches expressions that have a constant value
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$simplify$2f$wildcards$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isConstantExpression"])(node)) {
                            res[0].placeholders[rule.name] = node;
                        } else {
                            // mis-match: rule does not encompass current node
                            return [];
                        }
                        break;
                    case 've':
                        // rule matches expressions that do not have a constant value
                        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$simplify$2f$wildcards$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isConstantExpression"])(node)) {
                            res[0].placeholders[rule.name] = node;
                        } else {
                            // mis-match: rule does not encompass current node
                            return [];
                        }
                        break;
                    default:
                        throw new Error('Invalid symbol in rule: ' + rule.name);
                }
            }
        } else if (rule instanceof ConstantNode) {
            // Literal constant must match exactly
            if (!equal(rule.value, node.value)) {
                return [];
            }
        } else {
            // Some other node was encountered which we aren't prepared for, so no match
            return [];
        }
        // It's a match!
        // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')
        return res;
    }
    /**
   * Determines whether p and q (and all their children nodes) are identical.
   *
   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p
   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q
   * @return {Object} Information about the match, if it exists.
   */ function _exactMatch(p, q) {
        if (p instanceof ConstantNode && q instanceof ConstantNode) {
            if (!equal(p.value, q.value)) {
                return false;
            }
        } else if (p instanceof SymbolNode && q instanceof SymbolNode) {
            if (p.name !== q.name) {
                return false;
            }
        } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {
            if (p instanceof OperatorNode) {
                if (p.op !== q.op || p.fn !== q.fn) {
                    return false;
                }
            } else if (p instanceof FunctionNode) {
                if (p.name !== q.name) {
                    return false;
                }
            }
            if (p.args.length !== q.args.length) {
                return false;
            }
            for(var i = 0; i < p.args.length; i++){
                if (!_exactMatch(p.args[i], q.args[i])) {
                    return false;
                }
            }
        } else {
            return false;
        }
        return true;
    }
    return simplify;
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSimplifyConstant": (()=>createSimplifyConstant)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$simplify$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/simplify/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$noop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/noop.js [app-client] (ecmascript)");
;
;
;
;
;
var name = 'simplifyConstant';
var dependencies = [
    'typed',
    'config',
    'mathWithTransform',
    'matrix',
    '?fraction',
    '?bignumber',
    'AccessorNode',
    'ArrayNode',
    'ConstantNode',
    'FunctionNode',
    'IndexNode',
    'ObjectNode',
    'OperatorNode',
    'SymbolNode'
];
var createSimplifyConstant = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, mathWithTransform, matrix, fraction, bignumber, AccessorNode, ArrayNode, ConstantNode, FunctionNode, IndexNode, ObjectNode, OperatorNode, SymbolNode } = _ref;
    var { isCommutative, isAssociative, allChildren, createMakeNodeFunction } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$simplify$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createUtil"])({
        FunctionNode,
        OperatorNode,
        SymbolNode
    });
    /**
   * simplifyConstant() takes a mathjs expression (either a Node representing
   * a parse tree or a string which it parses to produce a node), and replaces
   * any subexpression of it consisting entirely of constants with the computed
   * value of that subexpression.
   *
   * Syntax:
   *
   *     math.simplifyConstant(expr)
   *     math.simplifyConstant(expr, options)
   *
   * Examples:
   *
   *     math.simplifyConstant('x + 4*3/6')  // Node "x + 2"
   *     math.simplifyConstant('z cos(0)')   // Node "z 1"
   *     math.simplifyConstant('(5.2 + 1.08)t', {exactFractions: false})  // Node "6.28 t"
   *
   * See also:
   *
   *     simplify, simplifyCore, resolve, derivative
   *
   * @param {Node | string} node
   *     The expression to be simplified
   * @param {Object} options
   *     Simplification options, as per simplify()
   * @return {Node} Returns expression with constant subexpressions evaluated
   */ var simplifyConstant = typed('simplifyConstant', {
        Node: (node)=>_ensureNode(foldFraction(node, {})),
        'Node, Object': function Node_Object(expr, options) {
            return _ensureNode(foldFraction(expr, options));
        }
    });
    function _removeFractions(thing) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFraction"])(thing)) {
            return thing.valueOf();
        }
        if (thing instanceof Array) {
            return thing.map(_removeFractions);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(thing)) {
            return matrix(_removeFractions(thing.valueOf()));
        }
        return thing;
    }
    function _eval(fnname, args, options) {
        try {
            return mathWithTransform[fnname].apply(null, args);
        } catch (ignore) {
            // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions
            args = args.map(_removeFractions);
            return _toNumber(mathWithTransform[fnname].apply(null, args), options);
        }
    }
    var _toNode = typed({
        Fraction: _fractionToNode,
        number: function number(n) {
            if (n < 0) {
                return unaryMinusNode(new ConstantNode(-n));
            }
            return new ConstantNode(n);
        },
        BigNumber: function BigNumber(n) {
            if (n < 0) {
                return unaryMinusNode(new ConstantNode(-n));
            }
            return new ConstantNode(n); // old parameters: (n.toString(), 'number')
        },
        bigint: function bigint(n) {
            if (n < 0n) {
                return unaryMinusNode(new ConstantNode(-n));
            }
            return new ConstantNode(n);
        },
        Complex: function Complex(s) {
            throw new Error('Cannot convert Complex number to Node');
        },
        string: function string(s) {
            return new ConstantNode(s);
        },
        Matrix: function Matrix(m) {
            return new ArrayNode(m.valueOf().map((e)=>_toNode(e)));
        }
    });
    function _ensureNode(thing) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(thing)) {
            return thing;
        }
        return _toNode(thing);
    }
    // convert a number to a fraction only if it can be expressed exactly,
    // and when both numerator and denominator are small enough
    function _exactFraction(n, options) {
        var exactFractions = options && options.exactFractions !== false;
        if (exactFractions && isFinite(n) && fraction) {
            var f = fraction(n);
            var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default
            if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
                return f;
            }
        }
        return n;
    }
    // Convert numbers to a preferred number type in preference order: Fraction, number, Complex
    // BigNumbers are left alone
    var _toNumber = typed({
        'string, Object': function string_Object(s, options) {
            var numericType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeNumberType"])(s, config);
            if (numericType === 'BigNumber') {
                if (bignumber === undefined) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$noop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noBignumber"])();
                }
                return bignumber(s);
            } else if (numericType === 'bigint') {
                return BigInt(s);
            } else if (numericType === 'Fraction') {
                if (fraction === undefined) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$noop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noFraction"])();
                }
                return fraction(s);
            } else {
                var n = parseFloat(s);
                return _exactFraction(n, options);
            }
        },
        'Fraction, Object': function Fraction_Object(s, options) {
            return s;
        },
        // we don't need options here
        'BigNumber, Object': function BigNumber_Object(s, options) {
            return s;
        },
        // we don't need options here
        'number, Object': function number_Object(s, options) {
            return _exactFraction(s, options);
        },
        'bigint, Object': function bigint_Object(s, options) {
            return s;
        },
        'Complex, Object': function Complex_Object(s, options) {
            if (s.im !== 0) {
                return s;
            }
            return _exactFraction(s.re, options);
        },
        'Matrix, Object': function Matrix_Object(s, options) {
            return matrix(_exactFraction(s.valueOf()));
        },
        'Array, Object': function Array_Object(s, options) {
            return s.map(_exactFraction);
        }
    });
    function unaryMinusNode(n) {
        return new OperatorNode('-', 'unaryMinus', [
            n
        ]);
    }
    function _fractionToNode(f) {
        var n;
        var vn = f.s * f.n;
        if (vn < 0) {
            n = new OperatorNode('-', 'unaryMinus', [
                new ConstantNode(-vn)
            ]);
        } else {
            n = new ConstantNode(vn);
        }
        if (f.d === 1) {
            return n;
        }
        return new OperatorNode('/', 'divide', [
            n,
            new ConstantNode(f.d)
        ]);
    }
    /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */ function _foldAccessor(obj, index, options) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexNode"])(index)) {
            // don't know what to do with that...
            return new AccessorNode(_ensureNode(obj), _ensureNode(index));
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArrayNode"])(obj) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(obj)) {
            var remainingDims = Array.from(index.dimensions);
            /* We will resolve constant indices one at a time, looking
       * just in the first or second dimensions because (a) arrays
       * of more than two dimensions are likely rare, and (b) pulling
       * out the third or higher dimension would be pretty intricate.
       * The price is that we miss simplifying [..3d array][x,y,1]
       */ while(remainingDims.length > 0){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {
                    var first = _toNumber(remainingDims.shift().value, options);
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArrayNode"])(obj)) {
                        obj = obj.items[first - 1];
                    } else {
                        // matrix
                        obj = obj.valueOf()[first - 1];
                        if (obj instanceof Array) {
                            obj = matrix(obj);
                        }
                    }
                } else if (remainingDims.length > 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {
                    var second = _toNumber(remainingDims[1].value, options);
                    var tryItems = [];
                    var fromItems = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArrayNode"])(obj) ? obj.items : obj.valueOf();
                    for (var item of fromItems){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArrayNode"])(item)) {
                            tryItems.push(item.items[second - 1]);
                        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMatrix"])(obj)) {
                            tryItems.push(item[second - 1]);
                        } else {
                            break;
                        }
                    }
                    if (tryItems.length === fromItems.length) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArrayNode"])(obj)) {
                            obj = new ArrayNode(tryItems);
                        } else {
                            // matrix
                            obj = matrix(tryItems);
                        }
                        remainingDims.splice(1, 1);
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
            if (remainingDims.length === index.dimensions.length) {
                /* No successful constant indexing */ return new AccessorNode(_ensureNode(obj), index);
            }
            if (remainingDims.length > 0) {
                /* Indexed some but not all dimensions */ index = new IndexNode(remainingDims);
                return new AccessorNode(_ensureNode(obj), index);
            }
            /* All dimensions were constant, access completely resolved */ return obj;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObjectNode"])(obj) && index.dimensions.length === 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(index.dimensions[0])) {
            var key = index.dimensions[0].value;
            if (key in obj.properties) {
                return obj.properties[key];
            }
            return new ConstantNode(); // undefined
        }
        /* Don't know how to index this sort of obj, at least not with this index */ return new AccessorNode(_ensureNode(obj), index);
    }
    /*
   * Create a binary tree from a list of Fractions and Nodes.
   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so
   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).
   * @param args - list of Fractions and Nodes
   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions
   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes
   * if args.length is 1, returns args[0]
   * @return - Either a Node representing a binary expression or Fraction
   */ function foldOp(fn, args, makeNode, options) {
        var first = args.shift();
        // In the following reduction, sofar always has one of the three following
        // forms: [NODE], [CONSTANT], or [NODE, CONSTANT]
        var reduction = args.reduce((sofar, next)=>{
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(next)) {
                var last = sofar.pop();
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(last)) {
                    return [
                        last,
                        next
                    ];
                }
                // Two constants in a row, try to fold them into one
                try {
                    sofar.push(_eval(fn, [
                        last,
                        next
                    ], options));
                    return sofar;
                } catch (ignoreandcontinue) {
                    sofar.push(last);
                // fall through to Node case
                }
            }
            // Encountered a Node, or failed folding --
            // collapse everything so far into a single tree:
            sofar.push(_ensureNode(sofar.pop()));
            var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);
            return [
                makeNode([
                    newtree,
                    _ensureNode(next)
                ])
            ];
        }, [
            first
        ]);
        if (reduction.length === 1) {
            return reduction[0];
        }
        // Might end up with a tree and a constant at the end:
        return makeNode([
            reduction[0],
            _toNode(reduction[1])
        ]);
    }
    // destroys the original node and returns a folded one
    function foldFraction(node, options) {
        switch(node.type){
            case 'SymbolNode':
                return node;
            case 'ConstantNode':
                switch(typeof node.value){
                    case 'number':
                        return _toNumber(node.value, options);
                    case 'bigint':
                        return _toNumber(node.value, options);
                    case 'string':
                        return node.value;
                    default:
                        if (!isNaN(node.value)) return _toNumber(node.value, options);
                }
                return node;
            case 'FunctionNode':
                if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {
                    return node;
                }
                {
                    // Process operators as OperatorNode
                    var operatorFunctions = [
                        'add',
                        'multiply'
                    ];
                    if (!operatorFunctions.includes(node.name)) {
                        var args = node.args.map((arg)=>foldFraction(arg, options));
                        // If all args are numbers
                        if (!args.some(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])) {
                            try {
                                return _eval(node.name, args, options);
                            } catch (ignoreandcontinue) {}
                        }
                        // Size of a matrix does not depend on entries
                        if (node.name === 'size' && args.length === 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArrayNode"])(args[0])) {
                            var sz = [];
                            var section = args[0];
                            while((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArrayNode"])(section)){
                                sz.push(section.items.length);
                                section = section.items[0];
                            }
                            return matrix(sz);
                        }
                        // Convert all args to nodes and construct a symbolic function call
                        return new FunctionNode(node.name, args.map(_ensureNode));
                    } else {
                    // treat as operator
                    }
                }
            /* falls through */ case 'OperatorNode':
                {
                    var fn = node.fn.toString();
                    var _args;
                    var res;
                    var makeNode = createMakeNodeFunction(node);
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(node) && node.isUnary()) {
                        _args = [
                            foldFraction(node.args[0], options)
                        ];
                        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(_args[0])) {
                            res = _eval(fn, _args, options);
                        } else {
                            res = makeNode(_args);
                        }
                    } else if (isAssociative(node, options.context)) {
                        _args = allChildren(node, options.context);
                        _args = _args.map((arg)=>foldFraction(arg, options));
                        if (isCommutative(fn, options.context)) {
                            // commutative binary operator
                            var consts = [];
                            var vars = [];
                            for(var i = 0; i < _args.length; i++){
                                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(_args[i])) {
                                    consts.push(_args[i]);
                                } else {
                                    vars.push(_args[i]);
                                }
                            }
                            if (consts.length > 1) {
                                res = foldOp(fn, consts, makeNode, options);
                                vars.unshift(res);
                                res = foldOp(fn, vars, makeNode, options);
                            } else {
                                // we won't change the children order since it's not neccessary
                                res = foldOp(fn, _args, makeNode, options);
                            }
                        } else {
                            // non-commutative binary operator
                            res = foldOp(fn, _args, makeNode, options);
                        }
                    } else {
                        // non-associative binary operator
                        _args = node.args.map((arg)=>foldFraction(arg, options));
                        res = foldOp(fn, _args, makeNode, options);
                    }
                    return res;
                }
            case 'ParenthesisNode':
                // remove the uneccessary parenthesis
                return foldFraction(node.content, options);
            case 'AccessorNode':
                return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
            case 'ArrayNode':
                {
                    var foldItems = node.items.map((item)=>foldFraction(item, options));
                    if (foldItems.some(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])) {
                        return new ArrayNode(foldItems.map(_ensureNode));
                    }
                    /* All literals -- return a Matrix so we can operate on it */ return matrix(foldItems);
                }
            case 'IndexNode':
                {
                    return new IndexNode(node.dimensions.map((n)=>simplifyConstant(n, options)));
                }
            case 'ObjectNode':
                {
                    var foldProps = {};
                    for(var prop in node.properties){
                        foldProps[prop] = simplifyConstant(node.properties[prop], options);
                    }
                    return new ObjectNode(foldProps);
                }
            case 'AssignmentNode':
            /* falls through */ case 'BlockNode':
            /* falls through */ case 'FunctionAssignmentNode':
            /* falls through */ case 'RangeNode':
            /* falls through */ case 'ConditionalNode':
            /* falls through */ default:
                throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
        }
    }
    return simplifyConstant;
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSimplifyCore": (()=>createSimplifyCore)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$expression$2f$operators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/expression/operators.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$simplify$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/function/algebra/simplify/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
;
;
var name = 'simplifyCore';
var dependencies = [
    'typed',
    'parse',
    'equal',
    'isZero',
    'add',
    'subtract',
    'multiply',
    'divide',
    'pow',
    'AccessorNode',
    'ArrayNode',
    'ConstantNode',
    'FunctionNode',
    'IndexNode',
    'ObjectNode',
    'OperatorNode',
    'ParenthesisNode',
    'SymbolNode'
];
var createSimplifyCore = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, parse, equal, isZero, add, subtract, multiply, divide, pow, AccessorNode, ArrayNode, ConstantNode, FunctionNode, IndexNode, ObjectNode, OperatorNode, ParenthesisNode, SymbolNode } = _ref;
    var node0 = new ConstantNode(0);
    var node1 = new ConstantNode(1);
    var nodeT = new ConstantNode(true);
    var nodeF = new ConstantNode(false);
    // test if a node will always have a boolean value (true/false)
    // not sure if this list is complete
    function isAlwaysBoolean(node) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(node) && [
            'and',
            'not',
            'or'
        ].includes(node.op);
    }
    var { hasProperty, isCommutative } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$function$2f$algebra$2f$simplify$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createUtil"])({
        FunctionNode,
        OperatorNode,
        SymbolNode
    });
    /**
   * simplifyCore() performs single pass simplification suitable for
   * applications requiring ultimate performance. To roughly summarize,
   * it handles cases along the lines of simplifyConstant() but where
   * knowledge of a single argument is sufficient to determine the value.
   * In contrast, simplify() extends simplifyCore() with additional passes
   * to provide deeper simplification (such as gathering like terms).
   *
   * Specifically, simplifyCore:
   *
   * * Converts all function calls with operator equivalents to their
   *   operator forms.
   * * Removes operators or function calls that are guaranteed to have no
   *   effect (such as unary '+').
   * * Removes double unary '-', '~', and 'not'
   * * Eliminates addition/subtraction of 0 and multiplication/division/powers
   *   by 1 or 0.
   * * Converts addition of a negation into subtraction.
   * * Eliminates logical operations with constant true or false leading
   *   arguments.
   * * Puts constants on the left of a product, if multiplication is
   *   considered commutative by the options (which is the default)
   *
   * Syntax:
   *
   *     math.simplifyCore(expr)
   *     math.simplifyCore(expr, options)
   *
   * Examples:
   *
   *     const f = math.parse('2 * 1 * x ^ (1 - 0)')
   *     math.simplifyCore(f)                          // Node "2 * x"
   *     math.simplify('2 * 1 * x ^ (1 - 0)', [math.simplifyCore]) // Node "2 * x"
   *
   * See also:
   *
   *     simplify, simplifyConstant, resolve, derivative
   *
   * @param {Node | string} node
   *     The expression to be simplified
   * @param {Object} options
   *     Simplification options, as per simplify()
   * @return {Node} Returns expression with basic simplifications applied
   */ function _simplifyCore(nodeToSimplify) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var context = options ? options.context : undefined;
        if (hasProperty(nodeToSimplify, 'trivial', context)) {
            // This node does nothing if it has only one argument, so if so,
            // return that argument simplified
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunctionNode"])(nodeToSimplify) && nodeToSimplify.args.length === 1) {
                return _simplifyCore(nodeToSimplify.args[0], options);
            }
            // For other node types, we try the generic methods
            var simpChild = false;
            var childCount = 0;
            nodeToSimplify.forEach((c)=>{
                ++childCount;
                if (childCount === 1) {
                    simpChild = _simplifyCore(c, options);
                }
            });
            if (childCount === 1) {
                return simpChild;
            }
        }
        var node = nodeToSimplify;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunctionNode"])(node)) {
            var op = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$expression$2f$operators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOperator"])(node.name);
            if (op) {
                // Replace FunctionNode with a new OperatorNode
                if (node.args.length > 2 && hasProperty(node, 'associative', context)) {
                    // unflatten into binary operations since that's what simplifyCore handles
                    while(node.args.length > 2){
                        var last = node.args.pop();
                        var seclast = node.args.pop();
                        node.args.push(new OperatorNode(op, node.name, [
                            last,
                            seclast
                        ]));
                    }
                }
                node = new OperatorNode(op, node.name, node.args);
            } else {
                return new FunctionNode(_simplifyCore(node.fn), node.args.map((n)=>_simplifyCore(n, options)));
            }
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(node) && node.isUnary()) {
            var a0 = _simplifyCore(node.args[0], options);
            if (node.op === '~') {
                // bitwise not
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(a0) && a0.isUnary() && a0.op === '~') {
                    return a0.args[0];
                }
            }
            if (node.op === 'not') {
                // logical not
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(a0) && a0.isUnary() && a0.op === 'not') {
                    // Has the effect of turning the argument into a boolean
                    // So can only eliminate the double negation if
                    // the inside is already boolean
                    if (isAlwaysBoolean(a0.args[0])) {
                        return a0.args[0];
                    }
                }
            }
            var finish = true;
            if (node.op === '-') {
                // unary minus
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(a0)) {
                    if (a0.isBinary() && a0.fn === 'subtract') {
                        node = new OperatorNode('-', 'subtract', [
                            a0.args[1],
                            a0.args[0]
                        ]);
                        finish = false; // continue to process the new binary node
                    }
                    if (a0.isUnary() && a0.op === '-') {
                        return a0.args[0];
                    }
                }
            }
            if (finish) return new OperatorNode(node.op, node.fn, [
                a0
            ]);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(node) && node.isBinary()) {
            var _a = _simplifyCore(node.args[0], options);
            var a1 = _simplifyCore(node.args[1], options);
            if (node.op === '+') {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(_a) && isZero(_a.value)) {
                    return a1;
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(a1) && isZero(a1.value)) {
                    return _a;
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(a1) && a1.isUnary() && a1.op === '-') {
                    a1 = a1.args[0];
                    node = new OperatorNode('-', 'subtract', [
                        _a,
                        a1
                    ]);
                }
            }
            if (node.op === '-') {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(a1) && a1.isUnary() && a1.op === '-') {
                    return _simplifyCore(new OperatorNode('+', 'add', [
                        _a,
                        a1.args[0]
                    ]), options);
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(_a) && isZero(_a.value)) {
                    return _simplifyCore(new OperatorNode('-', 'unaryMinus', [
                        a1
                    ]));
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(a1) && isZero(a1.value)) {
                    return _a;
                }
                return new OperatorNode(node.op, node.fn, [
                    _a,
                    a1
                ]);
            }
            if (node.op === '*') {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(_a)) {
                    if (isZero(_a.value)) {
                        return node0;
                    } else if (equal(_a.value, 1)) {
                        return a1;
                    }
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(a1)) {
                    if (isZero(a1.value)) {
                        return node0;
                    } else if (equal(a1.value, 1)) {
                        return _a;
                    }
                    if (isCommutative(node, context)) {
                        return new OperatorNode(node.op, node.fn, [
                            a1,
                            _a
                        ], node.implicit); // constants on left
                    }
                }
                return new OperatorNode(node.op, node.fn, [
                    _a,
                    a1
                ], node.implicit);
            }
            if (node.op === '/') {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(_a) && isZero(_a.value)) {
                    return node0;
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(a1) && equal(a1.value, 1)) {
                    return _a;
                }
                return new OperatorNode(node.op, node.fn, [
                    _a,
                    a1
                ]);
            }
            if (node.op === '^') {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(a1)) {
                    if (isZero(a1.value)) {
                        return node1;
                    } else if (equal(a1.value, 1)) {
                        return _a;
                    }
                }
            }
            if (node.op === 'and') {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(_a)) {
                    if (_a.value) {
                        if (isAlwaysBoolean(a1)) return a1;
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(a1)) {
                            return a1.value ? nodeT : nodeF;
                        }
                    } else {
                        return nodeF;
                    }
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(a1)) {
                    if (a1.value) {
                        if (isAlwaysBoolean(_a)) return _a;
                    } else {
                        return nodeF;
                    }
                }
            }
            if (node.op === 'or') {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(_a)) {
                    if (_a.value) {
                        return nodeT;
                    } else {
                        if (isAlwaysBoolean(a1)) return a1;
                    }
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(a1)) {
                    if (a1.value) {
                        return nodeT;
                    } else {
                        if (isAlwaysBoolean(_a)) return _a;
                    }
                }
            }
            return new OperatorNode(node.op, node.fn, [
                _a,
                a1
            ]);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(node)) {
            return new OperatorNode(node.op, node.fn, node.args.map((a)=>_simplifyCore(a, options)));
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArrayNode"])(node)) {
            return new ArrayNode(node.items.map((n)=>_simplifyCore(n, options)));
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAccessorNode"])(node)) {
            return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexNode"])(node)) {
            return new IndexNode(node.dimensions.map((n)=>_simplifyCore(n, options)));
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObjectNode"])(node)) {
            var newProps = {};
            for(var prop in node.properties){
                newProps[prop] = _simplifyCore(node.properties[prop], options);
            }
            return new ObjectNode(newProps);
        }
        // cannot simplify
        return node;
    }
    return typed(name, {
        Node: _simplifyCore,
        'Node,Object': _simplifyCore
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/resolve.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createResolve": (()=>createResolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
;
var name = 'resolve';
var dependencies = [
    'typed',
    'parse',
    'ConstantNode',
    'FunctionNode',
    'OperatorNode',
    'ParenthesisNode'
];
var createResolve = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, parse, ConstantNode, FunctionNode, OperatorNode, ParenthesisNode } = _ref;
    /**
   * resolve(expr, scope) replaces variable nodes with their scoped values
   *
   * Syntax:
   *
   *     math.resolve(expr, scope)
   *
   * Examples:
   *
   *     math.resolve('x + y', {x:1, y:2})           // Node '1 + 2'
   *     math.resolve(math.parse('x+y'), {x:1, y:2}) // Node '1 + 2'
   *     math.simplify('x+y', {x:2, y: math.parse('x+x')}).toString() // "6"
   *
   * See also:
   *
   *     simplify, evaluate
   *
   * @param {Node | Node[]} node
   *     The expression tree (or trees) to be simplified
   * @param {Object} scope
   *     Scope specifying variables to be resolved
   * @return {Node | Node[]} Returns `node` with variables recursively substituted.
   * @throws {ReferenceError}
   *     If there is a cyclic dependency among the variables in `scope`,
   *     resolution is impossible and a ReferenceError is thrown.
   */ function _resolve(node, scope) {
        var within = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
        // note `within`:
        // `within` is not documented, since it is for internal cycle
        // detection only
        if (!scope) {
            return node;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSymbolNode"])(node)) {
            if (within.has(node.name)) {
                var variables = Array.from(within).join(', ');
                throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
            }
            var value = scope.get(node.name);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNode"])(value)) {
                var nextWithin = new Set(within);
                nextWithin.add(node.name);
                return _resolve(value, scope, nextWithin);
            } else if (typeof value === 'number') {
                return parse(String(value));
            } else if (value !== undefined) {
                return new ConstantNode(value);
            } else {
                return node;
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOperatorNode"])(node)) {
            var args = node.args.map(function(arg) {
                return _resolve(arg, scope, within);
            });
            return new OperatorNode(node.op, node.fn, args, node.implicit);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isParenthesisNode"])(node)) {
            return new ParenthesisNode(_resolve(node.content, scope, within));
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunctionNode"])(node)) {
            var _args = node.args.map(function(arg) {
                return _resolve(arg, scope, within);
            });
            return new FunctionNode(node.name, _args);
        }
        // Otherwise just recursively resolve any children (might also work
        // for some of the above special cases)
        return node.map((child)=>_resolve(child, scope, within));
    }
    return typed('resolve', {
        Node: _resolve,
        'Node, Map | null | undefined': _resolve,
        'Node, Object': (n, scope)=>_resolve(n, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createMap"])(scope)),
        // For arrays and matrices, we map `self` rather than `_resolve`
        // because resolve is fairly expensive anyway, and this way
        // we get nice error messages if one entry in the array has wrong type.
        'Array | Matrix': typed.referToSelf((self)=>(A)=>A.map((n)=>self(n))),
        'Array | Matrix, null | undefined': typed.referToSelf((self)=>(A)=>A.map((n)=>self(n))),
        'Array, Object': typed.referTo('Array,Map', (selfAM)=>(A, scope)=>selfAM(A, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createMap"])(scope))),
        'Matrix, Object': typed.referTo('Matrix,Map', (selfMM)=>(A, scope)=>selfMM(A, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createMap"])(scope))),
        'Array | Matrix, Map': typed.referToSelf((self)=>(A, scope)=>A.map((n)=>self(n, scope)))
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createSymbolicEqual": (()=>createSymbolicEqual)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
var name = 'symbolicEqual';
var dependencies = [
    'parse',
    'simplify',
    'typed',
    'OperatorNode'
];
var createSymbolicEqual = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { parse, simplify, typed, OperatorNode } = _ref;
    /**
   * Attempts to determine if two expressions are symbolically equal, i.e.
   * one is the result of valid algebraic manipulations on the other.
   * Currently, this simply checks if the difference of the two expressions
   * simplifies down to 0. So there are two important caveats:
   * 1. whether two expressions are symbolically equal depends on the
   *     manipulations allowed. Therefore, this function takes an optional
   *     third argument, which are the options that control the behavior
   *     as documented for the `simplify()` function.
   * 2. it is in general intractable to find the minimal simplification of
   *     an arbitrarily complicated expression. So while a `true` value
   *     of `symbolicEqual` ensures that the two expressions can be manipulated
   *     to match each other, a `false` value does not absolutely rule this out.
   *
   * Syntax:
   *
   *     math.symbolicEqual(expr1, expr2)
   *     math.symbolicEqual(expr1, expr2, options)
   *
   * Examples:
   *
   *     math.symbolicEqual('x*y', 'y*x') // Returns true
   *     math.symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}}) // Returns false
   *     math.symbolicEqual('x/y', '(y*x^(-1))^(-1)') // Returns true
   *     math.symbolicEqual('abs(x)','x') // Returns false
   *     math.symbolicEqual('abs(x)','x', simplify.positiveContext) // Returns true
   *
   * See also:
   *
   *     simplify, evaluate
   *
   * @param {Node|string} expr1  The first expression to compare
   * @param {Node|string} expr2  The second expression to compare
   * @param {Object} [options] Optional option object, passed to simplify
   * @returns {boolean}
   *     Returns true if a valid manipulation making the expressions equal
   *     is found.
   */ function _symbolicEqual(e1, e2) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var diff = new OperatorNode('-', 'subtract', [
            e1,
            e2
        ]);
        var simplified = simplify(diff, {}, options);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(simplified) && !simplified.value;
    }
    return typed(name, {
        'Node, Node': _symbolicEqual,
        'Node, Node, Object': _symbolicEqual
    });
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/derivative.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDerivative": (()=>createDerivative)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/is.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-client] (ecmascript)");
;
;
;
var name = 'derivative';
var dependencies = [
    'typed',
    'config',
    'parse',
    'simplify',
    'equal',
    'isZero',
    'numeric',
    'ConstantNode',
    'FunctionNode',
    'OperatorNode',
    'ParenthesisNode',
    'SymbolNode'
];
var createDerivative = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { typed, config, parse, simplify, equal, isZero, numeric, ConstantNode, FunctionNode, OperatorNode, ParenthesisNode, SymbolNode } = _ref;
    /**
   * Takes the derivative of an expression expressed in parser Nodes.
   * The derivative will be taken over the supplied variable in the
   * second parameter. If there are multiple variables in the expression,
   * it will return a partial derivative.
   *
   * This uses rules of differentiation which can be found here:
   *
   * - [Differentiation rules (Wikipedia)](https://en.wikipedia.org/wiki/Differentiation_rules)
   *
   * Syntax:
   *
   *     math.derivative(expr, variable)
   *     math.derivative(expr, variable, options)
   *
   * Examples:
   *
   *     math.derivative('x^2', 'x')                     // Node '2 * x'
   *     math.derivative('x^2', 'x', {simplify: false})  // Node '2 * 1 * x ^ (2 - 1)'
   *     math.derivative('sin(2x)', 'x'))                // Node '2 * cos(2 * x)'
   *     math.derivative('2*x', 'x').evaluate()          // number 2
   *     math.derivative('x^2', 'x').evaluate({x: 4})    // number 8
   *     const f = math.parse('x^2')
   *     const x = math.parse('x')
   *     math.derivative(f, x)                           // Node {2 * x}
   *
   * See also:
   *
   *     simplify, parse, evaluate
   *
   * @param  {Node | string} expr           The expression to differentiate
   * @param  {SymbolNode | string} variable The variable over which to differentiate
   * @param  {{simplify: boolean}} [options]
   *                         There is one option available, `simplify`, which
   *                         is true by default. When false, output will not
   *                         be simplified.
   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`
   */ function plainDerivative(expr, variable) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
            simplify: true
        };
        var constNodes = {};
        constTag(constNodes, expr, variable.name);
        var res = _derivative(expr, constNodes);
        return options.simplify ? simplify(res) : res;
    }
    function parseIdentifier(string) {
        var symbol = parse(string);
        if (!symbol.isSymbolNode) {
            throw new TypeError('Invalid variable. ' + "Cannot parse ".concat(JSON.stringify(string), " into a variable in function derivative"));
        }
        return symbol;
    }
    var derivative = typed(name, {
        'Node, SymbolNode': plainDerivative,
        'Node, SymbolNode, Object': plainDerivative,
        'Node, string': (node, symbol)=>plainDerivative(node, parseIdentifier(symbol)),
        'Node, string, Object': (node, symbol, options)=>plainDerivative(node, parseIdentifier(symbol), options)
    });
    derivative._simplify = true;
    derivative.toTex = function(deriv) {
        return _derivTex.apply(null, deriv.args);
    };
    // FIXME: move the toTex method of derivative to latex.js. Difficulty is that it relies on parse.
    // NOTE: the optional "order" parameter here is currently unused
    var _derivTex = typed('_derivTex', {
        'Node, SymbolNode': function Node_SymbolNode(expr, x) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(expr) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"])(expr.value) === 'string') {
                return _derivTex(parse(expr.value).toString(), x.toString(), 1);
            } else {
                return _derivTex(expr.toTex(), x.toString(), 1);
            }
        },
        'Node, ConstantNode': function Node_ConstantNode(expr, x) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeOf"])(x.value) === 'string') {
                return _derivTex(expr, parse(x.value));
            } else {
                throw new Error("The second parameter to 'derivative' is a non-string constant");
            }
        },
        'Node, SymbolNode, ConstantNode': function Node_SymbolNode_ConstantNode(expr, x, order) {
            return _derivTex(expr.toString(), x.name, order.value);
        },
        'string, string, number': function string_string_number(expr, x, order) {
            var d;
            if (order === 1) {
                d = '{d\\over d' + x + '}';
            } else {
                d = '{d^{' + order + '}\\over d' + x + '^{' + order + '}}';
            }
            return d + "\\left[".concat(expr, "\\right]");
        }
    });
    /**
   * Does a depth-first search on the expression tree to identify what Nodes
   * are constants (e.g. 2 + 2), and stores the ones that are constants in
   * constNodes. Classification is done as follows:
   *
   *   1. ConstantNodes are constants.
   *   2. If there exists a SymbolNode, of which we are differentiating over,
   *      in the subtree it is not constant.
   *
   * @param  {Object} constNodes  Holds the nodes that are constant
   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
   * @param  {string} varName     Variable that we are differentiating
   * @return {boolean}  if node is constant
   */ // TODO: can we rewrite constTag into a pure function?
    var constTag = typed('constTag', {
        'Object, ConstantNode, string': function Object_ConstantNode_string(constNodes, node) {
            constNodes[node] = true;
            return true;
        },
        'Object, SymbolNode, string': function Object_SymbolNode_string(constNodes, node, varName) {
            // Treat other variables like constants. For reasoning, see:
            //   https://en.wikipedia.org/wiki/Partial_derivative
            if (node.name !== varName) {
                constNodes[node] = true;
                return true;
            }
            return false;
        },
        'Object, ParenthesisNode, string': function Object_ParenthesisNode_string(constNodes, node, varName) {
            return constTag(constNodes, node.content, varName);
        },
        'Object, FunctionAssignmentNode, string': function Object_FunctionAssignmentNode_string(constNodes, node, varName) {
            if (!node.params.includes(varName)) {
                constNodes[node] = true;
                return true;
            }
            return constTag(constNodes, node.expr, varName);
        },
        'Object, FunctionNode | OperatorNode, string': function Object_FunctionNode__OperatorNode_string(constNodes, node, varName) {
            if (node.args.length > 0) {
                var isConst = constTag(constNodes, node.args[0], varName);
                for(var i = 1; i < node.args.length; ++i){
                    isConst = constTag(constNodes, node.args[i], varName) && isConst;
                }
                if (isConst) {
                    constNodes[node] = true;
                    return true;
                }
            }
            return false;
        }
    });
    /**
   * Applies differentiation rules.
   *
   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node
   * @param  {Object} constNodes  Holds the nodes that are constant
   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`
   */ var _derivative = typed('_derivative', {
        'ConstantNode, Object': function ConstantNode_Object(node) {
            return createConstantNode(0);
        },
        'SymbolNode, Object': function SymbolNode_Object(node, constNodes) {
            if (constNodes[node] !== undefined) {
                return createConstantNode(0);
            }
            return createConstantNode(1);
        },
        'ParenthesisNode, Object': function ParenthesisNode_Object(node, constNodes) {
            return new ParenthesisNode(_derivative(node.content, constNodes));
        },
        'FunctionAssignmentNode, Object': function FunctionAssignmentNode_Object(node, constNodes) {
            if (constNodes[node] !== undefined) {
                return createConstantNode(0);
            }
            return _derivative(node.expr, constNodes);
        },
        'FunctionNode, Object': function FunctionNode_Object(node, constNodes) {
            if (constNodes[node] !== undefined) {
                return createConstantNode(0);
            }
            var arg0 = node.args[0];
            var arg1;
            var div = false; // is output a fraction?
            var negative = false; // is output negative?
            var funcDerivative;
            switch(node.name){
                case 'cbrt':
                    // d/dx(cbrt(x)) = 1 / (3x^(2/3))
                    div = true;
                    funcDerivative = new OperatorNode('*', 'multiply', [
                        createConstantNode(3),
                        new OperatorNode('^', 'pow', [
                            arg0,
                            new OperatorNode('/', 'divide', [
                                createConstantNode(2),
                                createConstantNode(3)
                            ])
                        ])
                    ]);
                    break;
                case 'sqrt':
                case 'nthRoot':
                    // d/dx(sqrt(x)) = 1 / (2*sqrt(x))
                    if (node.args.length === 1) {
                        div = true;
                        funcDerivative = new OperatorNode('*', 'multiply', [
                            createConstantNode(2),
                            new FunctionNode('sqrt', [
                                arg0
                            ])
                        ]);
                    } else if (node.args.length === 2) {
                        // Rearrange from nthRoot(x, a) -> x^(1/a)
                        arg1 = new OperatorNode('/', 'divide', [
                            createConstantNode(1),
                            node.args[1]
                        ]);
                        // Is a variable?
                        constNodes[arg1] = constNodes[node.args[1]];
                        return _derivative(new OperatorNode('^', 'pow', [
                            arg0,
                            arg1
                        ]), constNodes);
                    }
                    break;
                case 'log10':
                    arg1 = createConstantNode(10);
                /* fall through! */ case 'log':
                    if (!arg1 && node.args.length === 1) {
                        // d/dx(log(x)) = 1 / x
                        funcDerivative = arg0.clone();
                        div = true;
                    } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {
                        // d/dx(log(x, c)) = 1 / (x*ln(c))
                        funcDerivative = new OperatorNode('*', 'multiply', [
                            arg0.clone(),
                            new FunctionNode('log', [
                                arg1 || node.args[1]
                            ])
                        ]);
                        div = true;
                    } else if (node.args.length === 2) {
                        // d/dx(log(f(x), g(x))) = d/dx(log(f(x)) / log(g(x)))
                        return _derivative(new OperatorNode('/', 'divide', [
                            new FunctionNode('log', [
                                arg0
                            ]),
                            new FunctionNode('log', [
                                node.args[1]
                            ])
                        ]), constNodes);
                    }
                    break;
                case 'pow':
                    if (node.args.length === 2) {
                        constNodes[arg1] = constNodes[node.args[1]];
                        // Pass to pow operator node parser
                        return _derivative(new OperatorNode('^', 'pow', [
                            arg0,
                            node.args[1]
                        ]), constNodes);
                    }
                    break;
                case 'exp':
                    // d/dx(e^x) = e^x
                    funcDerivative = new FunctionNode('exp', [
                        arg0.clone()
                    ]);
                    break;
                case 'sin':
                    // d/dx(sin(x)) = cos(x)
                    funcDerivative = new FunctionNode('cos', [
                        arg0.clone()
                    ]);
                    break;
                case 'cos':
                    // d/dx(cos(x)) = -sin(x)
                    funcDerivative = new OperatorNode('-', 'unaryMinus', [
                        new FunctionNode('sin', [
                            arg0.clone()
                        ])
                    ]);
                    break;
                case 'tan':
                    // d/dx(tan(x)) = sec(x)^2
                    funcDerivative = new OperatorNode('^', 'pow', [
                        new FunctionNode('sec', [
                            arg0.clone()
                        ]),
                        createConstantNode(2)
                    ]);
                    break;
                case 'sec':
                    // d/dx(sec(x)) = sec(x)tan(x)
                    funcDerivative = new OperatorNode('*', 'multiply', [
                        node,
                        new FunctionNode('tan', [
                            arg0.clone()
                        ])
                    ]);
                    break;
                case 'csc':
                    // d/dx(csc(x)) = -csc(x)cot(x)
                    negative = true;
                    funcDerivative = new OperatorNode('*', 'multiply', [
                        node,
                        new FunctionNode('cot', [
                            arg0.clone()
                        ])
                    ]);
                    break;
                case 'cot':
                    // d/dx(cot(x)) = -csc(x)^2
                    negative = true;
                    funcDerivative = new OperatorNode('^', 'pow', [
                        new FunctionNode('csc', [
                            arg0.clone()
                        ]),
                        createConstantNode(2)
                    ]);
                    break;
                case 'asin':
                    // d/dx(asin(x)) = 1 / sqrt(1 - x^2)
                    div = true;
                    funcDerivative = new FunctionNode('sqrt', [
                        new OperatorNode('-', 'subtract', [
                            createConstantNode(1),
                            new OperatorNode('^', 'pow', [
                                arg0.clone(),
                                createConstantNode(2)
                            ])
                        ])
                    ]);
                    break;
                case 'acos':
                    // d/dx(acos(x)) = -1 / sqrt(1 - x^2)
                    div = true;
                    negative = true;
                    funcDerivative = new FunctionNode('sqrt', [
                        new OperatorNode('-', 'subtract', [
                            createConstantNode(1),
                            new OperatorNode('^', 'pow', [
                                arg0.clone(),
                                createConstantNode(2)
                            ])
                        ])
                    ]);
                    break;
                case 'atan':
                    // d/dx(atan(x)) = 1 / (x^2 + 1)
                    div = true;
                    funcDerivative = new OperatorNode('+', 'add', [
                        new OperatorNode('^', 'pow', [
                            arg0.clone(),
                            createConstantNode(2)
                        ]),
                        createConstantNode(1)
                    ]);
                    break;
                case 'asec':
                    // d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))
                    div = true;
                    funcDerivative = new OperatorNode('*', 'multiply', [
                        new FunctionNode('abs', [
                            arg0.clone()
                        ]),
                        new FunctionNode('sqrt', [
                            new OperatorNode('-', 'subtract', [
                                new OperatorNode('^', 'pow', [
                                    arg0.clone(),
                                    createConstantNode(2)
                                ]),
                                createConstantNode(1)
                            ])
                        ])
                    ]);
                    break;
                case 'acsc':
                    // d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))
                    div = true;
                    negative = true;
                    funcDerivative = new OperatorNode('*', 'multiply', [
                        new FunctionNode('abs', [
                            arg0.clone()
                        ]),
                        new FunctionNode('sqrt', [
                            new OperatorNode('-', 'subtract', [
                                new OperatorNode('^', 'pow', [
                                    arg0.clone(),
                                    createConstantNode(2)
                                ]),
                                createConstantNode(1)
                            ])
                        ])
                    ]);
                    break;
                case 'acot':
                    // d/dx(acot(x)) = -1 / (x^2 + 1)
                    div = true;
                    negative = true;
                    funcDerivative = new OperatorNode('+', 'add', [
                        new OperatorNode('^', 'pow', [
                            arg0.clone(),
                            createConstantNode(2)
                        ]),
                        createConstantNode(1)
                    ]);
                    break;
                case 'sinh':
                    // d/dx(sinh(x)) = cosh(x)
                    funcDerivative = new FunctionNode('cosh', [
                        arg0.clone()
                    ]);
                    break;
                case 'cosh':
                    // d/dx(cosh(x)) = sinh(x)
                    funcDerivative = new FunctionNode('sinh', [
                        arg0.clone()
                    ]);
                    break;
                case 'tanh':
                    // d/dx(tanh(x)) = sech(x)^2
                    funcDerivative = new OperatorNode('^', 'pow', [
                        new FunctionNode('sech', [
                            arg0.clone()
                        ]),
                        createConstantNode(2)
                    ]);
                    break;
                case 'sech':
                    // d/dx(sech(x)) = -sech(x)tanh(x)
                    negative = true;
                    funcDerivative = new OperatorNode('*', 'multiply', [
                        node,
                        new FunctionNode('tanh', [
                            arg0.clone()
                        ])
                    ]);
                    break;
                case 'csch':
                    // d/dx(csch(x)) = -csch(x)coth(x)
                    negative = true;
                    funcDerivative = new OperatorNode('*', 'multiply', [
                        node,
                        new FunctionNode('coth', [
                            arg0.clone()
                        ])
                    ]);
                    break;
                case 'coth':
                    // d/dx(coth(x)) = -csch(x)^2
                    negative = true;
                    funcDerivative = new OperatorNode('^', 'pow', [
                        new FunctionNode('csch', [
                            arg0.clone()
                        ]),
                        createConstantNode(2)
                    ]);
                    break;
                case 'asinh':
                    // d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)
                    div = true;
                    funcDerivative = new FunctionNode('sqrt', [
                        new OperatorNode('+', 'add', [
                            new OperatorNode('^', 'pow', [
                                arg0.clone(),
                                createConstantNode(2)
                            ]),
                            createConstantNode(1)
                        ])
                    ]);
                    break;
                case 'acosh':
                    // d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)
                    div = true;
                    funcDerivative = new FunctionNode('sqrt', [
                        new OperatorNode('-', 'subtract', [
                            new OperatorNode('^', 'pow', [
                                arg0.clone(),
                                createConstantNode(2)
                            ]),
                            createConstantNode(1)
                        ])
                    ]);
                    break;
                case 'atanh':
                    // d/dx(atanh(x)) = 1 / (1 - x^2)
                    div = true;
                    funcDerivative = new OperatorNode('-', 'subtract', [
                        createConstantNode(1),
                        new OperatorNode('^', 'pow', [
                            arg0.clone(),
                            createConstantNode(2)
                        ])
                    ]);
                    break;
                case 'asech':
                    // d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))
                    div = true;
                    negative = true;
                    funcDerivative = new OperatorNode('*', 'multiply', [
                        arg0.clone(),
                        new FunctionNode('sqrt', [
                            new OperatorNode('-', 'subtract', [
                                createConstantNode(1),
                                new OperatorNode('^', 'pow', [
                                    arg0.clone(),
                                    createConstantNode(2)
                                ])
                            ])
                        ])
                    ]);
                    break;
                case 'acsch':
                    // d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))
                    div = true;
                    negative = true;
                    funcDerivative = new OperatorNode('*', 'multiply', [
                        new FunctionNode('abs', [
                            arg0.clone()
                        ]),
                        new FunctionNode('sqrt', [
                            new OperatorNode('+', 'add', [
                                new OperatorNode('^', 'pow', [
                                    arg0.clone(),
                                    createConstantNode(2)
                                ]),
                                createConstantNode(1)
                            ])
                        ])
                    ]);
                    break;
                case 'acoth':
                    // d/dx(acoth(x)) = -1 / (1 - x^2)
                    div = true;
                    negative = true;
                    funcDerivative = new OperatorNode('-', 'subtract', [
                        createConstantNode(1),
                        new OperatorNode('^', 'pow', [
                            arg0.clone(),
                            createConstantNode(2)
                        ])
                    ]);
                    break;
                case 'abs':
                    // d/dx(abs(x)) = abs(x)/x
                    funcDerivative = new OperatorNode('/', 'divide', [
                        new FunctionNode(new SymbolNode('abs'), [
                            arg0.clone()
                        ]),
                        arg0.clone()
                    ]);
                    break;
                case 'gamma':
                default:
                    throw new Error('Cannot process function "' + node.name + '" in derivative: ' + 'the function is not supported, undefined, or the number of arguments passed to it are not supported');
            }
            var op, func;
            if (div) {
                op = '/';
                func = 'divide';
            } else {
                op = '*';
                func = 'multiply';
            }
            /* Apply chain rule to all functions:
         F(x)  = f(g(x))
         F'(x) = g'(x)*f'(g(x)) */ var chainDerivative = _derivative(arg0, constNodes);
            if (negative) {
                chainDerivative = new OperatorNode('-', 'unaryMinus', [
                    chainDerivative
                ]);
            }
            return new OperatorNode(op, func, [
                chainDerivative,
                funcDerivative
            ]);
        },
        'OperatorNode, Object': function OperatorNode_Object(node, constNodes) {
            if (constNodes[node] !== undefined) {
                return createConstantNode(0);
            }
            if (node.op === '+') {
                // d/dx(sum(f(x)) = sum(f'(x))
                return new OperatorNode(node.op, node.fn, node.args.map(function(arg) {
                    return _derivative(arg, constNodes);
                }));
            }
            if (node.op === '-') {
                // d/dx(+/-f(x)) = +/-f'(x)
                if (node.isUnary()) {
                    return new OperatorNode(node.op, node.fn, [
                        _derivative(node.args[0], constNodes)
                    ]);
                }
                // Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)
                if (node.isBinary()) {
                    return new OperatorNode(node.op, node.fn, [
                        _derivative(node.args[0], constNodes),
                        _derivative(node.args[1], constNodes)
                    ]);
                }
            }
            if (node.op === '*') {
                // d/dx(c*f(x)) = c*f'(x)
                var constantTerms = node.args.filter(function(arg) {
                    return constNodes[arg] !== undefined;
                });
                if (constantTerms.length > 0) {
                    var nonConstantTerms = node.args.filter(function(arg) {
                        return constNodes[arg] === undefined;
                    });
                    var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode('*', 'multiply', nonConstantTerms);
                    var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
                    return new OperatorNode('*', 'multiply', newArgs);
                }
                // Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)
                return new OperatorNode('+', 'add', node.args.map(function(argOuter) {
                    return new OperatorNode('*', 'multiply', node.args.map(function(argInner) {
                        return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
                    }));
                }));
            }
            if (node.op === '/' && node.isBinary()) {
                var arg0 = node.args[0];
                var arg1 = node.args[1];
                // d/dx(f(x) / c) = f'(x) / c
                if (constNodes[arg1] !== undefined) {
                    return new OperatorNode('/', 'divide', [
                        _derivative(arg0, constNodes),
                        arg1
                    ]);
                }
                // Reciprocal Rule, d/dx(c / f(x)) = -c(f'(x)/f(x)^2)
                if (constNodes[arg0] !== undefined) {
                    return new OperatorNode('*', 'multiply', [
                        new OperatorNode('-', 'unaryMinus', [
                            arg0
                        ]),
                        new OperatorNode('/', 'divide', [
                            _derivative(arg1, constNodes),
                            new OperatorNode('^', 'pow', [
                                arg1.clone(),
                                createConstantNode(2)
                            ])
                        ])
                    ]);
                }
                // Quotient rule, d/dx(f(x) / g(x)) = (f'(x)g(x) - f(x)g'(x)) / g(x)^2
                return new OperatorNode('/', 'divide', [
                    new OperatorNode('-', 'subtract', [
                        new OperatorNode('*', 'multiply', [
                            _derivative(arg0, constNodes),
                            arg1.clone()
                        ]),
                        new OperatorNode('*', 'multiply', [
                            arg0.clone(),
                            _derivative(arg1, constNodes)
                        ])
                    ]),
                    new OperatorNode('^', 'pow', [
                        arg1.clone(),
                        createConstantNode(2)
                    ])
                ]);
            }
            if (node.op === '^' && node.isBinary()) {
                var _arg = node.args[0];
                var _arg2 = node.args[1];
                if (constNodes[_arg] !== undefined) {
                    // If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {
                        return createConstantNode(0);
                    }
                    // d/dx(c^f(x)) = c^f(x)*ln(c)*f'(x)
                    return new OperatorNode('*', 'multiply', [
                        node,
                        new OperatorNode('*', 'multiply', [
                            new FunctionNode('log', [
                                _arg.clone()
                            ]),
                            _derivative(_arg2.clone(), constNodes)
                        ])
                    ]);
                }
                if (constNodes[_arg2] !== undefined) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$is$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isConstantNode"])(_arg2)) {
                        // If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0
                        if (isZero(_arg2.value)) {
                            return createConstantNode(0);
                        }
                        // Ignore exponent; f(x)^1 = f(x)
                        if (equal(_arg2.value, 1)) {
                            return _derivative(_arg, constNodes);
                        }
                    }
                    // Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)
                    var powMinusOne = new OperatorNode('^', 'pow', [
                        _arg.clone(),
                        new OperatorNode('-', 'subtract', [
                            _arg2,
                            createConstantNode(1)
                        ])
                    ]);
                    return new OperatorNode('*', 'multiply', [
                        _arg2.clone(),
                        new OperatorNode('*', 'multiply', [
                            _derivative(_arg, constNodes),
                            powMinusOne
                        ])
                    ]);
                }
                // Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]
                return new OperatorNode('*', 'multiply', [
                    new OperatorNode('^', 'pow', [
                        _arg.clone(),
                        _arg2.clone()
                    ]),
                    new OperatorNode('+', 'add', [
                        new OperatorNode('*', 'multiply', [
                            _derivative(_arg, constNodes),
                            new OperatorNode('/', 'divide', [
                                _arg2.clone(),
                                _arg.clone()
                            ])
                        ]),
                        new OperatorNode('*', 'multiply', [
                            _derivative(_arg2, constNodes),
                            new FunctionNode('log', [
                                _arg.clone()
                            ])
                        ])
                    ])
                ]);
            }
            throw new Error('Cannot process operator "' + node.op + '" in derivative: ' + 'the operator is not supported, undefined, or the number of arguments passed to it are not supported');
        }
    });
    /**
   * Helper function to create a constant node with a specific type
   * (number, BigNumber, Fraction)
   * @param {number} value
   * @param {string} [valueType]
   * @return {ConstantNode}
   */ function createConstantNode(value, valueType) {
        return new ConstantNode(numeric(value, valueType || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeNumberType"])(String(value), config)));
    }
    return derivative;
});
}}),
"[project]/node_modules/mathjs/lib/esm/function/algebra/rationalize.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createRationalize": (()=>createRationalize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mathjs/lib/esm/utils/factory.js [app-client] (ecmascript)");
;
;
var name = 'rationalize';
var dependencies = [
    'config',
    'typed',
    'equal',
    'isZero',
    'add',
    'subtract',
    'multiply',
    'divide',
    'pow',
    'parse',
    'simplifyConstant',
    'simplifyCore',
    'simplify',
    '?bignumber',
    '?fraction',
    'mathWithTransform',
    'matrix',
    'AccessorNode',
    'ArrayNode',
    'ConstantNode',
    'FunctionNode',
    'IndexNode',
    'ObjectNode',
    'OperatorNode',
    'SymbolNode',
    'ParenthesisNode'
];
var createRationalize = /* #__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factory"])(name, dependencies, (_ref)=>{
    var { config, typed, equal, isZero, add, subtract, multiply, divide, pow, parse, simplifyConstant, simplifyCore, simplify, fraction, bignumber, mathWithTransform, matrix, AccessorNode, ArrayNode, ConstantNode, FunctionNode, IndexNode, ObjectNode, OperatorNode, SymbolNode, ParenthesisNode } = _ref;
    /**
   * Transform a rationalizable expression in a rational fraction.
   * If rational fraction is one variable polynomial then converts
   * the numerator and denominator in canonical form, with decreasing
   * exponents, returning the coefficients of numerator.
   *
   * Syntax:
   *
   *     math.rationalize(expr)
   *     math.rationalize(expr, detailed)
   *     math.rationalize(expr, scope)
   *     math.rationalize(expr, scope, detailed)
   *
   * Examples:
   *
   *     math.rationalize('sin(x)+y')
   *                   //  Error: There is an unsolved function call
   *     math.rationalize('2x/y - y/(x+1)')
   *                   // (2*x^2-y^2+2*x)/(x*y+y)
   *     math.rationalize('(2x+1)^6')
   *                   // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1
   *     math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')
   *                   // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)
   *     math.rationalize('x/(1-x)/(x-2)/(x-3)/(x-4) + 2x/ ( (1-2x)/(2-3x) )/ ((3-4x)/(4-5x) )') =
   *                   // (-30*x^7+344*x^6-1506*x^5+3200*x^4-3472*x^3+1846*x^2-381*x)/
   *                   //     (-8*x^6+90*x^5-383*x^4+780*x^3-797*x^2+390*x-72)
   *
   *     math.rationalize('x+x+x+y',{y:1}) // 3*x+1
   *     math.rationalize('x+x+x+y',{})    // 3*x+y
   *
   *     const ret = math.rationalize('x+x+x+y',{},true)
   *                   // ret.expression=3*x+y, ret.variables = ["x","y"]
   *     const ret = math.rationalize('-2+5x^2',{},true)
   *                   // ret.expression=5*x^2-2, ret.variables = ["x"], ret.coefficients=[-2,0,5]
   *
   * See also:
   *
   *     simplify
   *
   * @param  {Node|string} expr    The expression to check if is a polynomial expression
   * @param  {Object|boolean}      optional scope of expression or true for already evaluated rational expression at input
   * @param  {Boolean}  detailed   optional True if return an object, false if return expression node (default)
   *
   * @return {Object | Node}    The rational polynomial of `expr` or an object
   *            `{expression, numerator, denominator, variables, coefficients}`, where
   *              `expression` is a `Node` with the node simplified expression,
   *              `numerator` is a `Node` with the simplified numerator of expression,
   *              `denominator` is a `Node` or `boolean` with the simplified denominator or `false` (if there is no denominator),
   *              `variables` is an array with variable names,
   *              and `coefficients` is an array with coefficients of numerator sorted by increased exponent
   *           {Expression Node}  node simplified expression
   *
   */ function _rationalize(expr) {
        var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var detailed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var setRules = rulesRationalize(); // Rules for change polynomial in near canonical form
        var polyRet = polynomial(expr, scope, true, setRules.firstRules); // Check if expression is a rationalizable polynomial
        var nVars = polyRet.variables.length;
        var noExactFractions = {
            exactFractions: false
        };
        var withExactFractions = {
            exactFractions: true
        };
        expr = polyRet.expression;
        if (nVars >= 1) {
            // If expression in not a constant
            expr = expandPower(expr); // First expand power of polynomials (cannot be made from rules!)
            var sBefore; // Previous expression
            var rules;
            var eDistrDiv = true;
            var redoInic = false;
            // Apply the initial rules, including succ div rules:
            expr = simplify(expr, setRules.firstRules, {}, noExactFractions);
            var s;
            while(true){
                // Alternate applying successive division rules and distr.div.rules
                // until there are no more changes:
                rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
                expr = simplify(expr, rules, {}, withExactFractions);
                eDistrDiv = !eDistrDiv; // Swap between Distr.Div and Succ. Div. Rules
                s = expr.toString();
                if (s === sBefore) {
                    break; // No changes : end of the loop
                }
                redoInic = true;
                sBefore = s;
            }
            if (redoInic) {
                // Apply first rules again without succ div rules (if there are changes)
                expr = simplify(expr, setRules.firstRulesAgain, {}, noExactFractions);
            }
            // Apply final rules:
            expr = simplify(expr, setRules.finalRules, {}, noExactFractions);
        } // NVars >= 1
        var coefficients = [];
        var retRationalize = {};
        if (expr.type === 'OperatorNode' && expr.isBinary() && expr.op === '/') {
            // Separate numerator from denominator
            if (nVars === 1) {
                expr.args[0] = polyToCanonical(expr.args[0], coefficients);
                expr.args[1] = polyToCanonical(expr.args[1]);
            }
            if (detailed) {
                retRationalize.numerator = expr.args[0];
                retRationalize.denominator = expr.args[1];
            }
        } else {
            if (nVars === 1) {
                expr = polyToCanonical(expr, coefficients);
            }
            if (detailed) {
                retRationalize.numerator = expr;
                retRationalize.denominator = null;
            }
        }
        // nVars
        if (!detailed) return expr;
        retRationalize.coefficients = coefficients;
        retRationalize.variables = polyRet.variables;
        retRationalize.expression = expr;
        return retRationalize;
    }
    return typed(name, {
        Node: _rationalize,
        'Node, boolean': (expr, detailed)=>_rationalize(expr, {}, detailed),
        'Node, Object': _rationalize,
        'Node, Object, boolean': _rationalize
    }); // end of typed rationalize
    "TURBOPACK unreachable";
    /**
   *  Function to simplify an expression using an optional scope and
   *  return it if the expression is a polynomial expression, i.e.
   *  an expression with one or more variables and the operators
   *  +, -, *, and ^, where the exponent can only be a positive integer.
   *
   * Syntax:
   *
   *     polynomial(expr,scope,extended, rules)
   *
   * @param  {Node | string} expr     The expression to simplify and check if is polynomial expression
   * @param  {object} scope           Optional scope for expression simplification
   * @param  {boolean} extended       Optional. Default is false. When true allows divide operator.
   * @param  {array}  rules           Optional. Default is no rule.
   *
   *
   * @return {Object}
   *            {Object} node:   node simplified expression
   *            {Array}  variables:  variable names
   */ function polynomial(expr, scope, extended, rules) {
        var variables = [];
        var node = simplify(expr, rules, scope, {
            exactFractions: false
        }); // Resolves any variables and functions with all defined parameters
        extended = !!extended;
        var oper = '+-*' + (extended ? '/' : '');
        recPoly(node);
        var retFunc = {};
        retFunc.expression = node;
        retFunc.variables = variables;
        return retFunc;
        "TURBOPACK unreachable";
        // -------------------------------------------------------------------------------------------------------
        /**
     *  Function to simplify an expression using an optional scope and
     *  return it if the expression is a polynomial expression, i.e.
     *  an expression with one or more variables and the operators
     *  +, -, *, and ^, where the exponent can only be a positive integer.
     *
     * Syntax:
     *
     *     recPoly(node)
     *
     *
     * @param  {Node} node               The current sub tree expression in recursion
     *
     * @return                           nothing, throw an exception if error
     */ function recPoly(node) {
            var tp = node.type; // node type
            if (tp === 'FunctionNode') {
                // No function call in polynomial expression
                throw new Error('There is an unsolved function call');
            } else if (tp === 'OperatorNode') {
                if (node.op === '^') {
                    // TODO: handle negative exponents like in '1/x^(-2)'
                    if (node.args[1].type !== 'ConstantNode' || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(parseFloat(node.args[1].value))) {
                        throw new Error('There is a non-integer exponent');
                    } else {
                        recPoly(node.args[0]);
                    }
                } else {
                    if (!oper.includes(node.op)) {
                        throw new Error('Operator ' + node.op + ' invalid in polynomial expression');
                    }
                    for(var i = 0; i < node.args.length; i++){
                        recPoly(node.args[i]);
                    }
                } // type of operator
            } else if (tp === 'SymbolNode') {
                var _name = node.name; // variable name
                var pos = variables.indexOf(_name);
                if (pos === -1) {
                    // new variable in expression
                    variables.push(_name);
                }
            } else if (tp === 'ParenthesisNode') {
                recPoly(node.content);
            } else if (tp !== 'ConstantNode') {
                throw new Error('type ' + tp + ' is not allowed in polynomial expression');
            }
        } // end of recPoly
    } // end of polynomial
    // ---------------------------------------------------------------------------------------
    /**
   * Return a rule set to rationalize an polynomial expression in rationalize
   *
   * Syntax:
   *
   *     rulesRationalize()
   *
   * @return {array}        rule set to rationalize an polynomial expression
   */ function rulesRationalize() {
        var oldRules = [
            simplifyCore,
            // sCore
            {
                l: 'n+n',
                r: '2*n'
            },
            {
                l: 'n+-n',
                r: '0'
            },
            simplifyConstant,
            // sConstant
            {
                l: 'n*(n1^-1)',
                r: 'n/n1'
            },
            {
                l: 'n*n1^-n2',
                r: 'n/n1^n2'
            },
            {
                l: 'n1^-1',
                r: '1/n1'
            },
            {
                l: 'n*(n1/n2)',
                r: '(n*n1)/n2'
            },
            {
                l: '1*n',
                r: 'n'
            }
        ];
        var rulesFirst = [
            {
                l: '(-n1)/(-n2)',
                r: 'n1/n2'
            },
            // Unary division
            {
                l: '(-n1)*(-n2)',
                r: 'n1*n2'
            },
            // Unary multiplication
            {
                l: 'n1--n2',
                r: 'n1+n2'
            },
            // '--' elimination
            {
                l: 'n1-n2',
                r: 'n1+(-n2)'
            },
            // Subtraction turn into add with un�ry minus
            {
                l: '(n1+n2)*n3',
                r: '(n1*n3 + n2*n3)'
            },
            // Distributive 1
            {
                l: 'n1*(n2+n3)',
                r: '(n1*n2+n1*n3)'
            },
            // Distributive 2
            {
                l: 'c1*n + c2*n',
                r: '(c1+c2)*n'
            },
            // Joining constants
            {
                l: 'c1*n + n',
                r: '(c1+1)*n'
            },
            // Joining constants
            {
                l: 'c1*n - c2*n',
                r: '(c1-c2)*n'
            },
            // Joining constants
            {
                l: 'c1*n - n',
                r: '(c1-1)*n'
            },
            // Joining constants
            {
                l: 'v/c',
                r: '(1/c)*v'
            },
            // variable/constant (new!)
            {
                l: 'v/-c',
                r: '-(1/c)*v'
            },
            // variable/constant (new!)
            {
                l: '-v*-c',
                r: 'c*v'
            },
            // Inversion constant and variable 1
            {
                l: '-v*c',
                r: '-c*v'
            },
            // Inversion constant and variable 2
            {
                l: 'v*-c',
                r: '-c*v'
            },
            // Inversion constant and variable 3
            {
                l: 'v*c',
                r: 'c*v'
            },
            // Inversion constant and variable 4
            {
                l: '-(-n1*n2)',
                r: '(n1*n2)'
            },
            // Unary propagation
            {
                l: '-(n1*n2)',
                r: '(-n1*n2)'
            },
            // Unary propagation
            {
                l: '-(-n1+n2)',
                r: '(n1-n2)'
            },
            // Unary propagation
            {
                l: '-(n1+n2)',
                r: '(-n1-n2)'
            },
            // Unary propagation
            {
                l: '(n1^n2)^n3',
                r: '(n1^(n2*n3))'
            },
            // Power to Power
            {
                l: '-(-n1/n2)',
                r: '(n1/n2)'
            },
            // Division and Unary
            {
                l: '-(n1/n2)',
                r: '(-n1/n2)'
            }
        ]; // Divisao and Unary
        var rulesDistrDiv = [
            {
                l: '(n1/n2 + n3/n4)',
                r: '((n1*n4 + n3*n2)/(n2*n4))'
            },
            // Sum of fractions
            {
                l: '(n1/n2 + n3)',
                r: '((n1 + n3*n2)/n2)'
            },
            // Sum fraction with number 1
            {
                l: '(n1 + n2/n3)',
                r: '((n1*n3 + n2)/n3)'
            }
        ]; // Sum fraction with number 1
        var rulesSucDiv = [
            {
                l: '(n1/(n2/n3))',
                r: '((n1*n3)/n2)'
            },
            // Division simplification
            {
                l: '(n1/n2/n3)',
                r: '(n1/(n2*n3))'
            }
        ];
        var setRules = {}; // rules set in 4 steps.
        // All rules => infinite loop
        // setRules.allRules =oldRules.concat(rulesFirst,rulesDistrDiv,rulesSucDiv)
        setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv); // First rule set
        setRules.distrDivRules = rulesDistrDiv; // Just distr. div. rules
        setRules.sucDivRules = rulesSucDiv; // Jus succ. div. rules
        setRules.firstRulesAgain = oldRules.concat(rulesFirst); // Last rules set without succ. div.
        // Division simplification
        // Second rule set.
        // There is no aggregate expression with parentesis, but the only variable can be scattered.
        setRules.finalRules = [
            simplifyCore,
            // simplify.rules[0]
            {
                l: 'n*-n',
                r: '-n^2'
            },
            // Joining multiply with power 1
            {
                l: 'n*n',
                r: 'n^2'
            },
            // Joining multiply with power 2
            simplifyConstant,
            // simplify.rules[14] old 3rd index in oldRules
            {
                l: 'n*-n^n1',
                r: '-n^(n1+1)'
            },
            // Joining multiply with power 3
            {
                l: 'n*n^n1',
                r: 'n^(n1+1)'
            },
            // Joining multiply with power 4
            {
                l: 'n^n1*-n^n2',
                r: '-n^(n1+n2)'
            },
            // Joining multiply with power 5
            {
                l: 'n^n1*n^n2',
                r: 'n^(n1+n2)'
            },
            // Joining multiply with power 6
            {
                l: 'n^n1*-n',
                r: '-n^(n1+1)'
            },
            // Joining multiply with power 7
            {
                l: 'n^n1*n',
                r: 'n^(n1+1)'
            },
            // Joining multiply with power 8
            {
                l: 'n^n1/-n',
                r: '-n^(n1-1)'
            },
            // Joining multiply with power 8
            {
                l: 'n^n1/n',
                r: 'n^(n1-1)'
            },
            // Joining division with power 1
            {
                l: 'n/-n^n1',
                r: '-n^(1-n1)'
            },
            // Joining division with power 2
            {
                l: 'n/n^n1',
                r: 'n^(1-n1)'
            },
            // Joining division with power 3
            {
                l: 'n^n1/-n^n2',
                r: 'n^(n1-n2)'
            },
            // Joining division with power 4
            {
                l: 'n^n1/n^n2',
                r: 'n^(n1-n2)'
            },
            // Joining division with power 5
            {
                l: 'n1+(-n2*n3)',
                r: 'n1-n2*n3'
            },
            // Solving useless parenthesis 1
            {
                l: 'v*(-c)',
                r: '-c*v'
            },
            // Solving useless unary 2
            {
                l: 'n1+-n2',
                r: 'n1-n2'
            },
            // Solving +- together (new!)
            {
                l: 'v*c',
                r: 'c*v'
            },
            // inversion constant with variable
            {
                l: '(n1^n2)^n3',
                r: '(n1^(n2*n3))'
            } // Power to Power
        ];
        return setRules;
    } // End rulesRationalize
    // ---------------------------------------------------------------------------------------
    /**
   *  Expand recursively a tree node for handling with expressions with exponents
   *  (it's not for constants, symbols or functions with exponents)
   *  PS: The other parameters are internal for recursion
   *
   * Syntax:
   *
   *     expandPower(node)
   *
   * @param  {Node} node         Current expression node
   * @param  {node} parent       Parent current node inside the recursion
   * @param  (int}               Parent number of chid inside the rercursion
   *
   * @return {node}        node expression with all powers expanded.
   */ function expandPower(node, parent, indParent) {
        var tp = node.type;
        var internal = arguments.length > 1; // TRUE in internal calls
        if (tp === 'OperatorNode' && node.isBinary()) {
            var does = false;
            var val;
            if (node.op === '^') {
                // First operator: Parenthesis or UnaryMinus
                if ((node.args[0].type === 'ParenthesisNode' || node.args[0].type === 'OperatorNode') && node.args[1].type === 'ConstantNode') {
                    // Second operator: Constant
                    val = parseFloat(node.args[1].value);
                    does = val >= 2 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(val);
                }
            }
            if (does) {
                // Exponent >= 2
                // Before:
                //            operator A --> Subtree
                // parent pow
                //            constant
                //
                if (val > 2) {
                    // Exponent > 2,
                    // AFTER:  (exponent > 2)
                    //             operator A --> Subtree
                    // parent  *
                    //                 deep clone (operator A --> Subtree
                    //             pow
                    //                 constant - 1
                    //
                    var nEsqTopo = node.args[0];
                    var nDirTopo = new OperatorNode('^', 'pow', [
                        node.args[0].cloneDeep(),
                        new ConstantNode(val - 1)
                    ]);
                    node = new OperatorNode('*', 'multiply', [
                        nEsqTopo,
                        nDirTopo
                    ]);
                } else {
                    // Expo = 2 - no power
                    // AFTER:  (exponent =  2)
                    //             operator A --> Subtree
                    // parent   oper
                    //            deep clone (operator A --> Subtree)
                    //
                    node = new OperatorNode('*', 'multiply', [
                        node.args[0],
                        node.args[0].cloneDeep()
                    ]);
                }
                if (internal) {
                    // Change parent references in internal recursive calls
                    if (indParent === 'content') {
                        parent.content = node;
                    } else {
                        parent.args[indParent] = node;
                    }
                }
            } // does
        } // binary OperatorNode
        if (tp === 'ParenthesisNode') {
            // Recursion
            expandPower(node.content, node, 'content');
        } else if (tp !== 'ConstantNode' && tp !== 'SymbolNode') {
            for(var i = 0; i < node.args.length; i++){
                expandPower(node.args[i], node, i);
            }
        }
        if (!internal) {
            // return the root node
            return node;
        }
    } // End expandPower
    // ---------------------------------------------------------------------------------------
    /**
   * Auxilary function for rationalize
   * Convert near canonical polynomial in one variable in a canonical polynomial
   * with one term for each exponent in decreasing order
   *
   * Syntax:
   *
   *     polyToCanonical(node [, coefficients])
   *
   * @param  {Node | string} expr       The near canonical polynomial expression to convert in a a canonical polynomial expression
   *
   *        The string or tree expression needs to be at below syntax, with free spaces:
   *         (  (^(-)? | [+-]? )cte (*)? var (^expo)?  | cte )+
   *       Where 'var' is one variable with any valid name
   *             'cte' are real numeric constants with any value. It can be omitted if equal than 1
   *             'expo' are integers greater than 0. It can be omitted if equal than 1.
   *
   * @param  {array}   coefficients             Optional returns coefficients sorted by increased exponent
   *
   *
   * @return {node}        new node tree with one variable polynomial or string error.
   */ function polyToCanonical(node, coefficients) {
        if (coefficients === undefined) {
            coefficients = [];
        } // coefficients.
        coefficients[0] = 0; // index is the exponent
        var o = {};
        o.cte = 1;
        o.oper = '+';
        // fire: mark with * or ^ when finds * or ^ down tree, reset to "" with + and -.
        //       It is used to deduce the exponent: 1 for *, 0 for "".
        o.fire = '';
        var maxExpo = 0; // maximum exponent
        var varname = ''; // variable name
        recurPol(node, null, o);
        maxExpo = coefficients.length - 1;
        var first = true;
        var no;
        for(var i = maxExpo; i >= 0; i--){
            if (coefficients[i] === 0) continue;
            var n1 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));
            var op = coefficients[i] < 0 ? '-' : '+';
            if (i > 0) {
                // Is not a constant without variable
                var n2 = new SymbolNode(varname);
                if (i > 1) {
                    var n3 = new ConstantNode(i);
                    n2 = new OperatorNode('^', 'pow', [
                        n2,
                        n3
                    ]);
                }
                if (coefficients[i] === -1 && first) {
                    n1 = new OperatorNode('-', 'unaryMinus', [
                        n2
                    ]);
                } else if (Math.abs(coefficients[i]) === 1) {
                    n1 = n2;
                } else {
                    n1 = new OperatorNode('*', 'multiply', [
                        n1,
                        n2
                    ]);
                }
            }
            if (first) {
                no = n1;
            } else if (op === '+') {
                no = new OperatorNode('+', 'add', [
                    no,
                    n1
                ]);
            } else {
                no = new OperatorNode('-', 'subtract', [
                    no,
                    n1
                ]);
            }
            first = false;
        } // for
        if (first) {
            return new ConstantNode(0);
        } else {
            return no;
        }
        "TURBOPACK unreachable";
        /**
     * Recursive auxilary function inside polyToCanonical for
     * converting expression in canonical form
     *
     * Syntax:
     *
     *     recurPol(node, noPai, obj)
     *
     * @param  {Node} node        The current subpolynomial expression
     * @param  {Node | Null}  noPai   The current parent node
     * @param  {object}    obj        Object with many internal flags
     *
     * @return {}                    No return. If error, throws an exception
     */ function recurPol(node, noPai, o) {
            var tp = node.type;
            if (tp === 'FunctionNode') {
                // ***** FunctionName *****
                // No function call in polynomial expression
                throw new Error('There is an unsolved function call');
            } else if (tp === 'OperatorNode') {
                // ***** OperatorName *****
                if (!'+-*^'.includes(node.op)) throw new Error('Operator ' + node.op + ' invalid');
                if (noPai !== null) {
                    // -(unary),^  : children of *,+,-
                    if ((node.fn === 'unaryMinus' || node.fn === 'pow') && noPai.fn !== 'add' && noPai.fn !== 'subtract' && noPai.fn !== 'multiply') {
                        throw new Error('Invalid ' + node.op + ' placing');
                    }
                    // -,+,* : children of +,-
                    if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'multiply') && noPai.fn !== 'add' && noPai.fn !== 'subtract') {
                        throw new Error('Invalid ' + node.op + ' placing');
                    }
                    // -,+ : first child
                    if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'unaryMinus') && o.noFil !== 0) {
                        throw new Error('Invalid ' + node.op + ' placing');
                    }
                } // Has parent
                // Firers: ^,*       Old:   ^,&,-(unary): firers
                if (node.op === '^' || node.op === '*') {
                    o.fire = node.op;
                }
                for(var _i = 0; _i < node.args.length; _i++){
                    // +,-: reset fire
                    if (node.fn === 'unaryMinus') o.oper = '-';
                    if (node.op === '+' || node.fn === 'subtract') {
                        o.fire = '';
                        o.cte = 1; // default if there is no constant
                        o.oper = _i === 0 ? '+' : node.op;
                    }
                    o.noFil = _i; // number of son
                    recurPol(node.args[_i], node, o);
                } // for in children
            } else if (tp === 'SymbolNode') {
                // ***** SymbolName *****
                if (node.name !== varname && varname !== '') {
                    throw new Error('There is more than one variable');
                }
                varname = node.name;
                if (noPai === null) {
                    coefficients[1] = 1;
                    return;
                }
                // ^: Symbol is First child
                if (noPai.op === '^' && o.noFil !== 0) {
                    throw new Error('In power the variable should be the first parameter');
                }
                // *: Symbol is Second child
                if (noPai.op === '*' && o.noFil !== 1) {
                    throw new Error('In multiply the variable should be the second parameter');
                }
                // Symbol: firers '',* => it means there is no exponent above, so it's 1 (cte * var)
                if (o.fire === '' || o.fire === '*') {
                    if (maxExpo < 1) coefficients[1] = 0;
                    coefficients[1] += o.cte * (o.oper === '+' ? 1 : -1);
                    maxExpo = Math.max(1, maxExpo);
                }
            } else if (tp === 'ConstantNode') {
                var valor = parseFloat(node.value);
                if (noPai === null) {
                    coefficients[0] = valor;
                    return;
                }
                if (noPai.op === '^') {
                    // cte: second  child of power
                    if (o.noFil !== 1) throw new Error('Constant cannot be powered');
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mathjs$2f$lib$2f$esm$2f$utils$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(valor) || valor <= 0) {
                        throw new Error('Non-integer exponent is not allowed');
                    }
                    for(var _i2 = maxExpo + 1; _i2 < valor; _i2++)coefficients[_i2] = 0;
                    if (valor > maxExpo) coefficients[valor] = 0;
                    coefficients[valor] += o.cte * (o.oper === '+' ? 1 : -1);
                    maxExpo = Math.max(valor, maxExpo);
                    return;
                }
                o.cte = valor;
                // Cte: firer '' => There is no exponent and no multiplication, so the exponent is 0.
                if (o.fire === '') {
                    coefficients[0] += o.cte * (o.oper === '+' ? 1 : -1);
                }
            } else {
                throw new Error('Type ' + tp + ' is not allowed');
            }
        } // End of recurPol
    } // End of polyToCanonical
});
}}),
}]);

//# sourceMappingURL=node_modules_mathjs_lib_esm_function_algebra_c24efc94._.js.map