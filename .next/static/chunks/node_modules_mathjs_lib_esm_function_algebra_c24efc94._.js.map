{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js"],"sourcesContent":["import { isArray, isMatrix, isDenseMatrix, isSparseMatrix } from '../../../../utils/is.js';\nimport { arraySize } from '../../../../utils/array.js';\nimport { format } from '../../../../utils/string.js';\nexport function createSolveValidation(_ref) {\n  var {\n    DenseMatrix\n  } = _ref;\n  /**\n   * Validates matrix and column vector b for backward/forward substitution algorithms.\n   *\n   * @param {Matrix} m            An N x N matrix\n   * @param {Array | Matrix} b    A column vector\n   * @param {Boolean} copy        Return a copy of vector b\n   *\n   * @return {DenseMatrix}        Dense column vector b\n   */\n  return function solveValidation(m, b, copy) {\n    var mSize = m.size();\n    if (mSize.length !== 2) {\n      throw new RangeError('Matrix must be two dimensional (size: ' + format(mSize) + ')');\n    }\n    var rows = mSize[0];\n    var columns = mSize[1];\n    if (rows !== columns) {\n      throw new RangeError('Matrix must be square (size: ' + format(mSize) + ')');\n    }\n    var data = [];\n    if (isMatrix(b)) {\n      var bSize = b.size();\n      var bdata = b._data;\n\n      // 1-dim vector\n      if (bSize.length === 1) {\n        if (bSize[0] !== rows) {\n          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');\n        }\n        for (var i = 0; i < rows; i++) {\n          data[i] = [bdata[i]];\n        }\n        return new DenseMatrix({\n          data,\n          size: [rows, 1],\n          datatype: b._datatype\n        });\n      }\n\n      // 2-dim column\n      if (bSize.length === 2) {\n        if (bSize[0] !== rows || bSize[1] !== 1) {\n          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');\n        }\n        if (isDenseMatrix(b)) {\n          if (copy) {\n            data = [];\n            for (var _i = 0; _i < rows; _i++) {\n              data[_i] = [bdata[_i][0]];\n            }\n            return new DenseMatrix({\n              data,\n              size: [rows, 1],\n              datatype: b._datatype\n            });\n          }\n          return b;\n        }\n        if (isSparseMatrix(b)) {\n          for (var _i2 = 0; _i2 < rows; _i2++) {\n            data[_i2] = [0];\n          }\n          var values = b._values;\n          var index = b._index;\n          var ptr = b._ptr;\n          for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {\n            var _i3 = index[k];\n            data[_i3][0] = values[k];\n          }\n          return new DenseMatrix({\n            data,\n            size: [rows, 1],\n            datatype: b._datatype\n          });\n        }\n      }\n      throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');\n    }\n    if (isArray(b)) {\n      var bsize = arraySize(b);\n      if (bsize.length === 1) {\n        if (bsize[0] !== rows) {\n          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');\n        }\n        for (var _i4 = 0; _i4 < rows; _i4++) {\n          data[_i4] = [b[_i4]];\n        }\n        return new DenseMatrix({\n          data,\n          size: [rows, 1]\n        });\n      }\n      if (bsize.length === 2) {\n        if (bsize[0] !== rows || bsize[1] !== 1) {\n          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');\n        }\n        for (var _i5 = 0; _i5 < rows; _i5++) {\n          data[_i5] = [b[_i5][0]];\n        }\n        return new DenseMatrix({\n          data,\n          size: [rows, 1]\n        });\n      }\n      throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');\n    }\n  };\n}"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js"],"sourcesContent":["import { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nvar name = 'lsolve';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'equalScalar', 'DenseMatrix'];\nexport var createLsolve = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divideScalar,\n    multiplyScalar,\n    subtractScalar,\n    equalScalar,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n\n  /**\n   * Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there's no solution.\n   *\n   * `L * x = b`\n   *\n   * Syntax:\n   *\n   *    math.lsolve(L, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = lsolve(a, b)  // [[-5.5], [20]]\n   *\n   * See also:\n   *\n   *    lsolveAll, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function Array_Array__Matrix(a, b) {\n      var m = matrix(a);\n      var r = _denseForwardSubstitution(m, b);\n      return r.valueOf();\n    }\n  });\n  function _denseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n\n    // result\n    var x = [];\n    var mdata = m._data;\n\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      var bj = bdata[j][0] || 0;\n      var xj = void 0;\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n\n        var vjj = mdata[j][j];\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n        xj = divideScalar(bj, vjj);\n\n        // loop rows\n        for (var i = j + 1; i < rows; i++) {\n          bdata[i] = [subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\n        }\n      } else {\n        // degenerate row, we can choose any value\n        xj = 0;\n      }\n      x[j] = [xj];\n    }\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n  function _sparseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n\n    // result\n    var x = [];\n\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      var bj = bdata[j][0] || 0;\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n\n        var vjj = 0;\n        // matrix values & indices (column j)\n        var jValues = [];\n        var jIndices = [];\n\n        // first and last index in the column\n        var firstIndex = ptr[j];\n        var lastIndex = ptr[j + 1];\n\n        // values in column, find value at [j, j]\n        for (var k = firstIndex; k < lastIndex; k++) {\n          var i = index[k];\n\n          // check row (rows are not sorted!)\n          if (i === j) {\n            vjj = values[k];\n          } else if (i > j) {\n            // store lower triangular\n            jValues.push(values[k]);\n            jIndices.push(i);\n          }\n        }\n\n        // at this point we must have a value in vjj\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n        var xj = divideScalar(bj, vjj);\n        for (var _k = 0, l = jIndices.length; _k < l; _k++) {\n          var _i = jIndices[_k];\n          bdata[_i] = [subtractScalar(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];\n        }\n        x[j] = [xj];\n      } else {\n        // degenerate row, we can choose any value\n        x[j] = [0];\n      }\n    }\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 326, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js"],"sourcesContent":["import { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nvar name = 'usolve';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'equalScalar', 'DenseMatrix'];\nexport var createUsolve = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divideScalar,\n    multiplyScalar,\n    subtractScalar,\n    equalScalar,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n\n  /**\n   * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.\n   *\n   * `U * x = b`\n   *\n   * Syntax:\n   *\n   *    math.usolve(U, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = usolve(a, b)  // [[8], [9]]\n   *\n   * See also:\n   *\n   *    usolveAll, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} U       A N x N matrix or array (U)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\n   */\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {\n      return _sparseBackwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {\n      return _denseBackwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function Array_Array__Matrix(a, b) {\n      var m = matrix(a);\n      var r = _denseBackwardSubstitution(m, b);\n      return r.valueOf();\n    }\n  });\n  function _denseBackwardSubstitution(m, b) {\n    // make b into a column vector\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n\n    // result\n    var x = [];\n    var mdata = m._data;\n    // loop columns backwards\n    for (var j = columns - 1; j >= 0; j--) {\n      // b[j]\n      var bj = bdata[j][0] || 0;\n      // x[j]\n      var xj = void 0;\n      if (!equalScalar(bj, 0)) {\n        // value at [j, j]\n        var vjj = mdata[j][j];\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n        xj = divideScalar(bj, vjj);\n\n        // loop rows\n        for (var i = j - 1; i >= 0; i--) {\n          // update copy of b\n          bdata[i] = [subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\n        }\n      } else {\n        // zero value at j\n        xj = 0;\n      }\n      // update x\n      x[j] = [xj];\n    }\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n  function _sparseBackwardSubstitution(m, b) {\n    // make b into a column vector\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n\n    // result\n    var x = [];\n\n    // loop columns backwards\n    for (var j = columns - 1; j >= 0; j--) {\n      var bj = bdata[j][0] || 0;\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n\n        var vjj = 0;\n\n        // upper triangular matrix values & index (column j)\n        var jValues = [];\n        var jIndices = [];\n\n        // first & last indeces in column\n        var firstIndex = ptr[j];\n        var lastIndex = ptr[j + 1];\n\n        // values in column, find value at [j, j], loop backwards\n        for (var k = lastIndex - 1; k >= firstIndex; k--) {\n          var i = index[k];\n\n          // check row (rows are not sorted!)\n          if (i === j) {\n            vjj = values[k];\n          } else if (i < j) {\n            // store upper triangular\n            jValues.push(values[k]);\n            jIndices.push(i);\n          }\n        }\n\n        // at this point we must have a value in vjj\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n        var xj = divideScalar(bj, vjj);\n        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {\n          var _i = jIndices[_k];\n          bdata[_i] = [subtractScalar(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];\n        }\n        x[j] = [xj];\n      } else {\n        // degenerate row, we can choose any value\n        x[j] = [0];\n      }\n    }\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 503, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js"],"sourcesContent":["import { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nvar name = 'lsolveAll';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'equalScalar', 'DenseMatrix'];\nexport var createLsolveAll = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divideScalar,\n    multiplyScalar,\n    subtractScalar,\n    equalScalar,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n\n  /**\n   * Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.\n   *\n   * `L * x = b`\n   *\n   * Syntax:\n   *\n   *    math.lsolveAll(L, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]\n   *\n   * See also:\n   *\n   *    lsolve, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system\n   */\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function Array_Array__Matrix(a, b) {\n      var m = matrix(a);\n      var R = _denseForwardSubstitution(m, b);\n      return R.map(r => r.valueOf());\n    }\n  });\n  function _denseForwardSubstitution(m, b_) {\n    // the algorithm is derived from\n    // https://www.overleaf.com/read/csvgqdxggyjv\n\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\n    var M = m._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n\n    // loop columns\n    for (var i = 0; i < columns; i++) {\n      var L = B.length;\n\n      // loop right-hand sides\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n        if (!equalScalar(M[i][i], 0)) {\n          // non-singular row\n\n          b[i] = divideScalar(b[i], M[i][i]);\n          for (var j = i + 1; j < columns; j++) {\n            // b[j] -= b[i] * M[j,i]\n            b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n\n          var bNew = [...b];\n          bNew[i] = 1;\n          for (var _j = i + 1; _j < columns; _j++) {\n            bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);\n          }\n          B.push(bNew);\n        }\n      }\n    }\n    return B.map(x => new DenseMatrix({\n      data: x.map(e => [e]),\n      size: [rows, 1]\n    }));\n  }\n  function _sparseForwardSubstitution(m, b_) {\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n\n    // loop columns\n    for (var i = 0; i < columns; i++) {\n      var L = B.length;\n\n      // loop right-hand sides\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n\n        // values & indices (column i)\n        var iValues = [];\n        var iIndices = [];\n\n        // first & last indeces in column\n        var firstIndex = ptr[i];\n        var lastIndex = ptr[i + 1];\n\n        // find the value at [i, i]\n        var Mii = 0;\n        for (var j = firstIndex; j < lastIndex; j++) {\n          var J = index[j];\n          // check row\n          if (J === i) {\n            Mii = values[j];\n          } else if (J > i) {\n            // store lower triangular\n            iValues.push(values[j]);\n            iIndices.push(J);\n          }\n        }\n        if (!equalScalar(Mii, 0)) {\n          // non-singular row\n\n          b[i] = divideScalar(b[i], Mii);\n          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {\n            var _J = iIndices[_j2];\n            b[_J] = subtractScalar(b[_J], multiplyScalar(b[i], iValues[_j2]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n\n          var bNew = [...b];\n          bNew[i] = 1;\n          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {\n            var _J2 = iIndices[_j3];\n            bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);\n          }\n          B.push(bNew);\n        }\n      }\n    }\n    return B.map(x => new DenseMatrix({\n      data: x.map(e => [e]),\n      size: [rows, 1]\n    }));\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 703, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js"],"sourcesContent":["import { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nvar name = 'usolveAll';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'equalScalar', 'DenseMatrix'];\nexport var createUsolveAll = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divideScalar,\n    multiplyScalar,\n    subtractScalar,\n    equalScalar,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n\n  /**\n   * Finds all solutions of a linear equation system by backward substitution. Matrix must be an upper triangular matrix.\n   *\n   * `U * x = b`\n   *\n   * Syntax:\n   *\n   *    math.usolveAll(U, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = usolveAll(a, b)  // [ [[8], [9]] ]\n   *\n   * See also:\n   *\n   *    usolve, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} U       A N x N matrix or array (U)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system\n   */\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {\n      return _sparseBackwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {\n      return _denseBackwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function Array_Array__Matrix(a, b) {\n      var m = matrix(a);\n      var R = _denseBackwardSubstitution(m, b);\n      return R.map(r => r.valueOf());\n    }\n  });\n  function _denseBackwardSubstitution(m, b_) {\n    // the algorithm is derived from\n    // https://www.overleaf.com/read/csvgqdxggyjv\n\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\n    var M = m._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n\n    // loop columns backwards\n    for (var i = columns - 1; i >= 0; i--) {\n      var L = B.length;\n\n      // loop right-hand sides\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n        if (!equalScalar(M[i][i], 0)) {\n          // non-singular row\n\n          b[i] = divideScalar(b[i], M[i][i]);\n          for (var j = i - 1; j >= 0; j--) {\n            // b[j] -= b[i] * M[j,i]\n            b[j] = subtractScalar(b[j], multiplyScalar(b[i], M[j][i]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n\n          var bNew = [...b];\n          bNew[i] = 1;\n          for (var _j = i - 1; _j >= 0; _j--) {\n            bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);\n          }\n          B.push(bNew);\n        }\n      }\n    }\n    return B.map(x => new DenseMatrix({\n      data: x.map(e => [e]),\n      size: [rows, 1]\n    }));\n  }\n  function _sparseBackwardSubstitution(m, b_) {\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n\n    // loop columns backwards\n    for (var i = columns - 1; i >= 0; i--) {\n      var L = B.length;\n\n      // loop right-hand sides\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n\n        // values & indices (column i)\n        var iValues = [];\n        var iIndices = [];\n\n        // first & last indeces in column\n        var firstIndex = ptr[i];\n        var lastIndex = ptr[i + 1];\n\n        // find the value at [i, i]\n        var Mii = 0;\n        for (var j = lastIndex - 1; j >= firstIndex; j--) {\n          var J = index[j];\n          // check row\n          if (J === i) {\n            Mii = values[j];\n          } else if (J < i) {\n            // store upper triangular\n            iValues.push(values[j]);\n            iIndices.push(J);\n          }\n        }\n        if (!equalScalar(Mii, 0)) {\n          // non-singular row\n\n          b[i] = divideScalar(b[i], Mii);\n\n          // loop upper triangular\n          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {\n            var _J = iIndices[_j2];\n            b[_J] = subtractScalar(b[_J], multiplyScalar(b[i], iValues[_j2]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n\n          var bNew = [...b];\n          bNew[i] = 1;\n\n          // loop upper triangular\n          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {\n            var _J2 = iIndices[_j3];\n            bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);\n          }\n          B.push(bNew);\n        }\n      }\n    }\n    return B.map(x => new DenseMatrix({\n      data: x.map(e => [e]),\n      size: [rows, 1]\n    }));\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 905, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js"],"sourcesContent":["import { clone } from '../../../utils/object.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'lup';\nvar dependencies = ['typed', 'matrix', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'larger', 'equalScalar', 'unaryMinus', 'DenseMatrix', 'SparseMatrix', 'Spa'];\nexport var createLup = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    abs,\n    addScalar,\n    divideScalar,\n    multiplyScalar,\n    subtractScalar,\n    larger,\n    equalScalar,\n    unaryMinus,\n    DenseMatrix,\n    SparseMatrix,\n    Spa\n  } = _ref;\n  /**\n   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a\n   * row permutation vector `p` where `A[p,:] = L * U`\n   *\n   * Syntax:\n   *\n   *    math.lup(A)\n   *\n   * Example:\n   *\n   *    const m = [[2, 1], [1, 4]]\n   *    const r = math.lup(m)\n   *    // r = {\n   *    //   L: [[1, 0], [0.5, 1]],\n   *    //   U: [[2, 1], [0, 3.5]],\n   *    //   P: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    slu, lsolve, lusolve, usolve\n   *\n   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.\n   *\n   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.\n   */\n  return typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseLUP(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseLUP(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a);\n      // lup, use matrix implementation\n      var r = _denseLUP(m);\n      // result\n      return {\n        L: r.L.valueOf(),\n        U: r.U.valueOf(),\n        p: r.p\n      };\n    }\n  });\n  function _denseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1];\n    // minimum rows and columns\n    var n = Math.min(rows, columns);\n    // matrix array, clone original data\n    var data = clone(m._data);\n    // l matrix arrays\n    var ldata = [];\n    var lsize = [rows, n];\n    // u matrix arrays\n    var udata = [];\n    var usize = [n, columns];\n    // vars\n    var i, j, k;\n    // permutation vector\n    var p = [];\n    for (i = 0; i < rows; i++) {\n      p[i] = i;\n    }\n    // loop columns\n    for (j = 0; j < columns; j++) {\n      // skip first column in upper triangular matrix\n      if (j > 0) {\n        // loop rows\n        for (i = 0; i < rows; i++) {\n          // min i,j\n          var min = Math.min(i, j);\n          // v[i, j]\n          var s = 0;\n          // loop up to min\n          for (k = 0; k < min; k++) {\n            // s = l[i, k] - data[k, j]\n            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));\n          }\n          data[i][j] = subtractScalar(data[i][j], s);\n        }\n      }\n      // row with larger value in cvector, row >= j\n      var pi = j;\n      var pabsv = 0;\n      var vjj = 0;\n      // loop rows\n      for (i = j; i < rows; i++) {\n        // data @ i, j\n        var v = data[i][j];\n        // absolute value\n        var absv = abs(v);\n        // value is greater than pivote value\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = i;\n          // update max value\n          pabsv = absv;\n          // value @ [j, j]\n          vjj = v;\n        }\n      }\n      // swap rows (j <-> pi)\n      if (j !== pi) {\n        // swap values j <-> pi in p\n        p[j] = [p[pi], p[pi] = p[j]][0];\n        // swap j <-> pi in data\n        DenseMatrix._swapRows(j, pi, data);\n      }\n      // check column is in lower triangular matrix\n      if (j < rows) {\n        // loop rows (lower triangular matrix)\n        for (i = j + 1; i < rows; i++) {\n          // value @ i, j\n          var vij = data[i][j];\n          if (!equalScalar(vij, 0)) {\n            // update data\n            data[i][j] = divideScalar(data[i][j], vjj);\n          }\n        }\n      }\n    }\n    // loop columns\n    for (j = 0; j < columns; j++) {\n      // loop rows\n      for (i = 0; i < rows; i++) {\n        // initialize row in arrays\n        if (j === 0) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i] = [];\n          }\n          // L\n          ldata[i] = [];\n        }\n        // check we are in the upper triangular matrix\n        if (i < j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          }\n          // check column exists in lower triangular matrix\n          if (j < rows) {\n            // L\n            ldata[i][j] = 0;\n          }\n          continue;\n        }\n        // diagonal value\n        if (i === j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          }\n          // check column exists in lower triangular matrix\n          if (j < rows) {\n            // L\n            ldata[i][j] = 1;\n          }\n          continue;\n        }\n        // check row exists in upper triangular matrix\n        if (i < columns) {\n          // U\n          udata[i][j] = 0;\n        }\n        // check column exists in lower triangular matrix\n        if (j < rows) {\n          // L\n          ldata[i][j] = data[i][j];\n        }\n      }\n    }\n    // l matrix\n    var l = new DenseMatrix({\n      data: ldata,\n      size: lsize\n    });\n    // u matrix\n    var u = new DenseMatrix({\n      data: udata,\n      size: usize\n    });\n    // p vector\n    var pv = [];\n    for (i = 0, n = p.length; i < n; i++) {\n      pv[p[i]] = i;\n    }\n    // return matrices\n    return {\n      L: l,\n      U: u,\n      p: pv,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n  function _sparseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1];\n    // minimum rows and columns\n    var n = Math.min(rows, columns);\n    // matrix arrays (will not be modified, thanks to permutation vector)\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n    // l matrix arrays\n    var lvalues = [];\n    var lindex = [];\n    var lptr = [];\n    var lsize = [rows, n];\n    // u matrix arrays\n    var uvalues = [];\n    var uindex = [];\n    var uptr = [];\n    var usize = [n, columns];\n    // vars\n    var i, j, k;\n    // permutation vectors, (current index -> original index) and (original index -> current index)\n    var pvCo = [];\n    var pvOc = [];\n    for (i = 0; i < rows; i++) {\n      pvCo[i] = i;\n      pvOc[i] = i;\n    }\n    // swap indices in permutation vectors (condition x < y)!\n    var swapIndeces = function swapIndeces(x, y) {\n      // find pv indeces getting data from x and y\n      var kx = pvOc[x];\n      var ky = pvOc[y];\n      // update permutation vector current -> original\n      pvCo[kx] = y;\n      pvCo[ky] = x;\n      // update permutation vector original -> current\n      pvOc[x] = ky;\n      pvOc[y] = kx;\n    };\n    // loop columns\n    var _loop = function _loop() {\n      // sparse accumulator\n      var spa = new Spa();\n      // check lower triangular matrix has a value @ column j\n      if (j < rows) {\n        // update ptr\n        lptr.push(lvalues.length);\n        // first value in j column for lower triangular matrix\n        lvalues.push(1);\n        lindex.push(j);\n      }\n      // update ptr\n      uptr.push(uvalues.length);\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1];\n      // copy column j into sparse accumulator\n      for (k = k0; k < k1; k++) {\n        // row\n        i = index[k];\n        // copy column values into sparse accumulator (use permutation vector)\n        spa.set(pvCo[i], values[k]);\n      }\n      // skip first column in upper triangular matrix\n      if (j > 0) {\n        // loop rows in column j (above diagonal)\n        spa.forEach(0, j - 1, function (k, vkj) {\n          // loop rows in column k (L)\n          SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {\n            // check row is below k\n            if (i > k) {\n              // update spa value\n              spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));\n            }\n          });\n        });\n      }\n      // row with larger value in spa, row >= j\n      var pi = j;\n      var vjj = spa.get(j);\n      var pabsv = abs(vjj);\n      // loop values in spa (order by row, below diagonal)\n      spa.forEach(j + 1, rows - 1, function (x, v) {\n        // absolute value\n        var absv = abs(v);\n        // value is greater than pivote value\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = x;\n          // update max value\n          pabsv = absv;\n          // value @ [j, j]\n          vjj = v;\n        }\n      });\n      // swap rows (j <-> pi)\n      if (j !== pi) {\n        // swap values j <-> pi in L\n        SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr);\n        // swap values j <-> pi in U\n        SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr);\n        // swap values in spa\n        spa.swap(j, pi);\n        // update permutation vector (swap values @ j, pi)\n        swapIndeces(j, pi);\n      }\n      // loop values in spa (order by row)\n      spa.forEach(0, rows - 1, function (x, v) {\n        // check we are above diagonal\n        if (x <= j) {\n          // update upper triangular matrix\n          uvalues.push(v);\n          uindex.push(x);\n        } else {\n          // update value\n          v = divideScalar(v, vjj);\n          // check value is non zero\n          if (!equalScalar(v, 0)) {\n            // update lower triangular matrix\n            lvalues.push(v);\n            lindex.push(x);\n          }\n        }\n      });\n    };\n    for (j = 0; j < columns; j++) {\n      _loop();\n    }\n    // update ptrs\n    uptr.push(uvalues.length);\n    lptr.push(lvalues.length);\n\n    // return matrices\n    return {\n      L: new SparseMatrix({\n        values: lvalues,\n        index: lindex,\n        ptr: lptr,\n        size: lsize\n      }),\n      U: new SparseMatrix({\n        values: uvalues,\n        index: uindex,\n        ptr: uptr,\n        size: usize\n      }),\n      p: pvCo,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1309, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport { factory } from '../../../utils/factory.js';\nvar name = 'qr';\nvar dependencies = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'complex'];\nexport var createQr = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    zeros,\n    identity,\n    isZero,\n    equal,\n    sign,\n    sqrt,\n    conj,\n    unaryMinus,\n    addScalar,\n    divideScalar,\n    multiplyScalar,\n    subtractScalar,\n    complex\n  } = _ref;\n  /**\n   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in\n   * two matrices (`Q`, `R`) where `Q` is an\n   * orthogonal matrix and `R` is an upper triangular matrix.\n   *\n   * Syntax:\n   *\n   *    math.qr(A)\n   *\n   * Example:\n   *\n   *    const m = [\n   *      [1, -1,  4],\n   *      [1,  4, -2],\n   *      [1,  4,  2],\n   *      [1,  -1, 0]\n   *    ]\n   *    const result = math.qr(m)\n   *    // r = {\n   *    //   Q: [\n   *    //     [0.5, -0.5,   0.5],\n   *    //     [0.5,  0.5,  -0.5],\n   *    //     [0.5,  0.5,   0.5],\n   *    //     [0.5, -0.5,  -0.5],\n   *    //   ],\n   *    //   R: [\n   *    //     [2, 3,  2],\n   *    //     [0, 5, -2],\n   *    //     [0, 0,  4],\n   *    //     [0, 0,  0]\n   *    //   ]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lusolve\n   *\n   * @param {Matrix | Array} A    A two dimensional matrix or array\n   * for which to get the QR decomposition.\n   *\n   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal\n   * matrix and R: the upper triangular matrix\n   */\n  return _extends(typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseQR(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseQR(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a);\n      // lup, use matrix implementation\n      var r = _denseQR(m);\n      // result\n      return {\n        Q: r.Q.valueOf(),\n        R: r.R.valueOf()\n      };\n    }\n  }), {\n    _denseQRimpl\n  });\n  function _denseQRimpl(m) {\n    // rows & columns (m x n)\n    var rows = m._size[0]; // m\n    var cols = m._size[1]; // n\n\n    var Q = identity([rows], 'dense');\n    var Qdata = Q._data;\n    var R = m.clone();\n    var Rdata = R._data;\n\n    // vars\n    var i, j, k;\n    var w = zeros([rows], '');\n    for (k = 0; k < Math.min(cols, rows); ++k) {\n      /*\n       * **k-th Household matrix**\n       *\n       * The matrix I - 2*v*transpose(v)\n       * x     = first column of A\n       * x1    = first element of x\n       * alpha = x1 / |x1| * |x|\n       * e1    = tranpose([1, 0, 0, ...])\n       * u     = x - alpha * e1\n       * v     = u / |u|\n       *\n       * Household matrix = I - 2 * v * tranpose(v)\n       *\n       *  * Initially Q = I and R = A.\n       *  * Household matrix is a reflection in a plane normal to v which\n       *    will zero out all but the top right element in R.\n       *  * Appplying reflection to both Q and R will not change product.\n       *  * Repeat this process on the (1,1) minor to get R as an upper\n       *    triangular matrix.\n       *  * Reflections leave the magnitude of the columns of Q unchanged\n       *    so Q remains othoganal.\n       *\n       */\n\n      var pivot = Rdata[k][k];\n      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));\n      var conjSgn = conj(sgn);\n      var alphaSquared = 0;\n      for (i = k; i < rows; i++) {\n        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));\n      }\n      var alpha = multiplyScalar(sgn, sqrt(alphaSquared));\n      if (!isZero(alpha)) {\n        // first element in vector u\n        var u1 = subtractScalar(pivot, alpha);\n\n        // w = v * u1 / |u|    (only elements k to (rows-1) are used)\n        w[k] = 1;\n        for (i = k + 1; i < rows; i++) {\n          w[i] = divideScalar(Rdata[i][k], u1);\n        }\n\n        // tau = - conj(u1 / alpha)\n        var tau = unaryMinus(conj(divideScalar(u1, alpha)));\n        var s = void 0;\n\n        /*\n         * tau and w have been choosen so that\n         *\n         * 2 * v * tranpose(v) = tau * w * tranpose(w)\n         */\n\n        /*\n         * -- calculate R = R - tau * w * tranpose(w) * R --\n         * Only do calculation with rows k to (rows-1)\n         * Additionally columns 0 to (k-1) will not be changed by this\n         *   multiplication so do not bother recalculating them\n         */\n        for (j = k; j < cols; j++) {\n          s = 0.0;\n\n          // calculate jth element of [tranpose(w) * R]\n          for (i = k; i < rows; i++) {\n            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));\n          }\n\n          // calculate the jth element of [tau * transpose(w) * R]\n          s = multiplyScalar(s, tau);\n          for (i = k; i < rows; i++) {\n            Rdata[i][j] = multiplyScalar(subtractScalar(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);\n          }\n        }\n        /*\n         * -- calculate Q = Q - tau * Q * w * transpose(w) --\n         * Q is a square matrix (rows x rows)\n         * Only do calculation with columns k to (rows-1)\n         * Additionally rows 0 to (k-1) will not be changed by this\n         *   multiplication so do not bother recalculating them\n         */\n        for (i = 0; i < rows; i++) {\n          s = 0.0;\n\n          // calculate ith element of [Q * w]\n          for (j = k; j < rows; j++) {\n            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));\n          }\n\n          // calculate the ith element of [tau * Q * w]\n          s = multiplyScalar(s, tau);\n          for (j = k; j < rows; ++j) {\n            Qdata[i][j] = divideScalar(subtractScalar(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);\n          }\n        }\n      }\n    }\n\n    // return matrices\n    return {\n      Q,\n      R,\n      toString: function toString() {\n        return 'Q: ' + this.Q.toString() + '\\nR: ' + this.R.toString();\n      }\n    };\n  }\n  function _denseQR(m) {\n    var ret = _denseQRimpl(m);\n    var Rdata = ret.R._data;\n    if (m._data.length > 0) {\n      var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;\n      for (var i = 0; i < Rdata.length; ++i) {\n        for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {\n          Rdata[i][j] = zero;\n        }\n      }\n    }\n    return ret;\n  }\n  function _sparseQR(m) {\n    throw new Error('qr not implemented for sparse matrices yet');\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1530, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\n\n/**\n * Permutes a sparse matrix C = P * A * Q\n *\n * @param {SparseMatrix}  a         The Matrix A\n * @param {Array}   pinv            The row permutation vector\n * @param {Array}   q               The column permutation vector\n * @param {boolean} values          Create a pattern matrix (false), values and pattern otherwise\n *\n * @return {Matrix}                 C = P * A * Q, null on error\n */\nexport function csPermute(a, pinv, q, values) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size;\n  var adt = a._datatype;\n  // rows & columns\n  var m = asize[0];\n  var n = asize[1];\n  // c arrays\n  var cvalues = values && a._values ? [] : null;\n  var cindex = []; // (aptr[n])\n  var cptr = []; // (n + 1)\n  // initialize vars\n  var nz = 0;\n  // loop columns\n  for (var k = 0; k < n; k++) {\n    // column k of C is column q[k] of A\n    cptr[k] = nz;\n    // apply column permutation\n    var j = q ? q[k] : k;\n    // loop values in column j of A\n    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {\n      // row i of A is row pinv[i] of C\n      var r = pinv ? pinv[aindex[t]] : aindex[t];\n      // index\n      cindex[nz] = r;\n      // check we need to populate values\n      if (cvalues) {\n        cvalues[nz] = avalues[t];\n      }\n      // increment number of nonzero elements\n      nz++;\n    }\n  }\n  // finalize the last column of C\n  cptr[n] = nz;\n  // return C matrix\n  return a.createSparseMatrix({\n    values: cvalues,\n    index: cindex,\n    ptr: cptr,\n    size: [m, n],\n    datatype: adt\n  });\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;AAE7E;;;;;;;;;CASC;;;AACM,SAAS,UAAU,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,MAAM;IAC1C,WAAW;IACX,IAAI,UAAU,EAAE,OAAO;IACvB,IAAI,SAAS,EAAE,MAAM;IACrB,IAAI,OAAO,EAAE,IAAI;IACjB,IAAI,QAAQ,EAAE,KAAK;IACnB,IAAI,MAAM,EAAE,SAAS;IACrB,iBAAiB;IACjB,IAAI,IAAI,KAAK,CAAC,EAAE;IAChB,IAAI,IAAI,KAAK,CAAC,EAAE;IAChB,WAAW;IACX,IAAI,UAAU,UAAU,EAAE,OAAO,GAAG,EAAE,GAAG;IACzC,IAAI,SAAS,EAAE,EAAE,YAAY;IAC7B,IAAI,OAAO,EAAE,EAAE,UAAU;IACzB,kBAAkB;IAClB,IAAI,KAAK;IACT,eAAe;IACf,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;QAC1B,oCAAoC;QACpC,IAAI,CAAC,EAAE,GAAG;QACV,2BAA2B;QAC3B,IAAI,IAAI,IAAI,CAAC,CAAC,EAAE,GAAG;QACnB,+BAA+B;QAC/B,IAAK,IAAI,KAAK,IAAI,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,IAAI,IAAI,IAAI,IAAK;YAC5D,iCAAiC;YACjC,IAAI,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,EAAE;YAC1C,QAAQ;YACR,MAAM,CAAC,GAAG,GAAG;YACb,mCAAmC;YACnC,IAAI,SAAS;gBACX,OAAO,CAAC,GAAG,GAAG,OAAO,CAAC,EAAE;YAC1B;YACA,uCAAuC;YACvC;QACF;IACF;IACA,gCAAgC;IAChC,IAAI,CAAC,EAAE,GAAG;IACV,kBAAkB;IAClB,OAAO,EAAE,kBAAkB,CAAC;QAC1B,QAAQ;QACR,OAAO;QACP,KAAK;QACL,MAAM;YAAC;YAAG;SAAE;QACZ,UAAU;IACZ;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1601, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\n\n/**\n * Depth-first search and postorder of a tree rooted at node j\n *\n * @param {Number}  j               The tree node\n * @param {Number}  k\n * @param {Array}   w               The workspace array\n * @param {Number}  head            The index offset within the workspace for the head array\n * @param {Number}  next            The index offset within the workspace for the next array\n * @param {Array}   post            The post ordering array\n * @param {Number}  stack           The index offset within the workspace for the stack array\n */\nexport function csTdfs(j, k, w, head, next, post, stack) {\n  // variables\n  var top = 0;\n  // place j on the stack\n  w[stack] = j;\n  // while (stack is not empty)\n  while (top >= 0) {\n    // p = top of stack\n    var p = w[stack + top];\n    // i = youngest child of p\n    var i = w[head + p];\n    if (i === -1) {\n      // p has no unordered children left\n      top--;\n      // node p is the kth postordered node\n      post[k++] = p;\n    } else {\n      // remove i from children of p\n      w[head + p] = w[next + i];\n      // increment top\n      ++top;\n      // start dfs on child node i\n      w[stack + top] = i;\n    }\n  }\n  return k;\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;AAE7E;;;;;;;;;;CAUC;;;AACM,SAAS,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK;IACrD,YAAY;IACZ,IAAI,MAAM;IACV,uBAAuB;IACvB,CAAC,CAAC,MAAM,GAAG;IACX,6BAA6B;IAC7B,MAAO,OAAO,EAAG;QACf,mBAAmB;QACnB,IAAI,IAAI,CAAC,CAAC,QAAQ,IAAI;QACtB,0BAA0B;QAC1B,IAAI,IAAI,CAAC,CAAC,OAAO,EAAE;QACnB,IAAI,MAAM,CAAC,GAAG;YACZ,mCAAmC;YACnC;YACA,qCAAqC;YACrC,IAAI,CAAC,IAAI,GAAG;QACd,OAAO;YACL,8BAA8B;YAC9B,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,OAAO,EAAE;YACzB,gBAAgB;YAChB,EAAE;YACF,4BAA4B;YAC5B,CAAC,CAAC,QAAQ,IAAI,GAAG;QACnB;IACF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1650, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\nimport { csTdfs } from './csTdfs.js';\n\n/**\n * Post order a tree of forest\n *\n * @param {Array}   parent          The tree or forest\n * @param {Number}  n               Number of columns\n */\nexport function csPost(parent, n) {\n  // check inputs\n  if (!parent) {\n    return null;\n  }\n  // vars\n  var k = 0;\n  var j;\n  // allocate result\n  var post = []; // (n)\n  // workspace, head: first n entries, next: next n entries, stack: last n entries\n  var w = []; // (3 * n)\n  var head = 0;\n  var next = n;\n  var stack = 2 * n;\n  // initialize workspace\n  for (j = 0; j < n; j++) {\n    // empty linked lists\n    w[head + j] = -1;\n  }\n  // traverse nodes in reverse order\n  for (j = n - 1; j >= 0; j--) {\n    // check j is a root\n    if (parent[j] === -1) {\n      continue;\n    }\n    // add j to list of its parent\n    w[next + j] = w[head + parent[j]];\n    w[head + parent[j]] = j;\n  }\n  // loop nodes\n  for (j = 0; j < n; j++) {\n    // skip j if it is not a root\n    if (parent[j] !== -1) {\n      continue;\n    }\n    // depth-first search\n    k = csTdfs(j, k, w, head, next, post, stack);\n  }\n  return post;\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;;;;AAC7E;;AAQO,SAAS,OAAO,MAAM,EAAE,CAAC;IAC9B,eAAe;IACf,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IACA,OAAO;IACP,IAAI,IAAI;IACR,IAAI;IACJ,kBAAkB;IAClB,IAAI,OAAO,EAAE,EAAE,MAAM;IACrB,gFAAgF;IAChF,IAAI,IAAI,EAAE,EAAE,UAAU;IACtB,IAAI,OAAO;IACX,IAAI,OAAO;IACX,IAAI,QAAQ,IAAI;IAChB,uBAAuB;IACvB,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;QACtB,qBAAqB;QACrB,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;IACjB;IACA,kCAAkC;IAClC,IAAK,IAAI,IAAI,GAAG,KAAK,GAAG,IAAK;QAC3B,oBAAoB;QACpB,IAAI,MAAM,CAAC,EAAE,KAAK,CAAC,GAAG;YACpB;QACF;QACA,8BAA8B;QAC9B,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,OAAO,MAAM,CAAC,EAAE,CAAC;QACjC,CAAC,CAAC,OAAO,MAAM,CAAC,EAAE,CAAC,GAAG;IACxB;IACA,aAAa;IACb,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;QACtB,6BAA6B;QAC7B,IAAI,MAAM,CAAC,EAAE,KAAK,CAAC,GAAG;YACpB;QACF;QACA,qBAAqB;QACrB,IAAI,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE,GAAG,GAAG,GAAG,MAAM,MAAM,MAAM;IACxC;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1705, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\n\n/**\n * Computes the elimination tree of Matrix A (using triu(A)) or the\n * elimination tree of A'A without forming A'A.\n *\n * @param {Matrix}  a               The A Matrix\n * @param {boolean} ata             A value of true the function computes the etree of A'A\n */\nexport function csEtree(a, ata) {\n  // check inputs\n  if (!a) {\n    return null;\n  }\n  // a arrays\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size;\n  // rows & columns\n  var m = asize[0];\n  var n = asize[1];\n\n  // allocate result\n  var parent = []; // (n)\n\n  // allocate workspace\n  var w = []; // (n + (ata ? m : 0))\n  var ancestor = 0; // first n entries in w\n  var prev = n; // last m entries (ata = true)\n\n  var i, inext;\n\n  // check we are calculating A'A\n  if (ata) {\n    // initialize workspace\n    for (i = 0; i < m; i++) {\n      w[prev + i] = -1;\n    }\n  }\n  // loop columns\n  for (var k = 0; k < n; k++) {\n    // node k has no parent yet\n    parent[k] = -1;\n    // nor does k have an ancestor\n    w[ancestor + k] = -1;\n    // values in column k\n    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n      // row\n      var r = aindex[p];\n      // node\n      i = ata ? w[prev + r] : r;\n      // traverse from i to k\n      for (; i !== -1 && i < k; i = inext) {\n        // inext = ancestor of i\n        inext = w[ancestor + i];\n        // path compression\n        w[ancestor + i] = k;\n        // check no anc., parent is k\n        if (inext === -1) {\n          parent[i] = k;\n        }\n      }\n      if (ata) {\n        w[prev + r] = k;\n      }\n    }\n  }\n  return parent;\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;AAE7E;;;;;;CAMC;;;AACM,SAAS,QAAQ,CAAC,EAAE,GAAG;IAC5B,eAAe;IACf,IAAI,CAAC,GAAG;QACN,OAAO;IACT;IACA,WAAW;IACX,IAAI,SAAS,EAAE,MAAM;IACrB,IAAI,OAAO,EAAE,IAAI;IACjB,IAAI,QAAQ,EAAE,KAAK;IACnB,iBAAiB;IACjB,IAAI,IAAI,KAAK,CAAC,EAAE;IAChB,IAAI,IAAI,KAAK,CAAC,EAAE;IAEhB,kBAAkB;IAClB,IAAI,SAAS,EAAE,EAAE,MAAM;IAEvB,qBAAqB;IACrB,IAAI,IAAI,EAAE,EAAE,sBAAsB;IAClC,IAAI,WAAW,GAAG,uBAAuB;IACzC,IAAI,OAAO,GAAG,8BAA8B;IAE5C,IAAI,GAAG;IAEP,+BAA+B;IAC/B,IAAI,KAAK;QACP,uBAAuB;QACvB,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;YACtB,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;QACjB;IACF;IACA,eAAe;IACf,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;QAC1B,2BAA2B;QAC3B,MAAM,CAAC,EAAE,GAAG,CAAC;QACb,8BAA8B;QAC9B,CAAC,CAAC,WAAW,EAAE,GAAG,CAAC;QACnB,qBAAqB;QACrB,IAAK,IAAI,KAAK,IAAI,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,IAAI,IAAI,IAAI,IAAK;YAC5D,MAAM;YACN,IAAI,IAAI,MAAM,CAAC,EAAE;YACjB,OAAO;YACP,IAAI,MAAM,CAAC,CAAC,OAAO,EAAE,GAAG;YACxB,uBAAuB;YACvB,MAAO,MAAM,CAAC,KAAK,IAAI,GAAG,IAAI,MAAO;gBACnC,wBAAwB;gBACxB,QAAQ,CAAC,CAAC,WAAW,EAAE;gBACvB,mBAAmB;gBACnB,CAAC,CAAC,WAAW,EAAE,GAAG;gBAClB,6BAA6B;gBAC7B,IAAI,UAAU,CAAC,GAAG;oBAChB,MAAM,CAAC,EAAE,GAAG;gBACd;YACF;YACA,IAAI,KAAK;gBACP,CAAC,CAAC,OAAO,EAAE,GAAG;YAChB;QACF;IACF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1779, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\n\n/**\n * Keeps entries in the matrix when the callback function returns true, removes the entry otherwise\n *\n * @param {Matrix}   a              The sparse matrix\n * @param {function} callback       The callback function, function will be invoked with the following args:\n *                                    - The entry row\n *                                    - The entry column\n *                                    - The entry value\n *                                    - The state parameter\n * @param {any}      other          The state\n *\n * @return                          The number of nonzero elements in the matrix\n */\nexport function csFkeep(a, callback, other) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size;\n  // columns\n  var n = asize[1];\n  // nonzero items\n  var nz = 0;\n  // loop columns\n  for (var j = 0; j < n; j++) {\n    // get current location of col j\n    var p = aptr[j];\n    // record new location of col j\n    aptr[j] = nz;\n    for (; p < aptr[j + 1]; p++) {\n      // check we need to keep this item\n      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {\n        // keep A(i,j)\n        aindex[nz] = aindex[p];\n        // check we need to process values (pattern only)\n        if (avalues) {\n          avalues[nz] = avalues[p];\n        }\n        // increment nonzero items\n        nz++;\n      }\n    }\n  }\n  // finalize A\n  aptr[n] = nz;\n  // trim arrays\n  aindex.splice(nz, aindex.length - nz);\n  // check we need to process values (pattern only)\n  if (avalues) {\n    avalues.splice(nz, avalues.length - nz);\n  }\n  // return number of nonzero items\n  return nz;\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;AAE7E;;;;;;;;;;;;CAYC;;;AACM,SAAS,QAAQ,CAAC,EAAE,QAAQ,EAAE,KAAK;IACxC,WAAW;IACX,IAAI,UAAU,EAAE,OAAO;IACvB,IAAI,SAAS,EAAE,MAAM;IACrB,IAAI,OAAO,EAAE,IAAI;IACjB,IAAI,QAAQ,EAAE,KAAK;IACnB,UAAU;IACV,IAAI,IAAI,KAAK,CAAC,EAAE;IAChB,gBAAgB;IAChB,IAAI,KAAK;IACT,eAAe;IACf,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;QAC1B,gCAAgC;QAChC,IAAI,IAAI,IAAI,CAAC,EAAE;QACf,+BAA+B;QAC/B,IAAI,CAAC,EAAE,GAAG;QACV,MAAO,IAAI,IAAI,CAAC,IAAI,EAAE,EAAE,IAAK;YAC3B,kCAAkC;YAClC,IAAI,SAAS,MAAM,CAAC,EAAE,EAAE,GAAG,UAAU,OAAO,CAAC,EAAE,GAAG,GAAG,QAAQ;gBAC3D,cAAc;gBACd,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,EAAE;gBACtB,iDAAiD;gBACjD,IAAI,SAAS;oBACX,OAAO,CAAC,GAAG,GAAG,OAAO,CAAC,EAAE;gBAC1B;gBACA,0BAA0B;gBAC1B;YACF;QACF;IACF;IACA,aAAa;IACb,IAAI,CAAC,EAAE,GAAG;IACV,cAAc;IACd,OAAO,MAAM,CAAC,IAAI,OAAO,MAAM,GAAG;IAClC,iDAAiD;IACjD,IAAI,SAAS;QACX,QAAQ,MAAM,CAAC,IAAI,QAAQ,MAAM,GAAG;IACtC;IACA,iCAAiC;IACjC,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1844, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\n\n/**\n * This function \"flips\" its input about the integer -1.\n *\n * @param {Number}  i               The value to flip\n */\nexport function csFlip(i) {\n  // flip the value\n  return -i - 2;\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;AAE7E;;;;CAIC;;;AACM,SAAS,OAAO,CAAC;IACtB,iBAAiB;IACjB,OAAO,CAAC,IAAI;AACd","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1864, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\nimport { factory } from '../../../utils/factory.js';\nimport { csFkeep } from './csFkeep.js';\nimport { csFlip } from './csFlip.js';\nimport { csTdfs } from './csTdfs.js';\nvar name = 'csAmd';\nvar dependencies = ['add', 'multiply', 'transpose'];\nexport var createCsAmd = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    add,\n    multiply,\n    transpose\n  } = _ref;\n  /**\n   * Approximate minimum degree ordering. The minimum degree algorithm is a widely used\n   * heuristic for finding a permutation P so that P*A*P' has fewer nonzeros in its factorization\n   * than A. It is a gready method that selects the sparsest pivot row and column during the course\n   * of a right looking sparse Cholesky factorization.\n   *\n   * @param {Number} order    0: Natural, 1: Cholesky, 2: LU, 3: QR\n   * @param {Matrix} m        Sparse Matrix\n   */\n  return function csAmd(order, a) {\n    // check input parameters\n    if (!a || order <= 0 || order > 3) {\n      return null;\n    }\n    // a matrix arrays\n    var asize = a._size;\n    // rows and columns\n    var m = asize[0];\n    var n = asize[1];\n    // initialize vars\n    var lemax = 0;\n    // dense threshold\n    var dense = Math.max(16, 10 * Math.sqrt(n));\n    dense = Math.min(n - 2, dense);\n    // create target matrix C\n    var cm = _createTargetMatrix(order, a, m, n, dense);\n    // drop diagonal entries\n    csFkeep(cm, _diag, null);\n    // C matrix arrays\n    var cindex = cm._index;\n    var cptr = cm._ptr;\n\n    // number of nonzero elements in C\n    var cnz = cptr[n];\n\n    // allocate result (n+1)\n    var P = [];\n\n    // create workspace (8 * (n + 1))\n    var W = [];\n    var len = 0; // first n + 1 entries\n    var nv = n + 1; // next n + 1 entries\n    var next = 2 * (n + 1); // next n + 1 entries\n    var head = 3 * (n + 1); // next n + 1 entries\n    var elen = 4 * (n + 1); // next n + 1 entries\n    var degree = 5 * (n + 1); // next n + 1 entries\n    var w = 6 * (n + 1); // next n + 1 entries\n    var hhead = 7 * (n + 1); // last n + 1 entries\n\n    // use P as workspace for last\n    var last = P;\n\n    // initialize quotient graph\n    var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);\n\n    // initialize degree lists\n    var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);\n\n    // minimum degree node\n    var mindeg = 0;\n\n    // vars\n    var i, j, k, k1, k2, e, pj, ln, nvi, pk, eln, p1, p2, pn, h, d;\n\n    // while (selecting pivots) do\n    while (nel < n) {\n      // select node of minimum approximate degree. amd() is now ready to start eliminating the graph. It first\n      // finds a node k of minimum degree and removes it from its degree list. The variable nel keeps track of thow\n      // many nodes have been eliminated.\n      for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++);\n      if (W[next + k] !== -1) {\n        last[W[next + k]] = -1;\n      }\n      // remove k from degree list\n      W[head + mindeg] = W[next + k];\n      // elenk = |Ek|\n      var elenk = W[elen + k];\n      // # of nodes k represents\n      var nvk = W[nv + k];\n      // W[nv + k] nodes of A eliminated\n      nel += nvk;\n\n      // Construct a new element. The new element Lk is constructed in place if |Ek| = 0. nv[i] is\n      // negated for all nodes i in Lk to flag them as members of this set. Each node i is removed from the\n      // degree lists. All elements e in Ek are absorved into element k.\n      var dk = 0;\n      // flag k as in Lk\n      W[nv + k] = -nvk;\n      var p = cptr[k];\n      // do in place if W[elen + k] === 0\n      var pk1 = elenk === 0 ? p : cnz;\n      var pk2 = pk1;\n      for (k1 = 1; k1 <= elenk + 1; k1++) {\n        if (k1 > elenk) {\n          // search the nodes in k\n          e = k;\n          // list of nodes starts at cindex[pj]\n          pj = p;\n          // length of list of nodes in k\n          ln = W[len + k] - elenk;\n        } else {\n          // search the nodes in e\n          e = cindex[p++];\n          pj = cptr[e];\n          // length of list of nodes in e\n          ln = W[len + e];\n        }\n        for (k2 = 1; k2 <= ln; k2++) {\n          i = cindex[pj++];\n          // check  node i dead, or seen\n          if ((nvi = W[nv + i]) <= 0) {\n            continue;\n          }\n          // W[degree + Lk] += size of node i\n          dk += nvi;\n          // negate W[nv + i] to denote i in Lk\n          W[nv + i] = -nvi;\n          // place i in Lk\n          cindex[pk2++] = i;\n          if (W[next + i] !== -1) {\n            last[W[next + i]] = last[i];\n          }\n          // check we need to remove i from degree list\n          if (last[i] !== -1) {\n            W[next + last[i]] = W[next + i];\n          } else {\n            W[head + W[degree + i]] = W[next + i];\n          }\n        }\n        if (e !== k) {\n          // absorb e into k\n          cptr[e] = csFlip(k);\n          // e is now a dead element\n          W[w + e] = 0;\n        }\n      }\n      // cindex[cnz...nzmax] is free\n      if (elenk !== 0) {\n        cnz = pk2;\n      }\n      // external degree of k - |Lk\\i|\n      W[degree + k] = dk;\n      // element k is in cindex[pk1..pk2-1]\n      cptr[k] = pk1;\n      W[len + k] = pk2 - pk1;\n      // k is now an element\n      W[elen + k] = -2;\n\n      // Find set differences. The scan1 function now computes the set differences |Le \\ Lk| for all elements e. At the start of the\n      // scan, no entry in the w array is greater than or equal to mark.\n\n      // clear w if necessary\n      mark = _wclear(mark, lemax, W, w, n);\n      // scan 1: find |Le\\Lk|\n      for (pk = pk1; pk < pk2; pk++) {\n        i = cindex[pk];\n        // check if W[elen + i] empty, skip it\n        if ((eln = W[elen + i]) <= 0) {\n          continue;\n        }\n        // W[nv + i] was negated\n        nvi = -W[nv + i];\n        var wnvi = mark - nvi;\n        // scan Ei\n        for (p = cptr[i], p1 = cptr[i] + eln - 1; p <= p1; p++) {\n          e = cindex[p];\n          if (W[w + e] >= mark) {\n            // decrement |Le\\Lk|\n            W[w + e] -= nvi;\n          } else if (W[w + e] !== 0) {\n            // ensure e is a live element, 1st time e seen in scan 1\n            W[w + e] = W[degree + e] + wnvi;\n          }\n        }\n      }\n\n      // degree update\n      // The second pass computes the approximate degree di, prunes the sets Ei and Ai, and computes a hash\n      // function h(i) for all nodes in Lk.\n\n      // scan2: degree update\n      for (pk = pk1; pk < pk2; pk++) {\n        // consider node i in Lk\n        i = cindex[pk];\n        p1 = cptr[i];\n        p2 = p1 + W[elen + i] - 1;\n        pn = p1;\n        // scan Ei\n        for (h = 0, d = 0, p = p1; p <= p2; p++) {\n          e = cindex[p];\n          // check e is an unabsorbed element\n          if (W[w + e] !== 0) {\n            // dext = |Le\\Lk|\n            var dext = W[w + e] - mark;\n            if (dext > 0) {\n              // sum up the set differences\n              d += dext;\n              // keep e in Ei\n              cindex[pn++] = e;\n              // compute the hash of node i\n              h += e;\n            } else {\n              // aggressive absorb. e->k\n              cptr[e] = csFlip(k);\n              // e is a dead element\n              W[w + e] = 0;\n            }\n          }\n        }\n        // W[elen + i] = |Ei|\n        W[elen + i] = pn - p1 + 1;\n        var p3 = pn;\n        var p4 = p1 + W[len + i];\n        // prune edges in Ai\n        for (p = p2 + 1; p < p4; p++) {\n          j = cindex[p];\n          // check node j dead or in Lk\n          var nvj = W[nv + j];\n          if (nvj <= 0) {\n            continue;\n          }\n          // degree(i) += |j|\n          d += nvj;\n          // place j in node list of i\n          cindex[pn++] = j;\n          // compute hash for node i\n          h += j;\n        }\n        // check for mass elimination\n        if (d === 0) {\n          // absorb i into k\n          cptr[i] = csFlip(k);\n          nvi = -W[nv + i];\n          // |Lk| -= |i|\n          dk -= nvi;\n          // |k| += W[nv + i]\n          nvk += nvi;\n          nel += nvi;\n          W[nv + i] = 0;\n          // node i is dead\n          W[elen + i] = -1;\n        } else {\n          // update degree(i)\n          W[degree + i] = Math.min(W[degree + i], d);\n          // move first node to end\n          cindex[pn] = cindex[p3];\n          // move 1st el. to end of Ei\n          cindex[p3] = cindex[p1];\n          // add k as 1st element in of Ei\n          cindex[p1] = k;\n          // new len of adj. list of node i\n          W[len + i] = pn - p1 + 1;\n          // finalize hash of i\n          h = (h < 0 ? -h : h) % n;\n          // place i in hash bucket\n          W[next + i] = W[hhead + h];\n          W[hhead + h] = i;\n          // save hash of i in last[i]\n          last[i] = h;\n        }\n      }\n      // finalize |Lk|\n      W[degree + k] = dk;\n      lemax = Math.max(lemax, dk);\n      // clear w\n      mark = _wclear(mark + lemax, lemax, W, w, n);\n\n      // Supernode detection. Supernode detection relies on the hash function h(i) computed for each node i.\n      // If two nodes have identical adjacency lists, their hash functions wil be identical.\n      for (pk = pk1; pk < pk2; pk++) {\n        i = cindex[pk];\n        // check i is dead, skip it\n        if (W[nv + i] >= 0) {\n          continue;\n        }\n        // scan hash bucket of node i\n        h = last[i];\n        i = W[hhead + h];\n        // hash bucket will be empty\n        W[hhead + h] = -1;\n        for (; i !== -1 && W[next + i] !== -1; i = W[next + i], mark++) {\n          ln = W[len + i];\n          eln = W[elen + i];\n          for (p = cptr[i] + 1; p <= cptr[i] + ln - 1; p++) {\n            W[w + cindex[p]] = mark;\n          }\n          var jlast = i;\n          // compare i with all j\n          for (j = W[next + i]; j !== -1;) {\n            var ok = W[len + j] === ln && W[elen + j] === eln;\n            for (p = cptr[j] + 1; ok && p <= cptr[j] + ln - 1; p++) {\n              // compare i and j\n              if (W[w + cindex[p]] !== mark) {\n                ok = 0;\n              }\n            }\n            // check i and j are identical\n            if (ok) {\n              // absorb j into i\n              cptr[j] = csFlip(i);\n              W[nv + i] += W[nv + j];\n              W[nv + j] = 0;\n              // node j is dead\n              W[elen + j] = -1;\n              // delete j from hash bucket\n              j = W[next + j];\n              W[next + jlast] = j;\n            } else {\n              // j and i are different\n              jlast = j;\n              j = W[next + j];\n            }\n          }\n        }\n      }\n\n      // Finalize new element. The elimination of node k is nearly complete. All nodes i in Lk are scanned one last time.\n      // Node i is removed from Lk if it is dead. The flagged status of nv[i] is cleared.\n      for (p = pk1, pk = pk1; pk < pk2; pk++) {\n        i = cindex[pk];\n        // check  i is dead, skip it\n        if ((nvi = -W[nv + i]) <= 0) {\n          continue;\n        }\n        // restore W[nv + i]\n        W[nv + i] = nvi;\n        // compute external degree(i)\n        d = W[degree + i] + dk - nvi;\n        d = Math.min(d, n - nel - nvi);\n        if (W[head + d] !== -1) {\n          last[W[head + d]] = i;\n        }\n        // put i back in degree list\n        W[next + i] = W[head + d];\n        last[i] = -1;\n        W[head + d] = i;\n        // find new minimum degree\n        mindeg = Math.min(mindeg, d);\n        W[degree + i] = d;\n        // place i in Lk\n        cindex[p++] = i;\n      }\n      // # nodes absorbed into k\n      W[nv + k] = nvk;\n      // length of adj list of element k\n      if ((W[len + k] = p - pk1) === 0) {\n        // k is a root of the tree\n        cptr[k] = -1;\n        // k is now a dead element\n        W[w + k] = 0;\n      }\n      if (elenk !== 0) {\n        // free unused space in Lk\n        cnz = p;\n      }\n    }\n\n    // Postordering. The elimination is complete, but no permutation has been computed. All that is left\n    // of the graph is the assembly tree (ptr) and a set of dead nodes and elements (i is a dead node if\n    // nv[i] is zero and a dead element if nv[i] > 0). It is from this information only that the final permutation\n    // is computed. The tree is restored by unflipping all of ptr.\n\n    // fix assembly tree\n    for (i = 0; i < n; i++) {\n      cptr[i] = csFlip(cptr[i]);\n    }\n    for (j = 0; j <= n; j++) {\n      W[head + j] = -1;\n    }\n    // place unordered nodes in lists\n    for (j = n; j >= 0; j--) {\n      // skip if j is an element\n      if (W[nv + j] > 0) {\n        continue;\n      }\n      // place j in list of its parent\n      W[next + j] = W[head + cptr[j]];\n      W[head + cptr[j]] = j;\n    }\n    // place elements in lists\n    for (e = n; e >= 0; e--) {\n      // skip unless e is an element\n      if (W[nv + e] <= 0) {\n        continue;\n      }\n      if (cptr[e] !== -1) {\n        // place e in list of its parent\n        W[next + e] = W[head + cptr[e]];\n        W[head + cptr[e]] = e;\n      }\n    }\n    // postorder the assembly tree\n    for (k = 0, i = 0; i <= n; i++) {\n      if (cptr[i] === -1) {\n        k = csTdfs(i, k, W, head, next, P, w);\n      }\n    }\n    // remove last item in array\n    P.splice(P.length - 1, 1);\n    // return P\n    return P;\n  };\n\n  /**\n   * Creates the matrix that will be used by the approximate minimum degree ordering algorithm. The function accepts the matrix M as input and returns a permutation\n   * vector P. The amd algorithm operates on a symmetrix matrix, so one of three symmetric matrices is formed.\n   *\n   * Order: 0\n   *   A natural ordering P=null matrix is returned.\n   *\n   * Order: 1\n   *   Matrix must be square. This is appropriate for a Cholesky or LU factorization.\n   *   P = M + M'\n   *\n   * Order: 2\n   *   Dense columns from M' are dropped, M recreated from M'. This is appropriatefor LU factorization of unsymmetric matrices.\n   *   P = M' * M\n   *\n   * Order: 3\n   *   This is best used for QR factorization or LU factorization is matrix M has no dense rows. A dense row is a row with more than 10*sqr(columns) entries.\n   *   P = M' * M\n   */\n  function _createTargetMatrix(order, a, m, n, dense) {\n    // compute A'\n    var at = transpose(a);\n\n    // check order = 1, matrix must be square\n    if (order === 1 && n === m) {\n      // C = A + A'\n      return add(a, at);\n    }\n\n    // check order = 2, drop dense columns from M'\n    if (order === 2) {\n      // transpose arrays\n      var tindex = at._index;\n      var tptr = at._ptr;\n      // new column index\n      var p2 = 0;\n      // loop A' columns (rows)\n      for (var j = 0; j < m; j++) {\n        // column j of AT starts here\n        var p = tptr[j];\n        // new column j starts here\n        tptr[j] = p2;\n        // skip dense col j\n        if (tptr[j + 1] - p > dense) {\n          continue;\n        }\n        // map rows in column j of A\n        for (var p1 = tptr[j + 1]; p < p1; p++) {\n          tindex[p2++] = tindex[p];\n        }\n      }\n      // finalize AT\n      tptr[m] = p2;\n      // recreate A from new transpose matrix\n      a = transpose(at);\n      // use A' * A\n      return multiply(at, a);\n    }\n\n    // use A' * A, square or rectangular matrix\n    return multiply(at, a);\n  }\n\n  /**\n   * Initialize quotient graph. There are four kind of nodes and elements that must be represented:\n   *\n   *  - A live node is a node i (or a supernode) that has not been selected as a pivot nad has not been merged into another supernode.\n   *  - A dead node i is one that has been removed from the graph, having been absorved into r = flip(ptr[i]).\n   *  - A live element e is one that is in the graph, having been formed when node e was selected as the pivot.\n   *  - A dead element e is one that has benn absorved into a subsequent element s = flip(ptr[e]).\n   */\n  function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {\n    // Initialize quotient graph\n    for (var k = 0; k < n; k++) {\n      W[len + k] = cptr[k + 1] - cptr[k];\n    }\n    W[len + n] = 0;\n    // initialize workspace\n    for (var i = 0; i <= n; i++) {\n      // degree list i is empty\n      W[head + i] = -1;\n      last[i] = -1;\n      W[next + i] = -1;\n      // hash list i is empty\n      W[hhead + i] = -1;\n      // node i is just one node\n      W[nv + i] = 1;\n      // node i is alive\n      W[w + i] = 1;\n      // Ek of node i is empty\n      W[elen + i] = 0;\n      // degree of node i\n      W[degree + i] = W[len + i];\n    }\n    // clear w\n    var mark = _wclear(0, 0, W, w, n);\n    // n is a dead element\n    W[elen + n] = -2;\n    // n is a root of assembly tree\n    cptr[n] = -1;\n    // n is a dead element\n    W[w + n] = 0;\n    // return mark\n    return mark;\n  }\n\n  /**\n   * Initialize degree lists. Each node is placed in its degree lists. Nodes of zero degree are eliminated immediately. Nodes with\n   * degree >= dense are alsol eliminated and merged into a placeholder node n, a dead element. Thes nodes will appera last in the\n   * output permutation p.\n   */\n  function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {\n    // result\n    var nel = 0;\n    // loop columns\n    for (var i = 0; i < n; i++) {\n      // degree @ i\n      var d = W[degree + i];\n      // check node i is empty\n      if (d === 0) {\n        // element i is dead\n        W[elen + i] = -2;\n        nel++;\n        // i is a root of assembly tree\n        cptr[i] = -1;\n        W[w + i] = 0;\n      } else if (d > dense) {\n        // absorb i into element n\n        W[nv + i] = 0;\n        // node i is dead\n        W[elen + i] = -1;\n        nel++;\n        cptr[i] = csFlip(n);\n        W[nv + n]++;\n      } else {\n        var h = W[head + d];\n        if (h !== -1) {\n          last[h] = i;\n        }\n        // put node i in degree list d\n        W[next + i] = W[head + d];\n        W[head + d] = i;\n      }\n    }\n    return nel;\n  }\n  function _wclear(mark, lemax, W, w, n) {\n    if (mark < 2 || mark + lemax < 0) {\n      for (var k = 0; k < n; k++) {\n        if (W[w + k] !== 0) {\n          W[w + k] = 1;\n        }\n      }\n      mark = 2;\n    }\n    // at this point, W [0..n-1] < mark holds\n    return mark;\n  }\n  function _diag(i, j) {\n    return i !== j;\n  }\n});"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;;;;AAC7E;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAO;IAAY;CAAY;AAC5C,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,GAAG,EACH,QAAQ,EACR,SAAS,EACV,GAAG;IACJ;;;;;;;;GAQC,GACD,OAAO,SAAS,MAAM,KAAK,EAAE,CAAC;QAC5B,yBAAyB;QACzB,IAAI,CAAC,KAAK,SAAS,KAAK,QAAQ,GAAG;YACjC,OAAO;QACT;QACA,kBAAkB;QAClB,IAAI,QAAQ,EAAE,KAAK;QACnB,mBAAmB;QACnB,IAAI,IAAI,KAAK,CAAC,EAAE;QAChB,IAAI,IAAI,KAAK,CAAC,EAAE;QAChB,kBAAkB;QAClB,IAAI,QAAQ;QACZ,kBAAkB;QAClB,IAAI,QAAQ,KAAK,GAAG,CAAC,IAAI,KAAK,KAAK,IAAI,CAAC;QACxC,QAAQ,KAAK,GAAG,CAAC,IAAI,GAAG;QACxB,yBAAyB;QACzB,IAAI,KAAK,oBAAoB,OAAO,GAAG,GAAG,GAAG;QAC7C,wBAAwB;QACxB,CAAA,GAAA,mLAAA,CAAA,UAAO,AAAD,EAAE,IAAI,OAAO;QACnB,kBAAkB;QAClB,IAAI,SAAS,GAAG,MAAM;QACtB,IAAI,OAAO,GAAG,IAAI;QAElB,kCAAkC;QAClC,IAAI,MAAM,IAAI,CAAC,EAAE;QAEjB,wBAAwB;QACxB,IAAI,IAAI,EAAE;QAEV,iCAAiC;QACjC,IAAI,IAAI,EAAE;QACV,IAAI,MAAM,GAAG,sBAAsB;QACnC,IAAI,KAAK,IAAI,GAAG,qBAAqB;QACrC,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,qBAAqB;QAC7C,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,qBAAqB;QAC7C,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,qBAAqB;QAC7C,IAAI,SAAS,IAAI,CAAC,IAAI,CAAC,GAAG,qBAAqB;QAC/C,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,qBAAqB;QAC1C,IAAI,QAAQ,IAAI,CAAC,IAAI,CAAC,GAAG,qBAAqB;QAE9C,8BAA8B;QAC9B,IAAI,OAAO;QAEX,4BAA4B;QAC5B,IAAI,OAAO,yBAAyB,GAAG,MAAM,GAAG,KAAK,MAAM,MAAM,MAAM,OAAO,IAAI,GAAG,MAAM;QAE3F,0BAA0B;QAC1B,IAAI,MAAM,uBAAuB,GAAG,MAAM,GAAG,QAAQ,MAAM,GAAG,OAAO,IAAI,MAAM,MAAM;QAErF,sBAAsB;QACtB,IAAI,SAAS;QAEb,OAAO;QACP,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,IAAI,GAAG;QAE7D,8BAA8B;QAC9B,MAAO,MAAM,EAAG;YACd,yGAAyG;YACzG,6GAA6G;YAC7G,mCAAmC;YACnC,IAAK,IAAI,CAAC,GAAG,SAAS,KAAK,CAAC,IAAI,CAAC,CAAC,OAAO,OAAO,MAAM,CAAC,GAAG;YAC1D,IAAI,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,GAAG;gBACtB,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,GAAG,CAAC;YACvB;YACA,4BAA4B;YAC5B,CAAC,CAAC,OAAO,OAAO,GAAG,CAAC,CAAC,OAAO,EAAE;YAC9B,eAAe;YACf,IAAI,QAAQ,CAAC,CAAC,OAAO,EAAE;YACvB,0BAA0B;YAC1B,IAAI,MAAM,CAAC,CAAC,KAAK,EAAE;YACnB,kCAAkC;YAClC,OAAO;YAEP,4FAA4F;YAC5F,qGAAqG;YACrG,kEAAkE;YAClE,IAAI,KAAK;YACT,kBAAkB;YAClB,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC;YACb,IAAI,IAAI,IAAI,CAAC,EAAE;YACf,mCAAmC;YACnC,IAAI,MAAM,UAAU,IAAI,IAAI;YAC5B,IAAI,MAAM;YACV,IAAK,KAAK,GAAG,MAAM,QAAQ,GAAG,KAAM;gBAClC,IAAI,KAAK,OAAO;oBACd,wBAAwB;oBACxB,IAAI;oBACJ,qCAAqC;oBACrC,KAAK;oBACL,+BAA+B;oBAC/B,KAAK,CAAC,CAAC,MAAM,EAAE,GAAG;gBACpB,OAAO;oBACL,wBAAwB;oBACxB,IAAI,MAAM,CAAC,IAAI;oBACf,KAAK,IAAI,CAAC,EAAE;oBACZ,+BAA+B;oBAC/B,KAAK,CAAC,CAAC,MAAM,EAAE;gBACjB;gBACA,IAAK,KAAK,GAAG,MAAM,IAAI,KAAM;oBAC3B,IAAI,MAAM,CAAC,KAAK;oBAChB,8BAA8B;oBAC9B,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,KAAK,GAAG;wBAC1B;oBACF;oBACA,mCAAmC;oBACnC,MAAM;oBACN,qCAAqC;oBACrC,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC;oBACb,gBAAgB;oBAChB,MAAM,CAAC,MAAM,GAAG;oBAChB,IAAI,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,GAAG;wBACtB,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,GAAG,IAAI,CAAC,EAAE;oBAC7B;oBACA,6CAA6C;oBAC7C,IAAI,IAAI,CAAC,EAAE,KAAK,CAAC,GAAG;wBAClB,CAAC,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE;oBACjC,OAAO;wBACL,CAAC,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE;oBACvC;gBACF;gBACA,IAAI,MAAM,GAAG;oBACX,kBAAkB;oBAClB,IAAI,CAAC,EAAE,GAAG,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE;oBACjB,0BAA0B;oBAC1B,CAAC,CAAC,IAAI,EAAE,GAAG;gBACb;YACF;YACA,8BAA8B;YAC9B,IAAI,UAAU,GAAG;gBACf,MAAM;YACR;YACA,gCAAgC;YAChC,CAAC,CAAC,SAAS,EAAE,GAAG;YAChB,qCAAqC;YACrC,IAAI,CAAC,EAAE,GAAG;YACV,CAAC,CAAC,MAAM,EAAE,GAAG,MAAM;YACnB,sBAAsB;YACtB,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;YAEf,8HAA8H;YAC9H,kEAAkE;YAElE,uBAAuB;YACvB,OAAO,QAAQ,MAAM,OAAO,GAAG,GAAG;YAClC,uBAAuB;YACvB,IAAK,KAAK,KAAK,KAAK,KAAK,KAAM;gBAC7B,IAAI,MAAM,CAAC,GAAG;gBACd,sCAAsC;gBACtC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,KAAK,GAAG;oBAC5B;gBACF;gBACA,wBAAwB;gBACxB,MAAM,CAAC,CAAC,CAAC,KAAK,EAAE;gBAChB,IAAI,OAAO,OAAO;gBAClB,UAAU;gBACV,IAAK,IAAI,IAAI,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,EAAE,GAAG,MAAM,GAAG,KAAK,IAAI,IAAK;oBACtD,IAAI,MAAM,CAAC,EAAE;oBACb,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,MAAM;wBACpB,oBAAoB;wBACpB,CAAC,CAAC,IAAI,EAAE,IAAI;oBACd,OAAO,IAAI,CAAC,CAAC,IAAI,EAAE,KAAK,GAAG;wBACzB,wDAAwD;wBACxD,CAAC,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,SAAS,EAAE,GAAG;oBAC7B;gBACF;YACF;YAEA,gBAAgB;YAChB,qGAAqG;YACrG,qCAAqC;YAErC,uBAAuB;YACvB,IAAK,KAAK,KAAK,KAAK,KAAK,KAAM;gBAC7B,wBAAwB;gBACxB,IAAI,MAAM,CAAC,GAAG;gBACd,KAAK,IAAI,CAAC,EAAE;gBACZ,KAAK,KAAK,CAAC,CAAC,OAAO,EAAE,GAAG;gBACxB,KAAK;gBACL,UAAU;gBACV,IAAK,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,KAAK,IAAI,IAAK;oBACvC,IAAI,MAAM,CAAC,EAAE;oBACb,mCAAmC;oBACnC,IAAI,CAAC,CAAC,IAAI,EAAE,KAAK,GAAG;wBAClB,iBAAiB;wBACjB,IAAI,OAAO,CAAC,CAAC,IAAI,EAAE,GAAG;wBACtB,IAAI,OAAO,GAAG;4BACZ,6BAA6B;4BAC7B,KAAK;4BACL,eAAe;4BACf,MAAM,CAAC,KAAK,GAAG;4BACf,6BAA6B;4BAC7B,KAAK;wBACP,OAAO;4BACL,0BAA0B;4BAC1B,IAAI,CAAC,EAAE,GAAG,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE;4BACjB,sBAAsB;4BACtB,CAAC,CAAC,IAAI,EAAE,GAAG;wBACb;oBACF;gBACF;gBACA,qBAAqB;gBACrB,CAAC,CAAC,OAAO,EAAE,GAAG,KAAK,KAAK;gBACxB,IAAI,KAAK;gBACT,IAAI,KAAK,KAAK,CAAC,CAAC,MAAM,EAAE;gBACxB,oBAAoB;gBACpB,IAAK,IAAI,KAAK,GAAG,IAAI,IAAI,IAAK;oBAC5B,IAAI,MAAM,CAAC,EAAE;oBACb,6BAA6B;oBAC7B,IAAI,MAAM,CAAC,CAAC,KAAK,EAAE;oBACnB,IAAI,OAAO,GAAG;wBACZ;oBACF;oBACA,mBAAmB;oBACnB,KAAK;oBACL,4BAA4B;oBAC5B,MAAM,CAAC,KAAK,GAAG;oBACf,0BAA0B;oBAC1B,KAAK;gBACP;gBACA,6BAA6B;gBAC7B,IAAI,MAAM,GAAG;oBACX,kBAAkB;oBAClB,IAAI,CAAC,EAAE,GAAG,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE;oBACjB,MAAM,CAAC,CAAC,CAAC,KAAK,EAAE;oBAChB,cAAc;oBACd,MAAM;oBACN,mBAAmB;oBACnB,OAAO;oBACP,OAAO;oBACP,CAAC,CAAC,KAAK,EAAE,GAAG;oBACZ,iBAAiB;oBACjB,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;gBACjB,OAAO;oBACL,mBAAmB;oBACnB,CAAC,CAAC,SAAS,EAAE,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC,SAAS,EAAE,EAAE;oBACxC,yBAAyB;oBACzB,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG;oBACvB,4BAA4B;oBAC5B,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG;oBACvB,gCAAgC;oBAChC,MAAM,CAAC,GAAG,GAAG;oBACb,iCAAiC;oBACjC,CAAC,CAAC,MAAM,EAAE,GAAG,KAAK,KAAK;oBACvB,qBAAqB;oBACrB,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI;oBACvB,yBAAyB;oBACzB,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,QAAQ,EAAE;oBAC1B,CAAC,CAAC,QAAQ,EAAE,GAAG;oBACf,4BAA4B;oBAC5B,IAAI,CAAC,EAAE,GAAG;gBACZ;YACF;YACA,gBAAgB;YAChB,CAAC,CAAC,SAAS,EAAE,GAAG;YAChB,QAAQ,KAAK,GAAG,CAAC,OAAO;YACxB,UAAU;YACV,OAAO,QAAQ,OAAO,OAAO,OAAO,GAAG,GAAG;YAE1C,sGAAsG;YACtG,sFAAsF;YACtF,IAAK,KAAK,KAAK,KAAK,KAAK,KAAM;gBAC7B,IAAI,MAAM,CAAC,GAAG;gBACd,2BAA2B;gBAC3B,IAAI,CAAC,CAAC,KAAK,EAAE,IAAI,GAAG;oBAClB;gBACF;gBACA,6BAA6B;gBAC7B,IAAI,IAAI,CAAC,EAAE;gBACX,IAAI,CAAC,CAAC,QAAQ,EAAE;gBAChB,4BAA4B;gBAC5B,CAAC,CAAC,QAAQ,EAAE,GAAG,CAAC;gBAChB,MAAO,MAAM,CAAC,KAAK,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE,OAAQ;oBAC9D,KAAK,CAAC,CAAC,MAAM,EAAE;oBACf,MAAM,CAAC,CAAC,OAAO,EAAE;oBACjB,IAAK,IAAI,IAAI,CAAC,EAAE,GAAG,GAAG,KAAK,IAAI,CAAC,EAAE,GAAG,KAAK,GAAG,IAAK;wBAChD,CAAC,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC,GAAG;oBACrB;oBACA,IAAI,QAAQ;oBACZ,uBAAuB;oBACvB,IAAK,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE,MAAM,CAAC,GAAI;wBAC/B,IAAI,KAAK,CAAC,CAAC,MAAM,EAAE,KAAK,MAAM,CAAC,CAAC,OAAO,EAAE,KAAK;wBAC9C,IAAK,IAAI,IAAI,CAAC,EAAE,GAAG,GAAG,MAAM,KAAK,IAAI,CAAC,EAAE,GAAG,KAAK,GAAG,IAAK;4BACtD,kBAAkB;4BAClB,IAAI,CAAC,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC,KAAK,MAAM;gCAC7B,KAAK;4BACP;wBACF;wBACA,8BAA8B;wBAC9B,IAAI,IAAI;4BACN,kBAAkB;4BAClB,IAAI,CAAC,EAAE,GAAG,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE;4BACjB,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,KAAK,EAAE;4BACtB,CAAC,CAAC,KAAK,EAAE,GAAG;4BACZ,iBAAiB;4BACjB,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;4BACf,4BAA4B;4BAC5B,IAAI,CAAC,CAAC,OAAO,EAAE;4BACf,CAAC,CAAC,OAAO,MAAM,GAAG;wBACpB,OAAO;4BACL,wBAAwB;4BACxB,QAAQ;4BACR,IAAI,CAAC,CAAC,OAAO,EAAE;wBACjB;oBACF;gBACF;YACF;YAEA,mHAAmH;YACnH,mFAAmF;YACnF,IAAK,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAM;gBACtC,IAAI,MAAM,CAAC,GAAG;gBACd,4BAA4B;gBAC5B,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,EAAE,KAAK,GAAG;oBAC3B;gBACF;gBACA,oBAAoB;gBACpB,CAAC,CAAC,KAAK,EAAE,GAAG;gBACZ,6BAA6B;gBAC7B,IAAI,CAAC,CAAC,SAAS,EAAE,GAAG,KAAK;gBACzB,IAAI,KAAK,GAAG,CAAC,GAAG,IAAI,MAAM;gBAC1B,IAAI,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,GAAG;oBACtB,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,GAAG;gBACtB;gBACA,4BAA4B;gBAC5B,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,OAAO,EAAE;gBACzB,IAAI,CAAC,EAAE,GAAG,CAAC;gBACX,CAAC,CAAC,OAAO,EAAE,GAAG;gBACd,0BAA0B;gBAC1B,SAAS,KAAK,GAAG,CAAC,QAAQ;gBAC1B,CAAC,CAAC,SAAS,EAAE,GAAG;gBAChB,gBAAgB;gBAChB,MAAM,CAAC,IAAI,GAAG;YAChB;YACA,0BAA0B;YAC1B,CAAC,CAAC,KAAK,EAAE,GAAG;YACZ,kCAAkC;YAClC,IAAI,CAAC,CAAC,CAAC,MAAM,EAAE,GAAG,IAAI,GAAG,MAAM,GAAG;gBAChC,0BAA0B;gBAC1B,IAAI,CAAC,EAAE,GAAG,CAAC;gBACX,0BAA0B;gBAC1B,CAAC,CAAC,IAAI,EAAE,GAAG;YACb;YACA,IAAI,UAAU,GAAG;gBACf,0BAA0B;gBAC1B,MAAM;YACR;QACF;QAEA,oGAAoG;QACpG,oGAAoG;QACpG,8GAA8G;QAC9G,8DAA8D;QAE9D,oBAAoB;QACpB,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;YACtB,IAAI,CAAC,EAAE,GAAG,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,EAAE;QAC1B;QACA,IAAK,IAAI,GAAG,KAAK,GAAG,IAAK;YACvB,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;QACjB;QACA,iCAAiC;QACjC,IAAK,IAAI,GAAG,KAAK,GAAG,IAAK;YACvB,0BAA0B;YAC1B,IAAI,CAAC,CAAC,KAAK,EAAE,GAAG,GAAG;gBACjB;YACF;YACA,gCAAgC;YAChC,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC;YAC/B,CAAC,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG;QACtB;QACA,0BAA0B;QAC1B,IAAK,IAAI,GAAG,KAAK,GAAG,IAAK;YACvB,8BAA8B;YAC9B,IAAI,CAAC,CAAC,KAAK,EAAE,IAAI,GAAG;gBAClB;YACF;YACA,IAAI,IAAI,CAAC,EAAE,KAAK,CAAC,GAAG;gBAClB,gCAAgC;gBAChC,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC;gBAC/B,CAAC,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG;YACtB;QACF;QACA,8BAA8B;QAC9B,IAAK,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,IAAK;YAC9B,IAAI,IAAI,CAAC,EAAE,KAAK,CAAC,GAAG;gBAClB,IAAI,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE,GAAG,GAAG,GAAG,MAAM,MAAM,GAAG;YACrC;QACF;QACA,4BAA4B;QAC5B,EAAE,MAAM,CAAC,EAAE,MAAM,GAAG,GAAG;QACvB,WAAW;QACX,OAAO;IACT;;IAEA;;;;;;;;;;;;;;;;;;GAkBC,GACD,SAAS,oBAAoB,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK;QAChD,aAAa;QACb,IAAI,KAAK,UAAU;QAEnB,yCAAyC;QACzC,IAAI,UAAU,KAAK,MAAM,GAAG;YAC1B,aAAa;YACb,OAAO,IAAI,GAAG;QAChB;QAEA,8CAA8C;QAC9C,IAAI,UAAU,GAAG;YACf,mBAAmB;YACnB,IAAI,SAAS,GAAG,MAAM;YACtB,IAAI,OAAO,GAAG,IAAI;YAClB,mBAAmB;YACnB,IAAI,KAAK;YACT,yBAAyB;YACzB,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;gBAC1B,6BAA6B;gBAC7B,IAAI,IAAI,IAAI,CAAC,EAAE;gBACf,2BAA2B;gBAC3B,IAAI,CAAC,EAAE,GAAG;gBACV,mBAAmB;gBACnB,IAAI,IAAI,CAAC,IAAI,EAAE,GAAG,IAAI,OAAO;oBAC3B;gBACF;gBACA,4BAA4B;gBAC5B,IAAK,IAAI,KAAK,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,IAAI,IAAK;oBACtC,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,EAAE;gBAC1B;YACF;YACA,cAAc;YACd,IAAI,CAAC,EAAE,GAAG;YACV,uCAAuC;YACvC,IAAI,UAAU;YACd,aAAa;YACb,OAAO,SAAS,IAAI;QACtB;QAEA,2CAA2C;QAC3C,OAAO,SAAS,IAAI;IACtB;IAEA;;;;;;;GAOC,GACD,SAAS,yBAAyB,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM;QAC7F,4BAA4B;QAC5B,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YAC1B,CAAC,CAAC,MAAM,EAAE,GAAG,IAAI,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,EAAE;QACpC;QACA,CAAC,CAAC,MAAM,EAAE,GAAG;QACb,uBAAuB;QACvB,IAAK,IAAI,IAAI,GAAG,KAAK,GAAG,IAAK;YAC3B,yBAAyB;YACzB,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;YACf,IAAI,CAAC,EAAE,GAAG,CAAC;YACX,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;YACf,uBAAuB;YACvB,CAAC,CAAC,QAAQ,EAAE,GAAG,CAAC;YAChB,0BAA0B;YAC1B,CAAC,CAAC,KAAK,EAAE,GAAG;YACZ,kBAAkB;YAClB,CAAC,CAAC,IAAI,EAAE,GAAG;YACX,wBAAwB;YACxB,CAAC,CAAC,OAAO,EAAE,GAAG;YACd,mBAAmB;YACnB,CAAC,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC,MAAM,EAAE;QAC5B;QACA,UAAU;QACV,IAAI,OAAO,QAAQ,GAAG,GAAG,GAAG,GAAG;QAC/B,sBAAsB;QACtB,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;QACf,+BAA+B;QAC/B,IAAI,CAAC,EAAE,GAAG,CAAC;QACX,sBAAsB;QACtB,CAAC,CAAC,IAAI,EAAE,GAAG;QACX,cAAc;QACd,OAAO;IACT;IAEA;;;;GAIC,GACD,SAAS,uBAAuB,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI;QACtF,SAAS;QACT,IAAI,MAAM;QACV,eAAe;QACf,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YAC1B,aAAa;YACb,IAAI,IAAI,CAAC,CAAC,SAAS,EAAE;YACrB,wBAAwB;YACxB,IAAI,MAAM,GAAG;gBACX,oBAAoB;gBACpB,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;gBACf;gBACA,+BAA+B;gBAC/B,IAAI,CAAC,EAAE,GAAG,CAAC;gBACX,CAAC,CAAC,IAAI,EAAE,GAAG;YACb,OAAO,IAAI,IAAI,OAAO;gBACpB,0BAA0B;gBAC1B,CAAC,CAAC,KAAK,EAAE,GAAG;gBACZ,iBAAiB;gBACjB,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC;gBACf;gBACA,IAAI,CAAC,EAAE,GAAG,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE;gBACjB,CAAC,CAAC,KAAK,EAAE;YACX,OAAO;gBACL,IAAI,IAAI,CAAC,CAAC,OAAO,EAAE;gBACnB,IAAI,MAAM,CAAC,GAAG;oBACZ,IAAI,CAAC,EAAE,GAAG;gBACZ;gBACA,8BAA8B;gBAC9B,CAAC,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,OAAO,EAAE;gBACzB,CAAC,CAAC,OAAO,EAAE,GAAG;YAChB;QACF;QACA,OAAO;IACT;IACA,SAAS,QAAQ,IAAI,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;QACnC,IAAI,OAAO,KAAK,OAAO,QAAQ,GAAG;YAChC,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;gBAC1B,IAAI,CAAC,CAAC,IAAI,EAAE,KAAK,GAAG;oBAClB,CAAC,CAAC,IAAI,EAAE,GAAG;gBACb;YACF;YACA,OAAO;QACT;QACA,yCAAyC;QACzC,OAAO;IACT;IACA,SAAS,MAAM,CAAC,EAAE,CAAC;QACjB,OAAO,MAAM;IACf;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2430, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\n\n/**\n * This function determines if j is a leaf of the ith row subtree.\n * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)\n *\n * @param {Number}  i               The ith row subtree\n * @param {Number}  j               The node to test\n * @param {Array}   w               The workspace array\n * @param {Number}  first           The index offset within the workspace for the first array\n * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array\n * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array\n * @param {Number}  ancestor        The index offset within the workspace for the ancestor array\n *\n * @return {Object}\n */\nexport function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {\n  var s, sparent;\n\n  // our result\n  var jleaf = 0;\n  var q;\n\n  // check j is a leaf\n  if (i <= j || w[first + j] <= w[maxfirst + i]) {\n    return -1;\n  }\n  // update max first[j] seen so far\n  w[maxfirst + i] = w[first + j];\n  // jprev = previous leaf of ith subtree\n  var jprev = w[prevleaf + i];\n  w[prevleaf + i] = j;\n\n  // check j is first or subsequent leaf\n  if (jprev === -1) {\n    // 1st leaf, q = root of ith subtree\n    jleaf = 1;\n    q = i;\n  } else {\n    // update jleaf\n    jleaf = 2;\n    // q = least common ancester (jprev,j)\n    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]);\n    for (s = jprev; s !== q; s = sparent) {\n      // path compression\n      sparent = w[ancestor + s];\n      w[ancestor + s] = q;\n    }\n  }\n  return {\n    jleaf,\n    q\n  };\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;AAE7E;;;;;;;;;;;;;CAaC;;;AACM,SAAS,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ;IACjE,IAAI,GAAG;IAEP,aAAa;IACb,IAAI,QAAQ;IACZ,IAAI;IAEJ,oBAAoB;IACpB,IAAI,KAAK,KAAK,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,WAAW,EAAE,EAAE;QAC7C,OAAO,CAAC;IACV;IACA,kCAAkC;IAClC,CAAC,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,QAAQ,EAAE;IAC9B,uCAAuC;IACvC,IAAI,QAAQ,CAAC,CAAC,WAAW,EAAE;IAC3B,CAAC,CAAC,WAAW,EAAE,GAAG;IAElB,sCAAsC;IACtC,IAAI,UAAU,CAAC,GAAG;QAChB,oCAAoC;QACpC,QAAQ;QACR,IAAI;IACN,OAAO;QACL,eAAe;QACf,QAAQ;QACR,sCAAsC;QACtC,IAAK,IAAI,OAAO,MAAM,CAAC,CAAC,WAAW,EAAE,EAAE,IAAI,CAAC,CAAC,WAAW,EAAE;QAC1D,IAAK,IAAI,OAAO,MAAM,GAAG,IAAI,QAAS;YACpC,mBAAmB;YACnB,UAAU,CAAC,CAAC,WAAW,EAAE;YACzB,CAAC,CAAC,WAAW,EAAE,GAAG;QACpB;IACF;IACA,OAAO;QACL;QACA;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2490, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\nimport { factory } from '../../../utils/factory.js';\nimport { csLeaf } from './csLeaf.js';\nvar name = 'csCounts';\nvar dependencies = ['transpose'];\nexport var createCsCounts = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    transpose\n  } = _ref;\n  /**\n   * Computes the column counts using the upper triangular part of A.\n   * It transposes A internally, none of the input parameters are modified.\n   *\n   * @param {Matrix} a           The sparse matrix A\n   *\n   * @param {Matrix} ata         Count the columns of A'A instead\n   *\n   * @return                     An array of size n of the column counts or null on error\n   */\n  return function (a, parent, post, ata) {\n    // check inputs\n    if (!a || !parent || !post) {\n      return null;\n    }\n    // a matrix arrays\n    var asize = a._size;\n    // rows and columns\n    var m = asize[0];\n    var n = asize[1];\n    // variables\n    var i, j, k, J, p, p0, p1;\n\n    // workspace size\n    var s = 4 * n + (ata ? n + m + 1 : 0);\n    // allocate workspace\n    var w = []; // (s)\n    var ancestor = 0; // first n entries\n    var maxfirst = n; // next n entries\n    var prevleaf = 2 * n; // next n entries\n    var first = 3 * n; // next n entries\n    var head = 4 * n; // next n + 1 entries (used when ata is true)\n    var next = 5 * n + 1; // last entries in workspace\n    // clear workspace w[0..s-1]\n    for (k = 0; k < s; k++) {\n      w[k] = -1;\n    }\n\n    // allocate result\n    var colcount = []; // (n)\n\n    // AT = A'\n    var at = transpose(a);\n    // at arrays\n    var tindex = at._index;\n    var tptr = at._ptr;\n\n    // find w[first + j]\n    for (k = 0; k < n; k++) {\n      j = post[k];\n      // colcount[j]=1 if j is a leaf\n      colcount[j] = w[first + j] === -1 ? 1 : 0;\n      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {\n        w[first + j] = k;\n      }\n    }\n\n    // initialize ata if needed\n    if (ata) {\n      // invert post\n      for (k = 0; k < n; k++) {\n        w[post[k]] = k;\n      }\n      // loop rows (columns in AT)\n      for (i = 0; i < m; i++) {\n        // values in column i of AT\n        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {\n          k = Math.min(k, w[tindex[p]]);\n        }\n        // place row i in linked list k\n        w[next + i] = w[head + k];\n        w[head + k] = i;\n      }\n    }\n\n    // each node in its own set\n    for (i = 0; i < n; i++) {\n      w[ancestor + i] = i;\n    }\n    for (k = 0; k < n; k++) {\n      // j is the kth node in postordered etree\n      j = post[k];\n      // check j is not a root\n      if (parent[j] !== -1) {\n        colcount[parent[j]]--;\n      }\n\n      // J=j for LL'=A case\n      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {\n        for (p = tptr[J]; p < tptr[J + 1]; p++) {\n          i = tindex[p];\n          var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor);\n          // check A(i,j) is in skeleton\n          if (r.jleaf >= 1) {\n            colcount[j]++;\n          }\n          // check account for overlap in q\n          if (r.jleaf === 2) {\n            colcount[r.q]--;\n          }\n        }\n      }\n      if (parent[j] !== -1) {\n        w[ancestor + j] = parent[j];\n      }\n    }\n    // sum up colcount's of each child\n    for (j = 0; j < n; j++) {\n      if (parent[j] !== -1) {\n        colcount[parent[j]] += colcount[j];\n      }\n    }\n    return colcount;\n  };\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2619, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\nimport { csPermute } from './csPermute.js';\nimport { csPost } from './csPost.js';\nimport { csEtree } from './csEtree.js';\nimport { createCsAmd } from './csAmd.js';\nimport { createCsCounts } from './csCounts.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'csSqr';\nvar dependencies = ['add', 'multiply', 'transpose'];\nexport var createCsSqr = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    add,\n    multiply,\n    transpose\n  } = _ref;\n  var csAmd = createCsAmd({\n    add,\n    multiply,\n    transpose\n  });\n  var csCounts = createCsCounts({\n    transpose\n  });\n\n  /**\n   * Symbolic ordering and analysis for QR and LU decompositions.\n   *\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\n   * @param {Matrix}  a               The A matrix\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\n   *                                  symbolic ordering and analysis for LU decomposition (false)\n   *\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\n   */\n  return function csSqr(order, a, qr) {\n    // a arrays\n    var aptr = a._ptr;\n    var asize = a._size;\n    // columns\n    var n = asize[1];\n    // vars\n    var k;\n    // symbolic analysis result\n    var s = {};\n    // fill-reducing ordering\n    s.q = csAmd(order, a);\n    // validate results\n    if (order && !s.q) {\n      return null;\n    }\n    // QR symbolic analysis\n    if (qr) {\n      // apply permutations if needed\n      var c = order ? csPermute(a, null, s.q, 0) : a;\n      // etree of C'*C, where C=A(:,q)\n      s.parent = csEtree(c, 1);\n      // post order elimination tree\n      var post = csPost(s.parent, n);\n      // col counts chol(C'*C)\n      s.cp = csCounts(c, s.parent, post, 1);\n      // check we have everything needed to calculate number of nonzero elements\n      if (c && s.parent && s.cp && _vcount(c, s)) {\n        // calculate number of nonzero elements\n        for (s.unz = 0, k = 0; k < n; k++) {\n          s.unz += s.cp[k];\n        }\n      }\n    } else {\n      // for LU factorization only, guess nnz(L) and nnz(U)\n      s.unz = 4 * aptr[n] + n;\n      s.lnz = s.unz;\n    }\n    // return result S\n    return s;\n  };\n\n  /**\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\n   */\n  function _vcount(a, s) {\n    // a arrays\n    var aptr = a._ptr;\n    var aindex = a._index;\n    var asize = a._size;\n    // rows & columns\n    var m = asize[0];\n    var n = asize[1];\n    // initialize s arrays\n    s.pinv = []; // (m + n)\n    s.leftmost = []; // (m)\n    // vars\n    var parent = s.parent;\n    var pinv = s.pinv;\n    var leftmost = s.leftmost;\n    // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\n    var w = []; // (m + 3 * n)\n    var next = 0;\n    var head = m;\n    var tail = m + n;\n    var nque = m + 2 * n;\n    // vars\n    var i, k, p, p0, p1;\n    // initialize w\n    for (k = 0; k < n; k++) {\n      // queue k is empty\n      w[head + k] = -1;\n      w[tail + k] = -1;\n      w[nque + k] = 0;\n    }\n    // initialize row arrays\n    for (i = 0; i < m; i++) {\n      leftmost[i] = -1;\n    }\n    // loop columns backwards\n    for (k = n - 1; k >= 0; k--) {\n      // values & index for column k\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n        // leftmost[i] = min(find(A(i,:)))\n        leftmost[aindex[p]] = k;\n      }\n    }\n    // scan rows in reverse order\n    for (i = m - 1; i >= 0; i--) {\n      // row i is not yet ordered\n      pinv[i] = -1;\n      k = leftmost[i];\n      // check row i is empty\n      if (k === -1) {\n        continue;\n      }\n      // first row in queue k\n      if (w[nque + k]++ === 0) {\n        w[tail + k] = i;\n      }\n      // put i at head of queue k\n      w[next + i] = w[head + k];\n      w[head + k] = i;\n    }\n    s.lnz = 0;\n    s.m2 = m;\n    // find row permutation and nnz(V)\n    for (k = 0; k < n; k++) {\n      // remove row i from queue k\n      i = w[head + k];\n      // count V(k,k) as nonzero\n      s.lnz++;\n      // add a fictitious row\n      if (i < 0) {\n        i = s.m2++;\n      }\n      // associate row i with V(:,k)\n      pinv[i] = k;\n      // skip if V(k+1:m,k) is empty\n      if (--nque[k] <= 0) {\n        continue;\n      }\n      // nque[k] is nnz (V(k+1:m,k))\n      s.lnz += w[nque + k];\n      // move all rows to parent of k\n      var pa = parent[k];\n      if (pa !== -1) {\n        if (w[nque + pa] === 0) {\n          w[tail + pa] = w[tail + k];\n        }\n        w[next + w[tail + k]] = w[head + pa];\n        w[head + pa] = w[next + i];\n        w[nque + pa] += w[nque + k];\n      }\n    }\n    for (i = 0; i < m; i++) {\n      if (pinv[i] < 0) {\n        pinv[i] = k++;\n      }\n    }\n    return true;\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2810, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\n\n/**\n * Checks if the node at w[j] is marked\n *\n * @param {Array}   w               The array\n * @param {Number}  j               The array index\n */\nexport function csMarked(w, j) {\n  // check node is marked\n  return w[j] < 0;\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;AAE7E;;;;;CAKC;;;AACM,SAAS,SAAS,CAAC,EAAE,CAAC;IAC3B,uBAAuB;IACvB,OAAO,CAAC,CAAC,EAAE,GAAG;AAChB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2831, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\n\nimport { csFlip } from './csFlip.js';\n\n/**\n * Marks the node at w[j]\n *\n * @param {Array}   w               The array\n * @param {Number}  j               The array index\n */\nexport function csMark(w, j) {\n  // mark w[j]\n  w[j] = csFlip(w[j]);\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;;;;AAE7E;;AAQO,SAAS,OAAO,CAAC,EAAE,CAAC;IACzB,YAAY;IACZ,CAAC,CAAC,EAAE,GAAG,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE,CAAC,CAAC,EAAE;AACpB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2849, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\nimport { csFlip } from './csFlip.js';\n\n/**\n * Flips the value if it is negative of returns the same value otherwise.\n *\n * @param {Number}  i               The value to flip\n */\nexport function csUnflip(i) {\n  // flip the value if it is negative\n  return i < 0 ? csFlip(i) : i;\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;;;;AAC7E;;AAOO,SAAS,SAAS,CAAC;IACxB,mCAAmC;IACnC,OAAO,IAAI,IAAI,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE,KAAK;AAC7B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2867, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\nimport { csMarked } from './csMarked.js';\nimport { csMark } from './csMark.js';\nimport { csUnflip } from './csUnflip.js';\n\n/**\n * Depth-first search computes the nonzero pattern xi of the directed graph G (Matrix) starting\n * at nodes in B (see csReach()).\n *\n * @param {Number}  j               The starting node for the DFS algorithm\n * @param {Matrix}  g               The G matrix to search, ptr array modified, then restored\n * @param {Number}  top             Start index in stack xi[top..n-1]\n * @param {Number}  k               The kth column in B\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n *\n * @return {Number}                 New value of top\n */\nexport function csDfs(j, g, top, xi, pinv) {\n  // g arrays\n  var index = g._index;\n  var ptr = g._ptr;\n  var size = g._size;\n  // columns\n  var n = size[1];\n  // vars\n  var i, p, p2;\n  // initialize head\n  var head = 0;\n  // initialize the recursion stack\n  xi[0] = j;\n  // loop\n  while (head >= 0) {\n    // get j from the top of the recursion stack\n    j = xi[head];\n    // apply permutation vector\n    var jnew = pinv ? pinv[j] : j;\n    // check node j is marked\n    if (!csMarked(ptr, j)) {\n      // mark node j as visited\n      csMark(ptr, j);\n      // update stack (last n entries in xi)\n      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);\n    }\n    // node j done if no unvisited neighbors\n    var done = 1;\n    // examine all neighbors of j, stack (last n entries in xi)\n    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {\n      // consider neighbor node i\n      i = index[p];\n      // check we have visited node i, skip it\n      if (csMarked(ptr, i)) {\n        continue;\n      }\n      // pause depth-first search of node j, update stack (last n entries in xi)\n      xi[n + head] = p;\n      // start dfs at node i\n      xi[++head] = i;\n      // node j is not done\n      done = 0;\n      // break, to start dfs(i)\n      break;\n    }\n    // check depth-first search at node j is done\n    if (done) {\n      // remove j from the recursion stack\n      head--;\n      // and place in the output stack\n      xi[--top] = j;\n    }\n  }\n  return top;\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;;;;AAC7E;AACA;AACA;;;;AAgBO,SAAS,MAAM,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI;IACvC,WAAW;IACX,IAAI,QAAQ,EAAE,MAAM;IACpB,IAAI,MAAM,EAAE,IAAI;IAChB,IAAI,OAAO,EAAE,KAAK;IAClB,UAAU;IACV,IAAI,IAAI,IAAI,CAAC,EAAE;IACf,OAAO;IACP,IAAI,GAAG,GAAG;IACV,kBAAkB;IAClB,IAAI,OAAO;IACX,iCAAiC;IACjC,EAAE,CAAC,EAAE,GAAG;IACR,OAAO;IACP,MAAO,QAAQ,EAAG;QAChB,4CAA4C;QAC5C,IAAI,EAAE,CAAC,KAAK;QACZ,2BAA2B;QAC3B,IAAI,OAAO,OAAO,IAAI,CAAC,EAAE,GAAG;QAC5B,yBAAyB;QACzB,IAAI,CAAC,CAAA,GAAA,oLAAA,CAAA,WAAQ,AAAD,EAAE,KAAK,IAAI;YACrB,yBAAyB;YACzB,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE,KAAK;YACZ,sCAAsC;YACtC,EAAE,CAAC,IAAI,KAAK,GAAG,OAAO,IAAI,IAAI,CAAA,GAAA,oLAAA,CAAA,WAAQ,AAAD,EAAE,GAAG,CAAC,KAAK;QAClD;QACA,wCAAwC;QACxC,IAAI,OAAO;QACX,2DAA2D;QAC3D,IAAK,IAAI,EAAE,CAAC,IAAI,KAAK,EAAE,KAAK,OAAO,IAAI,IAAI,CAAA,GAAA,oLAAA,CAAA,WAAQ,AAAD,EAAE,GAAG,CAAC,OAAO,EAAE,GAAG,IAAI,IAAI,IAAK;YAC/E,2BAA2B;YAC3B,IAAI,KAAK,CAAC,EAAE;YACZ,wCAAwC;YACxC,IAAI,CAAA,GAAA,oLAAA,CAAA,WAAQ,AAAD,EAAE,KAAK,IAAI;gBACpB;YACF;YACA,0EAA0E;YAC1E,EAAE,CAAC,IAAI,KAAK,GAAG;YACf,sBAAsB;YACtB,EAAE,CAAC,EAAE,KAAK,GAAG;YACb,qBAAqB;YACrB,OAAO;YAEP;QACF;QACA,6CAA6C;QAC7C,IAAI,MAAM;YACR,oCAAoC;YACpC;YACA,gCAAgC;YAChC,EAAE,CAAC,EAAE,IAAI,GAAG;QACd;IACF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2939, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\n\nimport { csMarked } from './csMarked.js';\nimport { csMark } from './csMark.js';\nimport { csDfs } from './csDfs.js';\n\n/**\n * The csReach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1\n * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The\n * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).\n *\n * @param {Matrix}  g               The G matrix\n * @param {Matrix}  b               The B matrix\n * @param {Number}  k               The kth column in B\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n * @param {Array}   pinv            The inverse row permutation vector\n *\n * @return {Number}                 The index for the nonzero pattern\n */\nexport function csReach(g, b, k, xi, pinv) {\n  // g arrays\n  var gptr = g._ptr;\n  var gsize = g._size;\n  // b arrays\n  var bindex = b._index;\n  var bptr = b._ptr;\n  // columns\n  var n = gsize[1];\n  // vars\n  var p, p0, p1;\n  // initialize top\n  var top = n;\n  // loop column indeces in B\n  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n    // node i\n    var i = bindex[p];\n    // check node i is marked\n    if (!csMarked(gptr, i)) {\n      // start a dfs at unmarked node i\n      top = csDfs(i, g, top, xi, pinv);\n    }\n  }\n  // loop columns from top -> n - 1\n  for (p = top; p < n; p++) {\n    // restore G\n    csMark(gptr, xi[p]);\n  }\n  return top;\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;;;;AAE7E;AACA;AACA;;;;AAgBO,SAAS,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI;IACvC,WAAW;IACX,IAAI,OAAO,EAAE,IAAI;IACjB,IAAI,QAAQ,EAAE,KAAK;IACnB,WAAW;IACX,IAAI,SAAS,EAAE,MAAM;IACrB,IAAI,OAAO,EAAE,IAAI;IACjB,UAAU;IACV,IAAI,IAAI,KAAK,CAAC,EAAE;IAChB,OAAO;IACP,IAAI,GAAG,IAAI;IACX,iBAAiB;IACjB,IAAI,MAAM;IACV,2BAA2B;IAC3B,IAAK,KAAK,IAAI,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,IAAI,IAAI,IAAI,IAAK;QACxD,SAAS;QACT,IAAI,IAAI,MAAM,CAAC,EAAE;QACjB,yBAAyB;QACzB,IAAI,CAAC,CAAA,GAAA,oLAAA,CAAA,WAAQ,AAAD,EAAE,MAAM,IAAI;YACtB,iCAAiC;YACjC,MAAM,CAAA,GAAA,iLAAA,CAAA,QAAK,AAAD,EAAE,GAAG,GAAG,KAAK,IAAI;QAC7B;IACF;IACA,iCAAiC;IACjC,IAAK,IAAI,KAAK,IAAI,GAAG,IAAK;QACxB,YAAY;QACZ,CAAA,GAAA,kLAAA,CAAA,SAAM,AAAD,EAAE,MAAM,EAAE,CAAC,EAAE;IACpB;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2987, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\nimport { csReach } from './csReach.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'csSpsolve';\nvar dependencies = ['divideScalar', 'multiply', 'subtract'];\nexport var createCsSpsolve = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    divideScalar,\n    multiply,\n    subtract\n  } = _ref;\n  /**\n   * The function csSpsolve() computes the solution to G * x = bk, where bk is the\n   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the\n   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U\n   * is upper triangular with the diagonal entry as the last entry in each column.\n   *\n   * @param {Matrix}  g               The G matrix\n   * @param {Matrix}  b               The B matrix\n   * @param {Number}  k               The kth column in B\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\n   * @param {Array}   x               The soluton to the linear system G * x = b\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\n   * @param {boolean} lo              The lower (true) upper triangular (false) flag\n   *\n   * @return {Number}                 The index for the nonzero pattern\n   */\n  return function csSpsolve(g, b, k, xi, x, pinv, lo) {\n    // g arrays\n    var gvalues = g._values;\n    var gindex = g._index;\n    var gptr = g._ptr;\n    var gsize = g._size;\n    // columns\n    var n = gsize[1];\n    // b arrays\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    // vars\n    var p, p0, p1, q;\n    // xi[top..n-1] = csReach(B(:,k))\n    var top = csReach(g, b, k, xi, pinv);\n    // clear x\n    for (p = top; p < n; p++) {\n      x[xi[p]] = 0;\n    }\n    // scatter b\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n      x[bindex[p]] = bvalues[p];\n    }\n    // loop columns\n    for (var px = top; px < n; px++) {\n      // x array index for px\n      var j = xi[px];\n      // apply permutation vector (U x = b), j maps to column J of G\n      var J = pinv ? pinv[j] : j;\n      // check column J is empty\n      if (J < 0) {\n        continue;\n      }\n      // column value indeces in G, p0 <= p < p1\n      p0 = gptr[J];\n      p1 = gptr[J + 1];\n      // x(j) /= G(j,j)\n      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]);\n      // first entry L(j,j)\n      p = lo ? p0 + 1 : p0;\n      q = lo ? p1 : p1 - 1;\n      // loop\n      for (; p < q; p++) {\n        // row\n        var i = gindex[p];\n        // x(i) -= G(i,j) * x(j)\n        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));\n      }\n    }\n    // return top of stack\n    return top;\n  };\n});"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;;;;AAC7E;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAgB;IAAY;CAAW;AACpD,IAAI,kBAAkB,aAAa,GAAE,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACtE,IAAI,EACF,YAAY,EACZ,QAAQ,EACR,QAAQ,EACT,GAAG;IACJ;;;;;;;;;;;;;;;;GAgBC,GACD,OAAO,SAAS,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE;QAChD,WAAW;QACX,IAAI,UAAU,EAAE,OAAO;QACvB,IAAI,SAAS,EAAE,MAAM;QACrB,IAAI,OAAO,EAAE,IAAI;QACjB,IAAI,QAAQ,EAAE,KAAK;QACnB,UAAU;QACV,IAAI,IAAI,KAAK,CAAC,EAAE;QAChB,WAAW;QACX,IAAI,UAAU,EAAE,OAAO;QACvB,IAAI,SAAS,EAAE,MAAM;QACrB,IAAI,OAAO,EAAE,IAAI;QACjB,OAAO;QACP,IAAI,GAAG,IAAI,IAAI;QACf,iCAAiC;QACjC,IAAI,MAAM,CAAA,GAAA,mLAAA,CAAA,UAAO,AAAD,EAAE,GAAG,GAAG,GAAG,IAAI;QAC/B,UAAU;QACV,IAAK,IAAI,KAAK,IAAI,GAAG,IAAK;YACxB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG;QACb;QACA,YAAY;QACZ,IAAK,KAAK,IAAI,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,IAAI,IAAI,IAAI,IAAK;YACxD,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE;QAC3B;QACA,eAAe;QACf,IAAK,IAAI,KAAK,KAAK,KAAK,GAAG,KAAM;YAC/B,uBAAuB;YACvB,IAAI,IAAI,EAAE,CAAC,GAAG;YACd,8DAA8D;YAC9D,IAAI,IAAI,OAAO,IAAI,CAAC,EAAE,GAAG;YACzB,0BAA0B;YAC1B,IAAI,IAAI,GAAG;gBACT;YACF;YACA,0CAA0C;YAC1C,KAAK,IAAI,CAAC,EAAE;YACZ,KAAK,IAAI,CAAC,IAAI,EAAE;YAChB,iBAAiB;YACjB,CAAC,CAAC,EAAE,GAAG,aAAa,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,KAAK,KAAK,KAAK,EAAE;YACnD,qBAAqB;YACrB,IAAI,KAAK,KAAK,IAAI;YAClB,IAAI,KAAK,KAAK,KAAK;YACnB,OAAO;YACP,MAAO,IAAI,GAAG,IAAK;gBACjB,MAAM;gBACN,IAAI,IAAI,MAAM,CAAC,EAAE;gBACjB,wBAAwB;gBACxB,CAAC,CAAC,EAAE,GAAG,SAAS,CAAC,CAAC,EAAE,EAAE,SAAS,OAAO,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;YACjD;QACF;QACA,sBAAsB;QACtB,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3081, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\n\nimport { factory } from '../../../utils/factory.js';\nimport { createCsSpsolve } from './csSpsolve.js';\nvar name = 'csLu';\nvar dependencies = ['abs', 'divideScalar', 'multiply', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nexport var createCsLu = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    abs,\n    divideScalar,\n    multiply,\n    subtract,\n    larger,\n    largerEq,\n    SparseMatrix\n  } = _ref;\n  var csSpsolve = createCsSpsolve({\n    divideScalar,\n    multiply,\n    subtract\n  });\n\n  /**\n   * Computes the numeric LU factorization of the sparse matrix A. Implements a Left-looking LU factorization\n   * algorithm that computes L and U one column at a tume. At the kth step, it access columns 1 to k-1 of L\n   * and column k of A. Given the fill-reducing column ordering q (see parameter s) computes L, U and pinv so\n   * L * U = A(p, q), where p is the inverse of pinv.\n   *\n   * @param {Matrix}  m               The A Matrix to factorize\n   * @param {Object}  s               The symbolic analysis from csSqr(). Provides the fill-reducing\n   *                                  column ordering q\n   * @param {Number}  tol             Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Number}                 The numeric LU factorization of A or null\n   */\n  return function csLu(m, s, tol) {\n    // validate input\n    if (!m) {\n      return null;\n    }\n    // m arrays\n    var size = m._size;\n    // columns\n    var n = size[1];\n    // symbolic analysis result\n    var q;\n    var lnz = 100;\n    var unz = 100;\n    // update symbolic analysis parameters\n    if (s) {\n      q = s.q;\n      lnz = s.lnz || lnz;\n      unz = s.unz || unz;\n    }\n    // L arrays\n    var lvalues = []; // (lnz)\n    var lindex = []; // (lnz)\n    var lptr = []; // (n + 1)\n    // L\n    var L = new SparseMatrix({\n      values: lvalues,\n      index: lindex,\n      ptr: lptr,\n      size: [n, n]\n    });\n    // U arrays\n    var uvalues = []; // (unz)\n    var uindex = []; // (unz)\n    var uptr = []; // (n + 1)\n    // U\n    var U = new SparseMatrix({\n      values: uvalues,\n      index: uindex,\n      ptr: uptr,\n      size: [n, n]\n    });\n    // inverse of permutation vector\n    var pinv = []; // (n)\n    // vars\n    var i, p;\n    // allocate arrays\n    var x = []; // (n)\n    var xi = []; // (2 * n)\n    // initialize variables\n    for (i = 0; i < n; i++) {\n      // clear workspace\n      x[i] = 0;\n      // no rows pivotal yet\n      pinv[i] = -1;\n      // no cols of L yet\n      lptr[i + 1] = 0;\n    }\n    // reset number of nonzero elements in L and U\n    lnz = 0;\n    unz = 0;\n    // compute L(:,k) and U(:,k)\n    for (var k = 0; k < n; k++) {\n      // update ptr\n      lptr[k] = lnz;\n      uptr[k] = unz;\n      // apply column permutations if needed\n      var col = q ? q[k] : k;\n      // solve triangular system, x = L\\A(:,col)\n      var top = csSpsolve(L, m, col, xi, x, pinv, 1);\n      // find pivot\n      var ipiv = -1;\n      var a = -1;\n      // loop xi[] from top -> n\n      for (p = top; p < n; p++) {\n        // x[i] is nonzero\n        i = xi[p];\n        // check row i is not yet pivotal\n        if (pinv[i] < 0) {\n          // absolute value of x[i]\n          var xabs = abs(x[i]);\n          // check absoulte value is greater than pivot value\n          if (larger(xabs, a)) {\n            // largest pivot candidate so far\n            a = xabs;\n            ipiv = i;\n          }\n        } else {\n          // x(i) is the entry U(pinv[i],k)\n          uindex[unz] = pinv[i];\n          uvalues[unz++] = x[i];\n        }\n      }\n      // validate we found a valid pivot\n      if (ipiv === -1 || a <= 0) {\n        return null;\n      }\n      // update actual pivot column, give preference to diagonal value\n      if (pinv[col] < 0 && largerEq(abs(x[col]), multiply(a, tol))) {\n        ipiv = col;\n      }\n      // the chosen pivot\n      var pivot = x[ipiv];\n      // last entry in U(:,k) is U(k,k)\n      uindex[unz] = k;\n      uvalues[unz++] = pivot;\n      // ipiv is the kth pivot row\n      pinv[ipiv] = k;\n      // first entry in L(:,k) is L(k,k) = 1\n      lindex[lnz] = ipiv;\n      lvalues[lnz++] = 1;\n      // L(k+1:n,k) = x / pivot\n      for (p = top; p < n; p++) {\n        // row\n        i = xi[p];\n        // check x(i) is an entry in L(:,k)\n        if (pinv[i] < 0) {\n          // save unpermuted row in L\n          lindex[lnz] = i;\n          // scale pivot column\n          lvalues[lnz++] = divideScalar(x[i], pivot);\n        }\n        // x[0..n-1] = 0 for next k\n        x[i] = 0;\n      }\n    }\n    // update ptr\n    lptr[n] = lnz;\n    uptr[n] = unz;\n    // fix row indices of L for final pinv\n    for (p = 0; p < lnz; p++) {\n      lindex[p] = pinv[lindex[p]];\n    }\n    // trim arrays\n    lvalues.splice(lnz, lvalues.length - lnz);\n    lindex.splice(lnz, lindex.length - lnz);\n    uvalues.splice(unz, uvalues.length - unz);\n    uindex.splice(unz, uindex.length - unz);\n    // return LU factor\n    return {\n      L,\n      U,\n      pinv\n    };\n  };\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3277, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js"],"sourcesContent":["import { isInteger } from '../../../utils/number.js';\nimport { factory } from '../../../utils/factory.js';\nimport { createCsSqr } from '../sparse/csSqr.js';\nimport { createCsLu } from '../sparse/csLu.js';\nvar name = 'slu';\nvar dependencies = ['typed', 'abs', 'add', 'multiply', 'transpose', 'divideScalar', 'subtract', 'larger', 'largerEq', 'SparseMatrix'];\nexport var createSlu = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    abs,\n    add,\n    multiply,\n    transpose,\n    divideScalar,\n    subtract,\n    larger,\n    largerEq,\n    SparseMatrix\n  } = _ref;\n  var csSqr = createCsSqr({\n    add,\n    multiply,\n    transpose\n  });\n  var csLu = createCsLu({\n    abs,\n    divideScalar,\n    multiply,\n    subtract,\n    larger,\n    largerEq,\n    SparseMatrix\n  });\n\n  /**\n   * Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix `A` is decomposed in two matrices (`L`, `U`) and two permutation vectors (`pinv`, `q`) where\n   *\n   * `P * A * Q = L * U`\n   *\n   * Syntax:\n   *\n   *    math.slu(A, order, threshold)\n   *\n   * Examples:\n   *\n   *    const A = math.sparse([[4,3], [6, 3]])\n   *    math.slu(A, 1, 0.001)\n   *    // returns:\n   *    // {\n   *    //   L: [[1, 0], [1.5, 1]]\n   *    //   U: [[4, 3], [0, -1.5]]\n   *    //   p: [0, 1]\n   *    //   q: [0, 1]\n   *    // }\n   *\n   * See also:\n   *\n   *    lup, lsolve, usolve, lusolve\n   *\n   * @param {SparseMatrix} A              A two dimensional sparse matrix for which to get the LU decomposition.\n   * @param {Number}       order          The Symbolic Ordering and Analysis order:\n   *                                       0 - Natural ordering, no permutation vector q is returned\n   *                                       1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A'\n   *                                       2 - Symbolic ordering and analisis is performed on M = A' * A. Dense columns from A' are dropped, A recreated from A'.\n   *                                           This is appropriatefor LU factorization of unsymmetric matrices.\n   *                                       3 - Symbolic ordering and analisis is performed on M = A' * A. This is best used for LU factorization is matrix M has no dense rows.\n   *                                           A dense row is a row with more than 10*sqr(columns) entries.\n   * @param {Number}       threshold       Partial pivoting threshold (1 for partial pivoting)\n   *\n   * @return {Object} The lower triangular matrix, the upper triangular matrix and the permutation vectors.\n   */\n  return typed(name, {\n    'SparseMatrix, number, number': function SparseMatrix_number_number(a, order, threshold) {\n      // verify order\n      if (!isInteger(order) || order < 0 || order > 3) {\n        throw new Error('Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]');\n      }\n      // verify threshold\n      if (threshold < 0 || threshold > 1) {\n        throw new Error('Partial pivoting threshold must be a number from 0 to 1');\n      }\n\n      // perform symbolic ordering and analysis\n      var s = csSqr(order, a, false);\n\n      // perform lu decomposition\n      var f = csLu(a, s, threshold);\n\n      // return decomposition\n      return {\n        L: f.L,\n        U: f.U,\n        p: f.pinv,\n        q: s.q,\n        toString: function toString() {\n          return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\np: ' + this.p.toString() + (this.q ? '\\nq: ' + this.q.toString() : '') + '\\n';\n        }\n      };\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAO;IAAO;IAAY;IAAa;IAAgB;IAAY;IAAU;IAAY;CAAe;AAC9H,IAAI,YAAY,aAAa,GAAE,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAChE,IAAI,EACF,KAAK,EACL,GAAG,EACH,GAAG,EACH,QAAQ,EACR,SAAS,EACT,YAAY,EACZ,QAAQ,EACR,MAAM,EACN,QAAQ,EACR,YAAY,EACb,GAAG;IACJ,IAAI,QAAQ,CAAA,GAAA,iLAAA,CAAA,cAAW,AAAD,EAAE;QACtB;QACA;QACA;IACF;IACA,IAAI,OAAO,CAAA,GAAA,gLAAA,CAAA,aAAU,AAAD,EAAE;QACpB;QACA;QACA;QACA;QACA;QACA;QACA;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoCC,GACD,OAAO,MAAM,MAAM;QACjB,gCAAgC,SAAS,2BAA2B,CAAC,EAAE,KAAK,EAAE,SAAS;YACrF,eAAe;YACf,IAAI,CAAC,CAAA,GAAA,0JAAA,CAAA,YAAS,AAAD,EAAE,UAAU,QAAQ,KAAK,QAAQ,GAAG;gBAC/C,MAAM,IAAI,MAAM;YAClB;YACA,mBAAmB;YACnB,IAAI,YAAY,KAAK,YAAY,GAAG;gBAClC,MAAM,IAAI,MAAM;YAClB;YAEA,yCAAyC;YACzC,IAAI,IAAI,MAAM,OAAO,GAAG;YAExB,2BAA2B;YAC3B,IAAI,IAAI,KAAK,GAAG,GAAG;YAEnB,uBAAuB;YACvB,OAAO;gBACL,GAAG,EAAE,CAAC;gBACN,GAAG,EAAE,CAAC;gBACN,GAAG,EAAE,IAAI;gBACT,GAAG,EAAE,CAAC;gBACN,UAAU,SAAS;oBACjB,OAAO,QAAQ,IAAI,CAAC,CAAC,CAAC,QAAQ,KAAK,UAAU,IAAI,CAAC,CAAC,CAAC,QAAQ,KAAK,UAAU,IAAI,CAAC,CAAC,CAAC,QAAQ,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,UAAU,IAAI,CAAC,CAAC,CAAC,QAAQ,KAAK,EAAE,IAAI;gBAC/I;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3386, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js"],"sourcesContent":["// Copyright (c) 2006-2024, Timothy A. Davis, All Rights Reserved.\n// SPDX-License-Identifier: LGPL-2.1+\n// https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/dev/CSparse/Source\n\n/**\n * Permutes a vector; x = P'b. In MATLAB notation, x(p)=b.\n *\n * @param {Array} p           The permutation vector of length n. null value denotes identity\n * @param {Array} b           The input vector\n *\n * @return {Array}            The output vector x = P'b\n */\nexport function csIpvec(p, b) {\n  // vars\n  var k;\n  var n = b.length;\n  var x = [];\n  // check permutation vector was provided, p = null denotes identity\n  if (p) {\n    // loop vector\n    for (k = 0; k < n; k++) {\n      // apply permutation\n      x[p[k]] = b[k];\n    }\n  } else {\n    // loop vector\n    for (k = 0; k < n; k++) {\n      // x[i] = b[i]\n      x[k] = b[k];\n    }\n  }\n  return x;\n}"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,qCAAqC;AACrC,6EAA6E;AAE7E;;;;;;;CAOC;;;AACM,SAAS,QAAQ,CAAC,EAAE,CAAC;IAC1B,OAAO;IACP,IAAI;IACJ,IAAI,IAAI,EAAE,MAAM;IAChB,IAAI,IAAI,EAAE;IACV,mEAAmE;IACnE,IAAI,GAAG;QACL,cAAc;QACd,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;YACtB,oBAAoB;YACpB,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;QAChB;IACF,OAAO;QACL,cAAc;QACd,IAAK,IAAI,GAAG,IAAI,GAAG,IAAK;YACtB,cAAc;YACd,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;QACb;IACF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3426, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js"],"sourcesContent":["import { isArray, isMatrix } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nimport { csIpvec } from '../sparse/csIpvec.js';\nvar name = 'lusolve';\nvar dependencies = ['typed', 'matrix', 'lup', 'slu', 'usolve', 'lsolve', 'DenseMatrix'];\nexport var createLusolve = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    lup,\n    slu,\n    usolve,\n    lsolve,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n\n  /**\n   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.\n   *\n   * Syntax:\n   *\n   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b\n   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)\n   *\n   * Examples:\n   *\n   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]\n   *\n   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]\n   *\n   *    const f = math.lup(m)\n   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]\n   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = math.lusolve(a, b)  // [[2], [5]]\n   *\n   * See also:\n   *\n   *    lup, slu, lsolve, usolve\n   *\n   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition\n   * @param {Matrix | Array} b               Column Vector\n   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix\n   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.\n   *\n   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b\n   */\n  return typed(name, {\n    'Array, Array | Matrix': function Array_Array__Matrix(a, b) {\n      a = matrix(a);\n      var d = lup(a);\n      var x = _lusolve(d.L, d.U, d.p, null, b);\n      return x.valueOf();\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(a, b) {\n      var d = lup(a);\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(a, b) {\n      var d = lup(a);\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix, number, number': function SparseMatrix_Array__Matrix_number_number(a, b, order, threshold) {\n      var d = slu(a, order, threshold);\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    },\n    'Object, Array | Matrix': function Object_Array__Matrix(d, b) {\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    }\n  });\n  function _toMatrix(a) {\n    if (isMatrix(a)) {\n      return a;\n    }\n    if (isArray(a)) {\n      return matrix(a);\n    }\n    throw new TypeError('Invalid Matrix LU decomposition');\n  }\n  function _lusolve(l, u, p, q, b) {\n    // verify decomposition\n    l = _toMatrix(l);\n    u = _toMatrix(u);\n\n    // apply row permutations if needed (b is a DenseMatrix)\n    if (p) {\n      b = solveValidation(l, b, true);\n      b._data = csIpvec(p, b._data);\n    }\n\n    // use forward substitution to resolve L * y = b\n    var y = lsolve(l, b);\n    // use backward substitution to resolve U * x = y\n    var x = usolve(u, y);\n\n    // apply column permutations if needed (x is a DenseMatrix)\n    if (q) {\n      x._data = csIpvec(q, x._data);\n    }\n    return x;\n  }\n});"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAO;IAAO;IAAU;IAAU;CAAc;AAChF,IAAI,gBAAgB,aAAa,GAAE,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACpE,IAAI,EACF,KAAK,EACL,MAAM,EACN,GAAG,EACH,GAAG,EACH,MAAM,EACN,MAAM,EACN,WAAW,EACZ,GAAG;IACJ,IAAI,kBAAkB,CAAA,GAAA,oMAAA,CAAA,wBAAqB,AAAD,EAAE;QAC1C;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCC,GACD,OAAO,MAAM,MAAM;QACjB,yBAAyB,SAAS,oBAAoB,CAAC,EAAE,CAAC;YACxD,IAAI,OAAO;YACX,IAAI,IAAI,IAAI;YACZ,IAAI,IAAI,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,MAAM;YACtC,OAAO,EAAE,OAAO;QAClB;QACA,+BAA+B,SAAS,0BAA0B,CAAC,EAAE,CAAC;YACpE,IAAI,IAAI,IAAI;YACZ,OAAO,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,MAAM;QACvC;QACA,gCAAgC,SAAS,2BAA2B,CAAC,EAAE,CAAC;YACtE,IAAI,IAAI,IAAI;YACZ,OAAO,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,MAAM;QACvC;QACA,gDAAgD,SAAS,yCAAyC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,SAAS;YACtH,IAAI,IAAI,IAAI,GAAG,OAAO;YACtB,OAAO,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE;QACtC;QACA,0BAA0B,SAAS,qBAAqB,CAAC,EAAE,CAAC;YAC1D,OAAO,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE;QACtC;IACF;;IACA,SAAS,UAAU,CAAC;QAClB,IAAI,CAAA,GAAA,sJAAA,CAAA,WAAQ,AAAD,EAAE,IAAI;YACf,OAAO;QACT;QACA,IAAI,CAAA,GAAA,sJAAA,CAAA,UAAO,AAAD,EAAE,IAAI;YACd,OAAO,OAAO;QAChB;QACA,MAAM,IAAI,UAAU;IACtB;IACA,SAAS,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;QAC7B,uBAAuB;QACvB,IAAI,UAAU;QACd,IAAI,UAAU;QAEd,wDAAwD;QACxD,IAAI,GAAG;YACL,IAAI,gBAAgB,GAAG,GAAG;YAC1B,EAAE,KAAK,GAAG,CAAA,GAAA,mLAAA,CAAA,UAAO,AAAD,EAAE,GAAG,EAAE,KAAK;QAC9B;QAEA,gDAAgD;QAChD,IAAI,IAAI,OAAO,GAAG;QAClB,iDAAiD;QACjD,IAAI,IAAI,OAAO,GAAG;QAElB,2DAA2D;QAC3D,IAAI,GAAG;YACL,EAAE,KAAK,GAAG,CAAA,GAAA,mLAAA,CAAA,UAAO,AAAD,EAAE,GAAG,EAAE,KAAK;QAC9B;QACA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3543, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'polynomialRoot';\nvar dependencies = ['typed', 'isZero', 'equalScalar', 'add', 'subtract', 'multiply', 'divide', 'sqrt', 'unaryMinus', 'cbrt', 'typeOf', 'im', 're'];\nexport var createPolynomialRoot = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    isZero,\n    equalScalar,\n    add,\n    subtract,\n    multiply,\n    divide,\n    sqrt,\n    unaryMinus,\n    cbrt,\n    typeOf,\n    im,\n    re\n  } = _ref;\n  /**\n   * Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.\n   * Currently operates only on linear, quadratic, and cubic polynomials using the standard\n   * formulas for the roots.\n   *\n   * Syntax:\n   *\n   *     math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)\n   *\n   * Examples:\n   *     // linear\n   *     math.polynomialRoot(6, 3)                                        // [-2]\n   *     math.polynomialRoot(math.complex(6,3), 3)                        // [-2 - i]\n   *     math.polynomialRoot(math.complex(6,3), math.complex(2,1))        // [-3 + 0i]\n   *     // quadratic\n   *     math.polynomialRoot(2, -3, 1)                                    // [2, 1]\n   *     math.polynomialRoot(8, 8, 2)                                     // [-2]\n   *     math.polynomialRoot(-2, 0, 1)                                    // [1.4142135623730951, -1.4142135623730951]\n   *     math.polynomialRoot(2, -2, 1)                                    // [1 + i, 1 - i]\n   *     math.polynomialRoot(math.complex(1,3), math.complex(-3, -2), 1)  // [2 + i, 1 + i]\n   *     // cubic\n   *     math.polynomialRoot(-6, 11, -6, 1)                               // [1, 3, 2]\n   *     math.polynomialRoot(-8, 0, 0, 1)                                 // [-1 - 1.7320508075688774i, 2, -1 + 1.7320508075688774i]\n   *     math.polynomialRoot(0, 8, 8, 2)                                  // [0, -2]\n   *     math.polynomialRoot(1, 1, 1, 1)                                  // [-1 + 0i, 0 - i, 0 + i]\n   *\n   * See also:\n   *     cbrt, sqrt\n   *\n   * @param {... number | Complex} coeffs\n   *     The coefficients of the polynomial, starting with with the constant coefficent, followed\n   *     by the linear coefficient and subsequent coefficients of increasing powers.\n   * @return {Array} The distinct roots of the polynomial\n   */\n\n  return typed(name, {\n    'number|Complex, ...number|Complex': (constant, restCoeffs) => {\n      var coeffs = [constant, ...restCoeffs];\n      while (coeffs.length > 0 && isZero(coeffs[coeffs.length - 1])) {\n        coeffs.pop();\n      }\n      if (coeffs.length < 2) {\n        throw new RangeError(\"Polynomial [\".concat(constant, \", \").concat(restCoeffs, \"] must have a non-zero non-constant coefficient\"));\n      }\n      switch (coeffs.length) {\n        case 2:\n          // linear\n          return [unaryMinus(divide(coeffs[0], coeffs[1]))];\n        case 3:\n          {\n            // quadratic\n            var [c, b, a] = coeffs;\n            var denom = multiply(2, a);\n            var d1 = multiply(b, b);\n            var d2 = multiply(4, a, c);\n            if (equalScalar(d1, d2)) return [divide(unaryMinus(b), denom)];\n            var discriminant = sqrt(subtract(d1, d2));\n            return [divide(subtract(discriminant, b), denom), divide(subtract(unaryMinus(discriminant), b), denom)];\n          }\n        case 4:\n          {\n            // cubic, cf. https://en.wikipedia.org/wiki/Cubic_equation\n            var [d, _c, _b, _a] = coeffs;\n            var _denom = unaryMinus(multiply(3, _a));\n            var D0_1 = multiply(_b, _b);\n            var D0_2 = multiply(3, _a, _c);\n            var D1_1 = add(multiply(2, _b, _b, _b), multiply(27, _a, _a, d));\n            var D1_2 = multiply(9, _a, _b, _c);\n            if (equalScalar(D0_1, D0_2) && equalScalar(D1_1, D1_2)) {\n              return [divide(_b, _denom)];\n            }\n            var Delta0 = subtract(D0_1, D0_2);\n            var Delta1 = subtract(D1_1, D1_2);\n            var discriminant1 = add(multiply(18, _a, _b, _c, d), multiply(_b, _b, _c, _c));\n            var discriminant2 = add(multiply(4, _b, _b, _b, d), multiply(4, _a, _c, _c, _c), multiply(27, _a, _a, d, d));\n            if (equalScalar(discriminant1, discriminant2)) {\n              return [divide(subtract(multiply(4, _a, _b, _c), add(multiply(9, _a, _a, d), multiply(_b, _b, _b))), multiply(_a, Delta0)),\n              // simple root\n              divide(subtract(multiply(9, _a, d), multiply(_b, _c)), multiply(2, Delta0)) // double root\n              ];\n            }\n            // OK, we have three distinct roots\n            var Ccubed;\n            if (equalScalar(D0_1, D0_2)) {\n              Ccubed = Delta1;\n            } else {\n              Ccubed = divide(add(Delta1, sqrt(subtract(multiply(Delta1, Delta1), multiply(4, Delta0, Delta0, Delta0)))), 2);\n            }\n            var allRoots = true;\n            var rawRoots = cbrt(Ccubed, allRoots).toArray().map(C => divide(add(_b, C, divide(Delta0, C)), _denom));\n            return rawRoots.map(r => {\n              if (typeOf(r) === 'Complex' && equalScalar(re(r), re(r) + im(r))) {\n                return re(r);\n              }\n              return r;\n            });\n          }\n        default:\n          throw new RangeError(\"only implemented for cubic or lower-order polynomials, not \".concat(coeffs));\n      }\n    }\n  });\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3686, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/sylvester.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'sylvester';\nvar dependencies = ['typed', 'schur', 'matrixFromColumns', 'matrix', 'multiply', 'range', 'concat', 'transpose', 'index', 'subset', 'add', 'subtract', 'identity', 'lusolve', 'abs'];\nexport var createSylvester = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    schur,\n    matrixFromColumns,\n    matrix,\n    multiply,\n    range,\n    concat,\n    transpose,\n    index,\n    subset,\n    add,\n    subtract,\n    identity,\n    lusolve,\n    abs\n  } = _ref;\n  /**\n   *\n   * Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are\n   * matrices of appropriate dimensions, being A and B squared. Notice that other\n   * equivalent definitions for the Sylvester equation exist and this function\n   * assumes the one presented in the original publication of the the Bartels-\n   * Stewart algorithm, which is implemented by this function.\n   * https://en.wikipedia.org/wiki/Sylvester_equation\n   *\n   * Syntax:\n   *\n   *     math.sylvester(A, B, C)\n   *\n   * Examples:\n   *\n   *     const A = [[-1, -2], [1, 1]]\n   *     const B = [[2, -1], [1, -2]]\n   *     const C = [[-3, 2], [3, 0]]\n   *     math.sylvester(A, B, C)      // returns DenseMatrix [[-0.25, 0.25], [1.5, -1.25]]\n   *\n   * See also:\n   *\n   *     schur, lyap\n   *\n   * @param {Matrix | Array} A  Matrix A\n   * @param {Matrix | Array} B  Matrix B\n   * @param {Matrix | Array} C  Matrix C\n   * @return {Matrix | Array}   Matrix X, solving the Sylvester equation\n   */\n  return typed(name, {\n    'Matrix, Matrix, Matrix': _sylvester,\n    'Array, Matrix, Matrix': function Array_Matrix_Matrix(A, B, C) {\n      return _sylvester(matrix(A), B, C);\n    },\n    'Array, Array, Matrix': function Array_Array_Matrix(A, B, C) {\n      return _sylvester(matrix(A), matrix(B), C);\n    },\n    'Array, Matrix, Array': function Array_Matrix_Array(A, B, C) {\n      return _sylvester(matrix(A), B, matrix(C));\n    },\n    'Matrix, Array, Matrix': function Matrix_Array_Matrix(A, B, C) {\n      return _sylvester(A, matrix(B), C);\n    },\n    'Matrix, Array, Array': function Matrix_Array_Array(A, B, C) {\n      return _sylvester(A, matrix(B), matrix(C));\n    },\n    'Matrix, Matrix, Array': function Matrix_Matrix_Array(A, B, C) {\n      return _sylvester(A, B, matrix(C));\n    },\n    'Array, Array, Array': function Array_Array_Array(A, B, C) {\n      return _sylvester(matrix(A), matrix(B), matrix(C)).toArray();\n    }\n  });\n  function _sylvester(A, B, C) {\n    var n = B.size()[0];\n    var m = A.size()[0];\n    var sA = schur(A);\n    var F = sA.T;\n    var U = sA.U;\n    var sB = schur(multiply(-1, B));\n    var G = sB.T;\n    var V = sB.U;\n    var D = multiply(multiply(transpose(U), C), V);\n    var all = range(0, m);\n    var y = [];\n    var hc = (a, b) => concat(a, b, 1);\n    var vc = (a, b) => concat(a, b, 0);\n    for (var k = 0; k < n; k++) {\n      if (k < n - 1 && abs(subset(G, index(k + 1, k))) > 1e-5) {\n        var RHS = vc(subset(D, index(all, k)), subset(D, index(all, k + 1)));\n        for (var j = 0; j < k; j++) {\n          RHS = add(RHS, vc(multiply(y[j], subset(G, index(j, k))), multiply(y[j], subset(G, index(j, k + 1)))));\n        }\n        var gkk = multiply(identity(m), multiply(-1, subset(G, index(k, k))));\n        var gmk = multiply(identity(m), multiply(-1, subset(G, index(k + 1, k))));\n        var gkm = multiply(identity(m), multiply(-1, subset(G, index(k, k + 1))));\n        var gmm = multiply(identity(m), multiply(-1, subset(G, index(k + 1, k + 1))));\n        var LHS = vc(hc(add(F, gkk), gmk), hc(gkm, add(F, gmm)));\n        var yAux = lusolve(LHS, RHS);\n        y[k] = yAux.subset(index(range(0, m), 0));\n        y[k + 1] = yAux.subset(index(range(m, 2 * m), 0));\n        k++;\n      } else {\n        var _RHS = subset(D, index(all, k));\n        for (var _j = 0; _j < k; _j++) {\n          _RHS = add(_RHS, multiply(y[_j], subset(G, index(_j, k))));\n        }\n        var _gkk = subset(G, index(k, k));\n        var _LHS = subtract(F, multiply(_gkk, identity(m)));\n        y[k] = lusolve(_LHS, _RHS);\n      }\n    }\n    var Y = matrix(matrixFromColumns(...y));\n    var X = multiply(U, multiply(Y, transpose(V)));\n    return X;\n  }\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3814, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js"],"sourcesContent":["import { factory } from '../../../utils/factory.js';\nvar name = 'schur';\nvar dependencies = ['typed', 'matrix', 'identity', 'multiply', 'qr', 'norm', 'subtract'];\nexport var createSchur = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    identity,\n    multiply,\n    qr,\n    norm,\n    subtract\n  } = _ref;\n  /**\n   *\n   * Performs a real Schur decomposition of the real matrix A = UTU' where U is orthogonal\n   * and T is upper quasi-triangular.\n   * https://en.wikipedia.org/wiki/Schur_decomposition\n   *\n   * Syntax:\n   *\n   *     math.schur(A)\n   *\n   * Examples:\n   *\n   *     const A = [[1, 0], [-4, 3]]\n   *     math.schur(A) // returns {T: [[3, 4], [0, 1]], R: [[0, 1], [-1, 0]]}\n   *\n   * See also:\n   *\n   *     sylvester, lyap, qr\n   *\n   * @param {Array | Matrix} A  Matrix A\n   * @return {{U: Array | Matrix, T: Array | Matrix}} Object containing both matrix U and T of the Schur Decomposition A=UTU'\n   */\n  return typed(name, {\n    Array: function Array(X) {\n      var r = _schur(matrix(X));\n      return {\n        U: r.U.valueOf(),\n        T: r.T.valueOf()\n      };\n    },\n    Matrix: function Matrix(X) {\n      return _schur(X);\n    }\n  });\n  function _schur(X) {\n    var n = X.size()[0];\n    var A = X;\n    var U = identity(n);\n    var k = 0;\n    var A0;\n    do {\n      A0 = A;\n      var QR = qr(A);\n      var Q = QR.Q;\n      var R = QR.R;\n      A = multiply(R, Q);\n      U = multiply(U, Q);\n      if (k++ > 100) {\n        break;\n      }\n    } while (norm(subtract(A, A0)) > 1e-4);\n    return {\n      U,\n      T: A\n    };\n  }\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAY;IAAY;IAAM;IAAQ;CAAW;AACjF,IAAI,cAAc,aAAa,GAAE,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAClE,IAAI,EACF,KAAK,EACL,MAAM,EACN,QAAQ,EACR,QAAQ,EACR,EAAE,EACF,IAAI,EACJ,QAAQ,EACT,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;GAqBC,GACD,OAAO,MAAM,MAAM;QACjB,OAAO,SAAS,MAAM,CAAC;YACrB,IAAI,IAAI,OAAO,OAAO;YACtB,OAAO;gBACL,GAAG,EAAE,CAAC,CAAC,OAAO;gBACd,GAAG,EAAE,CAAC,CAAC,OAAO;YAChB;QACF;QACA,QAAQ,SAAS,OAAO,CAAC;YACvB,OAAO,OAAO;QAChB;IACF;;IACA,SAAS,OAAO,CAAC;QACf,IAAI,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE;QACnB,IAAI,IAAI;QACR,IAAI,IAAI,SAAS;QACjB,IAAI,IAAI;QACR,IAAI;QACJ,GAAG;YACD,KAAK;YACL,IAAI,KAAK,GAAG;YACZ,IAAI,IAAI,GAAG,CAAC;YACZ,IAAI,IAAI,GAAG,CAAC;YACZ,IAAI,SAAS,GAAG;YAChB,IAAI,SAAS,GAAG;YAChB,IAAI,MAAM,KAAK;gBACb;YACF;QACF,QAAS,KAAK,SAAS,GAAG,OAAO,KAAM;QACvC,OAAO;YACL;YACA,GAAG;QACL;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3894, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/lyap.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'lyap';\nvar dependencies = ['typed', 'matrix', 'sylvester', 'multiply', 'transpose'];\nexport var createLyap = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    sylvester,\n    multiply,\n    transpose\n  } = _ref;\n  /**\n   *\n   * Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P, where\n   * Q is an input matrix. When Q is symmetric, P is also symmetric. Notice\n   * that different equivalent definitions exist for the Continuous-time\n   * Lyapunov equation.\n   * https://en.wikipedia.org/wiki/Lyapunov_equation\n   *\n   * Syntax:\n   *\n   *     math.lyap(A, Q)\n   *\n   * Examples:\n   *\n   *     const A = [[-2, 0], [1, -4]]\n   *     const Q = [[3, 1], [1, 3]]\n   *     const P = math.lyap(A, Q)\n   *\n   * See also:\n   *\n   *     sylvester, schur\n   *\n   * @param {Matrix | Array} A  Matrix A\n   * @param {Matrix | Array} Q  Matrix Q\n   * @return {Matrix | Array} Matrix P solution to the Continuous-time Lyapunov equation AP+PA'=Q\n   */\n  return typed(name, {\n    'Matrix, Matrix': function Matrix_Matrix(A, Q) {\n      return sylvester(A, transpose(A), multiply(-1, Q));\n    },\n    'Array, Matrix': function Array_Matrix(A, Q) {\n      return sylvester(matrix(A), transpose(matrix(A)), multiply(-1, Q));\n    },\n    'Matrix, Array': function Matrix_Array(A, Q) {\n      return sylvester(A, transpose(matrix(A)), matrix(multiply(-1, Q)));\n    },\n    'Array, Array': function Array_Array(A, Q) {\n      return sylvester(matrix(A), transpose(matrix(A)), matrix(multiply(-1, Q))).toArray();\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAU;IAAa;IAAY;CAAY;AACrE,IAAI,aAAa,aAAa,GAAE,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACjE,IAAI,EACF,KAAK,EACL,MAAM,EACN,SAAS,EACT,QAAQ,EACR,SAAS,EACV,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;GAyBC,GACD,OAAO,MAAM,MAAM;QACjB,kBAAkB,SAAS,cAAc,CAAC,EAAE,CAAC;YAC3C,OAAO,UAAU,GAAG,UAAU,IAAI,SAAS,CAAC,GAAG;QACjD;QACA,iBAAiB,SAAS,aAAa,CAAC,EAAE,CAAC;YACzC,OAAO,UAAU,OAAO,IAAI,UAAU,OAAO,KAAK,SAAS,CAAC,GAAG;QACjE;QACA,iBAAiB,SAAS,aAAa,CAAC,EAAE,CAAC;YACzC,OAAO,UAAU,GAAG,UAAU,OAAO,KAAK,OAAO,SAAS,CAAC,GAAG;QAChE;QACA,gBAAgB,SAAS,YAAY,CAAC,EAAE,CAAC;YACvC,OAAO,UAAU,OAAO,IAAI,UAAU,OAAO,KAAK,OAAO,SAAS,CAAC,GAAG,KAAK,OAAO;QACpF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3955, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/leafCount.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'leafCount';\nvar dependencies = ['parse', 'typed'];\nexport var createLeafCount = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    parse,\n    typed\n  } = _ref;\n  // This does the real work, but we don't have to recurse through\n  // a typed call if we separate it out\n  function countLeaves(node) {\n    var count = 0;\n    node.forEach(n => {\n      count += countLeaves(n);\n    });\n    return count || 1;\n  }\n\n  /**\n   * Gives the number of \"leaf nodes\" in the parse tree of the given expression\n   * A leaf node is one that has no subexpressions, essentially either a\n   * symbol or a constant. Note that `5!` has just one leaf, the '5'; the\n   * unary factorial operator does not add a leaf. On the other hand,\n   * function symbols do add leaves, so `sin(x)/cos(x)` has four leaves.\n   *\n   * The `simplify()` function should generally not increase the `leafCount()`\n   * of an expression, although currently there is no guarantee that it never\n   * does so. In many cases, `simplify()` reduces the leaf count.\n   *\n   * Syntax:\n   *\n   *     math.leafCount(expr)\n   *\n   * Examples:\n   *\n   *     math.leafCount('x') // 1\n   *     math.leafCount(math.parse('a*d-b*c')) // 4\n   *     math.leafCount('[a,b;c,d][0,1]') // 6\n   *\n   * See also:\n   *\n   *     simplify\n   *\n   * @param {Node|string} expr    The expression to count the leaves of\n   *\n   * @return {number}  The number of leaves of `expr`\n   *\n   */\n  return typed(name, {\n    Node: function Node(expr) {\n      return countLeaves(expr);\n    }\n  });\n});"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;CAAQ;AAC9B,IAAI,kBAAkB,aAAa,GAAE,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IACtE,IAAI,EACF,KAAK,EACL,KAAK,EACN,GAAG;IACJ,gEAAgE;IAChE,qCAAqC;IACrC,SAAS,YAAY,IAAI;QACvB,IAAI,QAAQ;QACZ,KAAK,OAAO,CAAC,CAAA;YACX,SAAS,YAAY;QACvB;QACA,OAAO,SAAS;IAClB;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BC,GACD,OAAO,MAAM,MAAM;QACjB,MAAM,SAAS,KAAK,IAAI;YACtB,OAAO,YAAY;QACrB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4017, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/simplify/wildcards.js"],"sourcesContent":["import { isConstantNode, isFunctionNode, isOperatorNode, isParenthesisNode } from '../../../utils/is.js';\nexport { isConstantNode, isSymbolNode as isVariableNode } from '../../../utils/is.js';\nexport function isNumericNode(x) {\n  return isConstantNode(x) || isOperatorNode(x) && x.isUnary() && isConstantNode(x.args[0]);\n}\nexport function isConstantExpression(x) {\n  if (isConstantNode(x)) {\n    // Basic Constant types\n    return true;\n  }\n  if ((isFunctionNode(x) || isOperatorNode(x)) && x.args.every(isConstantExpression)) {\n    // Can be constant depending on arguments\n    return true;\n  }\n  if (isParenthesisNode(x) && isConstantExpression(x.content)) {\n    // Parenthesis are transparent\n    return true;\n  }\n  return false; // Probably missing some edge cases\n}"],"names":[],"mappings":";;;;AAAA;;;AAEO,SAAS,cAAc,CAAC;IAC7B,OAAO,CAAA,GAAA,sJAAA,CAAA,iBAAc,AAAD,EAAE,MAAM,CAAA,GAAA,sJAAA,CAAA,iBAAc,AAAD,EAAE,MAAM,EAAE,OAAO,MAAM,CAAA,GAAA,sJAAA,CAAA,iBAAc,AAAD,EAAE,EAAE,IAAI,CAAC,EAAE;AAC1F;AACO,SAAS,qBAAqB,CAAC;IACpC,IAAI,CAAA,GAAA,sJAAA,CAAA,iBAAc,AAAD,EAAE,IAAI;QACrB,uBAAuB;QACvB,OAAO;IACT;IACA,IAAI,CAAC,CAAA,GAAA,sJAAA,CAAA,iBAAc,AAAD,EAAE,MAAM,CAAA,GAAA,sJAAA,CAAA,iBAAc,AAAD,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,uBAAuB;QAClF,yCAAyC;QACzC,OAAO;IACT;IACA,IAAI,CAAA,GAAA,sJAAA,CAAA,oBAAiB,AAAD,EAAE,MAAM,qBAAqB,EAAE,OAAO,GAAG;QAC3D,8BAA8B;QAC9B,OAAO;IACT;IACA,OAAO,OAAO,mCAAmC;AACnD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4048, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/simplify/util.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { isFunctionNode, isOperatorNode, isParenthesisNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { hasOwnProperty } from '../../../utils/object.js';\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nexport var createUtil = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n\n  /* So that properties of an operator fit on one line: */\n  var T = true;\n  var F = false;\n  var defaultName = 'defaultF';\n  var defaultContext = {\n    /*      */add: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n    /**/unaryPlus: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n    /* */subtract: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    },\n    /* */multiply: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n    /*   */divide: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    },\n    /*    */paren: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: F\n    },\n    /* */defaultF: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    }\n  };\n  var realContext = {\n    divide: {\n      total: F\n    },\n    log: {\n      total: F\n    }\n  };\n  var positiveContext = {\n    subtract: {\n      total: F\n    },\n    abs: {\n      trivial: T\n    },\n    log: {\n      total: T\n    }\n  };\n  function hasProperty(nodeOrName, property) {\n    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultContext;\n    var name = defaultName;\n    if (typeof nodeOrName === 'string') {\n      name = nodeOrName;\n    } else if (isOperatorNode(nodeOrName)) {\n      name = nodeOrName.fn.toString();\n    } else if (isFunctionNode(nodeOrName)) {\n      name = nodeOrName.name;\n    } else if (isParenthesisNode(nodeOrName)) {\n      name = 'paren';\n    }\n    if (hasOwnProperty(context, name)) {\n      var properties = context[name];\n      if (hasOwnProperty(properties, property)) {\n        return properties[property];\n      }\n      if (hasOwnProperty(defaultContext, name)) {\n        return defaultContext[name][property];\n      }\n    }\n    if (hasOwnProperty(context, defaultName)) {\n      var _properties = context[defaultName];\n      if (hasOwnProperty(_properties, property)) {\n        return _properties[property];\n      }\n      return defaultContext[defaultName][property];\n    }\n    /* name not found in context and context has no global default */\n    /* So use default context. */\n    if (hasOwnProperty(defaultContext, name)) {\n      var _properties2 = defaultContext[name];\n      if (hasOwnProperty(_properties2, property)) {\n        return _properties2[property];\n      }\n    }\n    return defaultContext[defaultName][property];\n  }\n  function isCommutative(node) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;\n    return hasProperty(node, 'commutative', context);\n  }\n  function isAssociative(node) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;\n    return hasProperty(node, 'associative', context);\n  }\n\n  /**\n   * Merge the given contexts, with primary overriding secondary\n   * wherever they might conflict\n   */\n  function mergeContext(primary, secondary) {\n    var merged = _objectSpread({}, primary);\n    for (var prop in secondary) {\n      if (hasOwnProperty(primary, prop)) {\n        merged[prop] = _objectSpread(_objectSpread({}, secondary[prop]), primary[prop]);\n      } else {\n        merged[prop] = secondary[prop];\n      }\n    }\n    return merged;\n  }\n\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n  function flatten(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n    node.args = allChildren(node, context);\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i], context);\n    }\n  }\n\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n  function allChildren(node, context) {\n    var op;\n    var children = [];\n    var _findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n        if (isOperatorNode(child) && op === child.op) {\n          _findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n    if (isAssociative(node, context)) {\n      op = node.op;\n      _findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n  function unflattenr(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i], context);\n    }\n    if (l > 2 && isAssociative(node, context)) {\n      var curnode = node.args.pop();\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n      node.args = curnode.args;\n    }\n  }\n\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n  function unflattenl(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i], context);\n    }\n    if (l > 2 && isAssociative(node, context)) {\n      var curnode = node.args.shift();\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n      node.args = curnode.args;\n    }\n  }\n  function createMakeNodeFunction(node) {\n    if (isOperatorNode(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n  return {\n    createMakeNodeFunction,\n    hasProperty,\n    isCommutative,\n    isAssociative,\n    mergeContext,\n    flatten,\n    allChildren,\n    unflattenr,\n    unflattenl,\n    defaultContext,\n    realContext,\n    positiveContext\n  };\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4333, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/simplify.js"],"sourcesContent":["import { isParenthesisNode } from '../../utils/is.js';\nimport { isConstantNode, isVariableNode, isNumericNode, isConstantExpression } from './simplify/wildcards.js';\nimport { factory } from '../../utils/factory.js';\nimport { createUtil } from './simplify/util.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { createEmptyMap, createMap } from '../../utils/map.js';\nvar name = 'simplify';\nvar dependencies = ['typed', 'parse', 'equal', 'resolve', 'simplifyConstant', 'simplifyCore', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplify = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    parse,\n    equal,\n    resolve,\n    simplifyConstant,\n    simplifyCore,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  var {\n    hasProperty,\n    isCommutative,\n    isAssociative,\n    mergeContext,\n    flatten,\n    unflattenr,\n    unflattenl,\n    createMakeNodeFunction,\n    defaultContext,\n    realContext,\n    positiveContext\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n\n  /**\n   * Simplify an expression tree.\n   *\n   * A list of rules are applied to an expression, repeating over the list until\n   * no further changes are made.\n   * It's possible to pass a custom set of rules to the function as second\n   * argument. A rule can be specified as an object, string, or function:\n   *\n   *     const rules = [\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\n   *       function (node) {\n   *         // ... return a new node or return the node unchanged\n   *         return node\n   *       }\n   *     ]\n   *\n   * String and object rules consist of a left and right pattern. The left is\n   * used to match against the expression and the right determines what matches\n   * are replaced with. The main difference between a pattern and a normal\n   * expression is that variables starting with the following characters are\n   * interpreted as wildcards:\n   *\n   * - 'n' - Matches any node [Node]\n   * - 'c' - Matches a constant literal (5 or 3.2) [ConstantNode]\n   * - 'cl' - Matches a constant literal; same as c [ConstantNode]\n   * - 'cd' - Matches a decimal literal (5 or -3.2) [ConstantNode or unaryMinus wrapping a ConstantNode]\n   * - 'ce' - Matches a constant expression (-5 or √3) [Expressions consisting of only ConstantNodes, functions, and operators]\n   * - 'v' - Matches a variable; anything not matched by c (-5 or x) [Node that is not a ConstantNode]\n   * - 'vl' - Matches a variable literal (x or y) [SymbolNode]\n   * - 'vd' - Matches a non-decimal expression; anything not matched by cd (x or √3) [Node that is not a ConstantNode or unaryMinus that is wrapping a ConstantNode]\n   * - 've' - Matches a variable expression; anything not matched by ce (x or 2x) [Expressions that contain a SymbolNode or other non-constant term]\n   *\n   * The default list of rules is exposed on the function as `simplify.rules`\n   * and can be used as a basis to built a set of custom rules. Note that since\n   * the `simplifyCore` function is in the default list of rules, by default\n   * simplify will convert any function calls in the expression that have\n   * operator equivalents to their operator forms.\n   *\n   * To specify a rule as a string, separate the left and right pattern by '->'\n   * When specifying a rule as an object, the following keys are meaningful:\n   * - l - the left pattern\n   * - r - the right pattern\n   * - s - in lieu of l and r, the string form that is broken at -> to give them\n   * - repeat - whether to repeat this rule until the expression stabilizes\n   * - assuming - gives a context object, as in the 'context' option to\n   *     simplify. Every property in the context object must match the current\n   *     context in order, or else the rule will not be applied.\n   * - imposeContext - gives a context object, as in the 'context' option to\n   *     simplify. Any settings specified will override the incoming context\n   *     for all matches of this rule.\n   *\n   * For more details on the theory, see:\n   *\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\n   *\n   *  An optional `options` argument can be passed as last argument of `simplify`.\n   *  Currently available options (defaults in parentheses):\n   *  - `consoleDebug` (false): whether to write the expression being simplified\n   *    and any changes to it, along with the rule responsible, to console\n   *  - `context` (simplify.defaultContext): an object giving properties of\n   *    each operator, which determine what simplifications are allowed. The\n   *    currently meaningful properties are commutative, associative,\n   *    total (whether the operation is defined for all arguments), and\n   *    trivial (whether the operation applied to a single argument leaves\n   *    that argument unchanged). The default context is very permissive and\n   *    allows almost all simplifications. Only properties differing from\n   *    the default need to be specified; the default context is used as a\n   *    fallback. Additional contexts `simplify.realContext` and\n   *    `simplify.positiveContext` are supplied to cause simplify to perform\n   *    just simplifications guaranteed to preserve all values of the expression\n   *    assuming all variables and subexpressions are real numbers or\n   *    positive real numbers, respectively. (Note that these are in some cases\n   *    more restrictive than the default context; for example, the default\n   *    context will allow `x/x` to simplify to 1, whereas\n   *    `simplify.realContext` will not, as `0/0` is not equal to 1.)\n   *  - `exactFractions` (true): whether to try to convert all constants to\n   *    exact rational numbers.\n   *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will\n   *    be expressed as fractions only when both numerator and denominator\n   *    are smaller than `fractionsLimit`.\n   *\n   * Syntax:\n   *\n   *     math.simplify(expr)\n   *     math.simplify(expr, rules)\n   *     math.simplify(expr, rules)\n   *     math.simplify(expr, rules, scope)\n   *     math.simplify(expr, rules, scope, options)\n   *     math.simplify(expr, scope)\n   *     math.simplify(expr, scope, options)\n   *\n   * Examples:\n   *\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify(f)                          // Node \"2 * x\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\n   *\n   * See also:\n   *\n   *     simplifyCore, derivative, evaluate, parse, rationalize, resolve\n   *\n   * @param {Node | string} expr\n   *            The expression to be simplified\n   * @param {SimplifyRule[]} [rules]\n   *            Optional list with custom rules\n   * @param {Object} [scope] Optional scope with variables\n   * @param {SimplifyOptions} [options] Optional configuration settings\n   * @return {Node} Returns the simplified form of `expr`\n   */\n  typed.addConversion({\n    from: 'Object',\n    to: 'Map',\n    convert: createMap\n  });\n  var simplify = typed('simplify', {\n    Node: _simplify,\n    'Node, Map': (expr, scope) => _simplify(expr, false, scope),\n    'Node, Map, Object': (expr, scope, options) => _simplify(expr, false, scope, options),\n    'Node, Array': _simplify,\n    'Node, Array, Map': _simplify,\n    'Node, Array, Map, Object': _simplify\n  });\n  typed.removeConversion({\n    from: 'Object',\n    to: 'Map',\n    convert: createMap\n  });\n  simplify.defaultContext = defaultContext;\n  simplify.realContext = realContext;\n  simplify.positiveContext = positiveContext;\n  function removeParens(node) {\n    return node.transform(function (node) {\n      return isParenthesisNode(node) ? removeParens(node.content) : node;\n    });\n  }\n\n  // All constants that are allowed in rules\n  var SUPPORTED_CONSTANTS = {\n    true: true,\n    false: true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true\n    // null: false,\n    // undefined: false,\n    // version: false,\n  };\n\n  // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n  simplify.rules = [simplifyCore,\n  // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  },\n  // temporary rules\n  // Note initially we tend constants to the right because like-term\n  // collection prefers the left, and we would rather collect nonconstants\n  {\n    s: 'n-n1 -> n+-n1',\n    // temporarily replace 'subtract' so we can further flatten the 'add' operator\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n-n -> 0',\n    // partial alternative when we can't always subtract\n    assuming: {\n      subtract: {\n        total: false\n      }\n    }\n  }, {\n    s: '-(cl*v) -> v * (-cl)',\n    // make non-constant terms positive\n    assuming: {\n      multiply: {\n        commutative: true\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(cl*v) -> (-cl) * v',\n    // non-commutative version, part 1\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(v*cl) -> v * (-cl)',\n    // non-commutative version, part 2\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    l: '-(n1/n2)',\n    r: '-n1/n2'\n  }, {\n    l: '-v',\n    r: 'v * (-1)'\n  },\n  // finish making non-constant terms positive\n  {\n    l: '(n1 + n2)*(-1)',\n    r: 'n1*(-1) + n2*(-1)',\n    repeat: true\n  },\n  // expand negations to achieve as much sign cancellation as possible\n  {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  },\n  // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, {\n    s: '(n1*n2)^n3 -> n1^n3 * n2^n3',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: '(n1*n2)^(-1) -> n2^(-1) * n1^(-1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  },\n  // expand nested exponentiation\n  {\n    s: '(n ^ n1) ^ n2 -> n ^ (n1 * n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // 1/(1/n) = n needs 1/n to exist\n  },\n  // collect like factors; into a sum, only do this for nonconstants\n  {\n    l: ' vd   * ( vd   * n1 + n2)',\n    r: 'vd^2       * n1 +  vd   * n2'\n  }, {\n    s: ' vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // v*1/v = v^(1+-1) needs 1/v\n  }, {\n    s: 'vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    s: 'vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    s: 'n * n^n1 -> n^(n1+1)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // n*1/n = n^(-1+1) needs 1/n\n  }, {\n    s: 'n^n1 * n^n2 -> n^(n1+n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // ditto for n^2*1/n^2\n  },\n  // Unfortunately, to deal with more complicated cancellations, it\n  // becomes necessary to simplify constants twice per pass. It's not\n  // terribly expensive compared to matching rules, so this should not\n  // pose a performance problem.\n  simplifyConstant,\n  // First: before collecting like terms\n\n  // collect like terms\n  {\n    s: 'n+n -> 2*n',\n    assuming: {\n      add: {\n        total: true\n      }\n    } // 2 = 1 + 1 needs to exist\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'vd*n + vd',\n    r: 'vd*(n+1)'\n  },\n  // NOTE: leftmost position is special:\n  {\n    l: 'n3*n1 + n3*n2',\n    r: 'n3*(n1+n2)'\n  },\n  // All sub-monomials tried there.\n  {\n    l: 'n3^(-n4)*n1 +   n3  * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+1) *n2)'\n  }, {\n    l: 'n3^(-n4)*n1 + n3^n5 * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+n5)*n2)'\n  },\n  // noncommutative additional cases (term collection & factoring)\n  {\n    s: 'n*vd + vd -> (n+1)*vd',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'vd + n*vd -> (1+n)*vd',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3 + n2*n3 -> (n1+n2)*n3',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n^n1 * n -> n^(n1+1)',\n    assuming: {\n      divide: {\n        total: true\n      },\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'n*cd + cd',\n    r: '(n+1)*cd'\n  }, {\n    s: 'cd*n + cd -> cd*(n+1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'cd + cd*n -> cd*(1+n)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, simplifyConstant,\n  // Second: before returning expressions to \"standard form\"\n\n  // make factors positive (and undo 'make non-constant terms positive')\n  {\n    s: '(-n)*n1 -> -(n*n1)',\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n1*(-n) -> -(n1*n)',\n    // in case * non-commutative\n    assuming: {\n      subtract: {\n        total: true\n      },\n      multiply: {\n        commutative: false\n      }\n    }\n  },\n  // final ordering of constants\n  {\n    s: 'ce+ve -> ve+ce',\n    assuming: {\n      add: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'vd*cd -> cd*vd',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      multiply: {\n        commutative: false\n      }\n    }\n  },\n  // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  },\n  // undo replace 'subtract'\n  {\n    l: 'n+-(n1)',\n    r: 'n-(n1)'\n  }, {\n    s: 'n*(n1^-1) -> n/n1',\n    // undo replace 'divide'; for * commutative\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n  }, {\n    s: 'n*n1^-n2 -> n/n1^n2',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n  }, {\n    s: 'n^-1 -> 1/n',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n  }, {\n    l: 'n^1',\n    r: 'n'\n  },\n  // can be produced by power cancellation\n  {\n    s: 'n*(n1/n2) -> (n*n1)/n2',\n    // '*' before '/'\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    s: 'n-(n1+n2) -> n-n1-n2',\n    // '-' before '+'\n    assuming: {\n      addition: {\n        associative: true,\n        commutative: true\n      }\n    }\n  },\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n\n  // simplifyConstant can leave an extra factor of 1, which can always\n  // be eliminated, since the identity always commutes\n  {\n    l: '1*n',\n    r: 'n',\n    imposeContext: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: 'n1/(n2/n3) -> (n1*n3)/n2',\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    l: 'n1/(-n2)',\n    r: '-n1/n2'\n  }];\n\n  /**\n   * Takes any rule object as allowed by the specification in simplify\n   * and puts it in a standard form used by applyRule\n   */\n  function _canonicalizeRule(ruleObject, context) {\n    var newRule = {};\n    if (ruleObject.s) {\n      var lr = ruleObject.s.split('->');\n      if (lr.length === 2) {\n        newRule.l = lr[0];\n        newRule.r = lr[1];\n      } else {\n        throw SyntaxError('Could not parse rule: ' + ruleObject.s);\n      }\n    } else {\n      newRule.l = ruleObject.l;\n      newRule.r = ruleObject.r;\n    }\n    newRule.l = removeParens(parse(newRule.l));\n    newRule.r = removeParens(parse(newRule.r));\n    for (var prop of ['imposeContext', 'repeat', 'assuming']) {\n      if (prop in ruleObject) {\n        newRule[prop] = ruleObject[prop];\n      }\n    }\n    if (ruleObject.evaluate) {\n      newRule.evaluate = parse(ruleObject.evaluate);\n    }\n    if (isAssociative(newRule.l, context)) {\n      var nonCommutative = !isCommutative(newRule.l, context);\n      var leftExpandsym;\n      // Gen. the LHS placeholder used in this NC-context specific expansion rules\n      if (nonCommutative) leftExpandsym = _getExpandPlaceholderSymbol();\n      var makeNode = createMakeNodeFunction(newRule.l);\n      var expandsym = _getExpandPlaceholderSymbol();\n      newRule.expanded = {};\n      newRule.expanded.l = makeNode([newRule.l, expandsym]);\n      // Push the expandsym into the deepest possible branch.\n      // This helps to match the newRule against nodes returned from getSplits() later on.\n      flatten(newRule.expanded.l, context);\n      unflattenr(newRule.expanded.l, context);\n      newRule.expanded.r = makeNode([newRule.r, expandsym]);\n\n      // In and for a non-commutative context, attempting with yet additional expansion rules makes\n      // way for more matches cases of multi-arg expressions; such that associative rules (such as\n      // 'n*n -> n^2') can be applied to exprs. such as 'a * b * b' and 'a * b * b * a'.\n      if (nonCommutative) {\n        // 'Non-commutative' 1: LHS (placeholder) only\n        newRule.expandedNC1 = {};\n        newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);\n        newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]);\n        // 'Non-commutative' 2: farmost LHS and RHS placeholders\n        newRule.expandedNC2 = {};\n        newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);\n        newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);\n      }\n    }\n    return newRule;\n  }\n\n  /**\n   * Parse the string array of rules into nodes\n   *\n   * Example syntax for rules:\n   *\n   * Position constants to the left in a product:\n   * { l: 'n1 * c1', r: 'c1 * n1' }\n   * n1 is any Node, and c1 is a ConstantNode.\n   *\n   * Apply difference of squares formula:\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\n   * n1, n2 mean any Node.\n   *\n   * Short hand notation:\n   * 'n1 * c1 -> c1 * n1'\n   */\n  function _buildRules(rules, context) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n      var ruleType = typeof rule;\n      switch (ruleType) {\n        case 'string':\n          rule = {\n            s: rule\n          };\n        /* falls through */\n        case 'object':\n          newRule = _canonicalizeRule(rule, context);\n          break;\n        case 'function':\n          newRule = rule;\n          break;\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      }\n      // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n      ruleSet.push(newRule);\n    }\n    return ruleSet;\n  }\n  var _lastsym = 0;\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n  function _simplify(expr, rules) {\n    var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createEmptyMap();\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var debug = options.consoleDebug;\n    rules = _buildRules(rules || simplify.rules, options.context);\n    var res = resolve(expr, scope);\n    res = removeParens(res);\n    var visited = {};\n    var str = res.toString({\n      parenthesis: 'all'\n    });\n    while (!visited[str]) {\n      visited[str] = true;\n      _lastsym = 0; // counter for placeholder symbols\n      var laststr = str;\n      if (debug) console.log('Working on: ', str);\n      for (var i = 0; i < rules.length; i++) {\n        var rulestr = '';\n        if (typeof rules[i] === 'function') {\n          res = rules[i](res, options);\n          if (debug) rulestr = rules[i].name;\n        } else {\n          flatten(res, options.context);\n          res = applyRule(res, rules[i], options.context);\n          if (debug) {\n            rulestr = \"\".concat(rules[i].l.toString(), \" -> \").concat(rules[i].r.toString());\n          }\n        }\n        if (debug) {\n          var newstr = res.toString({\n            parenthesis: 'all'\n          });\n          if (newstr !== laststr) {\n            console.log('Applying', rulestr, 'produced', newstr);\n            laststr = newstr;\n          }\n        }\n        /* Use left-heavy binary tree internally,\n         * since custom rule functions may expect it\n         */\n        unflattenl(res, options.context);\n      }\n      str = res.toString({\n        parenthesis: 'all'\n      });\n    }\n    return res;\n  }\n  function mapRule(nodes, rule, context) {\n    var resNodes = nodes;\n    if (nodes) {\n      for (var i = 0; i < nodes.length; ++i) {\n        var newNode = applyRule(nodes[i], rule, context);\n        if (newNode !== nodes[i]) {\n          if (resNodes === nodes) {\n            resNodes = nodes.slice();\n          }\n          resNodes[i] = newNode;\n        }\n      }\n    }\n    return resNodes;\n  }\n\n  /**\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {Object | Function} rule\n   * @param  {Object} context -- information about assumed properties of operators\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\n   */\n  function applyRule(node, rule, context) {\n    //    console.log('Entering applyRule(\"', rule.l.toString({parenthesis:'all'}), '->', rule.r.toString({parenthesis:'all'}), '\",', node.toString({parenthesis:'all'}),')')\n\n    // check that the assumptions for this rule are satisfied by the current\n    // context:\n    if (rule.assuming) {\n      for (var symbol in rule.assuming) {\n        for (var property in rule.assuming[symbol]) {\n          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {\n            return node;\n          }\n        }\n      }\n    }\n    var mergedContext = mergeContext(rule.imposeContext, context);\n\n    // Do not clone node unless we find a match\n    var res = node;\n\n    // First replace our child nodes with their simplified versions\n    // If a child could not be simplified, applying the rule to it\n    // will have no effect since the node is returned unchanged\n    if (res instanceof OperatorNode || res instanceof FunctionNode) {\n      var newArgs = mapRule(res.args, rule, context);\n      if (newArgs !== res.args) {\n        res = res.clone();\n        res.args = newArgs;\n      }\n    } else if (res instanceof ParenthesisNode) {\n      if (res.content) {\n        var newContent = applyRule(res.content, rule, context);\n        if (newContent !== res.content) {\n          res = new ParenthesisNode(newContent);\n        }\n      }\n    } else if (res instanceof ArrayNode) {\n      var newItems = mapRule(res.items, rule, context);\n      if (newItems !== res.items) {\n        res = new ArrayNode(newItems);\n      }\n    } else if (res instanceof AccessorNode) {\n      var newObj = res.object;\n      if (res.object) {\n        newObj = applyRule(res.object, rule, context);\n      }\n      var newIndex = res.index;\n      if (res.index) {\n        newIndex = applyRule(res.index, rule, context);\n      }\n      if (newObj !== res.object || newIndex !== res.index) {\n        res = new AccessorNode(newObj, newIndex);\n      }\n    } else if (res instanceof IndexNode) {\n      var newDims = mapRule(res.dimensions, rule, context);\n      if (newDims !== res.dimensions) {\n        res = new IndexNode(newDims);\n      }\n    } else if (res instanceof ObjectNode) {\n      var changed = false;\n      var newProps = {};\n      for (var prop in res.properties) {\n        newProps[prop] = applyRule(res.properties[prop], rule, context);\n        if (newProps[prop] !== res.properties[prop]) {\n          changed = true;\n        }\n      }\n      if (changed) {\n        res = new ObjectNode(newProps);\n      }\n    }\n\n    // Try to match a rule against this node\n    var repl = rule.r;\n    var matches = _ruleMatch(rule.l, res, mergedContext)[0];\n\n    // If the rule is associative operator, we can try matching it while allowing additional terms.\n    // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n    if (!matches && rule.expanded) {\n      repl = rule.expanded.r;\n      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];\n    }\n    // Additional, non-commutative context expansion-rules\n    if (!matches && rule.expandedNC1) {\n      repl = rule.expandedNC1.r;\n      matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];\n      if (!matches) {\n        // Existence of NC1 implies NC2\n        repl = rule.expandedNC2.r;\n        matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];\n      }\n    }\n    if (matches) {\n      // const before = res.toString({parenthesis: 'all'})\n\n      // Create a new node by cloning the rhs of the matched rule\n      // we keep any implicit multiplication state if relevant\n      var implicit = res.implicit;\n      res = repl.clone();\n      if (implicit && 'implicit' in repl) {\n        res.implicit = true;\n      }\n\n      // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n      res = res.transform(function (node) {\n        if (node.isSymbolNode && hasOwnProperty(matches.placeholders, node.name)) {\n          return matches.placeholders[node.name].clone();\n        } else {\n          return node;\n        }\n      });\n\n      // const after = res.toString({parenthesis: 'all'})\n      // console.log('Simplified ' + before + ' to ' + after)\n    }\n    if (rule.repeat && res !== node) {\n      res = applyRule(res, rule, context);\n    }\n    return res;\n  }\n\n  /**\n   * Get (binary) combinations of a flattened binary node\n   * e.g. +(node1, node2, node3) -> [\n   *        +(node1,  +(node2, node3)),\n   *        +(node2,  +(node1, node3)),\n   *        +(node3,  +(node1, node2))]\n   *\n   */\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      // Keep order, but try all parenthesizations\n      for (var _i = 1; _i < node.args.length; _i++) {\n        var left = node.args[0];\n        if (_i > 1) {\n          left = makeNode(node.args.slice(0, _i));\n        }\n        rightArgs = node.args.slice(_i);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([left, right]));\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Returns the set union of two match-placeholders or null if there is a conflict.\n   */\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    };\n\n    // Some matches may not have placeholders; this is OK\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    }\n\n    // Placeholders with the same key must match exactly\n    for (var key in match1.placeholders) {\n      if (hasOwnProperty(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n        if (hasOwnProperty(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n    for (var _key in match2.placeholders) {\n      if (hasOwnProperty(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   */\n  function combineChildMatches(list1, list2) {\n    var res = [];\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n    var merged;\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\n   * Each list represents matches found in one child of a node.\n   * Returns a list of unique matches.\n   */\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n    return uniqueSets;\n  }\n\n  /**\n   * Determines whether node matches rule.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param {Object} context -- provides assumed properties of operators\n   * @param {Boolean} isSplit -- whether we are in process of splitting an\n   *                    n-ary operator node into possible binary combinations.\n   *                    Defaults to false.\n   * @return {Object} Information about the match, if it exists.\n   */\n  function _ruleMatch(rule, node, context, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n\n    //    console.log('Entering _ruleMatch(', rule.toString({parenthesis:'all'}), ', ', node.toString({parenthesis:'all'}), ', ', context, ')')\n    var res = [{\n      placeholders: {}\n    }];\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      }\n\n      // rule and node match. Search the children of rule and node.\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly,\n        // except in any order if operator is commutative\n        var childMatches = [];\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i], context);\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            break;\n          }\n          // The child matched, so add the information returned from the child to our result\n          childMatches.push(childMatch);\n        }\n        if (childMatches.length !== rule.args.length) {\n          if (!isCommutative(node, context) ||\n          // exact match in order needed\n          rule.args.length === 1) {\n            // nothing to commute\n            return [];\n          }\n          if (rule.args.length > 2) {\n            /* Need to generate all permutations and try them.\n             * It's a bit complicated, and unlikely to come up since there\n             * are very few ternary or higher operators. So punt for now.\n             */\n            throw new Error('permuting >2 commutative non-associative rule arguments not yet implemented');\n          }\n          /* Exactly two arguments, try them reversed */\n          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);\n          if (leftMatch.length === 0) {\n            return [];\n          }\n          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);\n          if (rightMatch.length === 0) {\n            return [];\n          }\n          childMatches = [leftMatch, rightMatch];\n        }\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule\n        // matches for each of them and return their union.\n        var splits = getSplits(node, context);\n        var splitMatches = [];\n        for (var _i2 = 0; _i2 < splits.length; _i2++) {\n          var matchSet = _ruleMatch(rule, splits[_i2], context, true); // recursing at the same tree depth here\n          splitMatches = splitMatches.concat(matchSet);\n        }\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first one or two characters of the symbol node name.\n      // These meanings are expalined in the documentation for simplify()\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else {\n        // wildcards are composed of up to two alphabetic or underscore characters\n        switch (rule.name[1] >= 'a' && rule.name[1] <= 'z' ? rule.name.substring(0, 2) : rule.name[0]) {\n          case 'n':\n          case '_p':\n            // rule matches _anything_, so assign this node to the rule.name placeholder\n            // Assign node to the rule.name placeholder.\n            // Our parent will check for matches among placeholders.\n            res[0].placeholders[rule.name] = node;\n            break;\n          case 'c':\n          case 'cl':\n            // rule matches a ConstantNode\n            if (isConstantNode(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n            break;\n          case 'v':\n            // rule matches anything other than a ConstantNode\n            if (!isConstantNode(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n            break;\n          case 'vl':\n            // rule matches VariableNode\n            if (isVariableNode(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n            break;\n          case 'cd':\n            // rule matches a ConstantNode or unaryMinus-wrapped ConstantNode\n            if (isNumericNode(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n            break;\n          case 'vd':\n            // rule matches anything other than a ConstantNode or unaryMinus-wrapped ConstantNode\n            if (!isNumericNode(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n            break;\n          case 'ce':\n            // rule matches expressions that have a constant value\n            if (isConstantExpression(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n            break;\n          case 've':\n            // rule matches expressions that do not have a constant value\n            if (!isConstantExpression(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n            break;\n          default:\n            throw new Error('Invalid symbol in rule: ' + rule.name);\n        }\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    }\n\n    // It's a match!\n\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n    return res;\n  }\n\n  /**\n   * Determines whether p and q (and all their children nodes) are identical.\n   *\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\n   * @return {Object} Information about the match, if it exists.\n   */\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n    return true;\n  }\n  return simplify;\n});"],"names":[],"mappings":"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AAG;YACD,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QAAG;YACD,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QACA,+BAA+B;QAC/B;YACE,GAAG;YACH,UAAU;gBACR,QAAQ;oBACN,OAAO;gBACT;YACF,EAAE,iCAAiC;QACrC;QACA,kEAAkE;QAClE;YACE,GAAG;YACH,GAAG;QACL;QAAG;YACD,GAAG;YACH,UAAU;gBACR,QAAQ;oBACN,OAAO;gBACT;YACF,EAAE,6BAA6B;QACjC;QAAG;YACD,GAAG;YACH,UAAU;gBACR,QAAQ;oBACN,OAAO;gBACT;YACF;QACF;QAAG;YACD,GAAG;YACH,UAAU;gBACR,QAAQ;oBACN,OAAO;gBACT;YACF;QACF;QAAG;YACD,GAAG;YACH,GAAG;QACL;QAAG;YACD,GAAG;YACH,UAAU;gBACR,QAAQ;oBACN,OAAO;gBACT;YACF,EAAE,6BAA6B;QACjC;QAAG;YACD,GAAG;YACH,UAAU;gBACR,QAAQ;oBACN,OAAO;gBACT;YACF,EAAE,sBAAsB;QAC1B;QACA,iEAAiE;QACjE,mEAAmE;QACnE,oEAAoE;QACpE,8BAA8B;QAC9B;QACA,sCAAsC;QAEtC,qBAAqB;QACrB;YACE,GAAG;YACH,UAAU;gBACR,KAAK;oBACH,OAAO;gBACT;YACF,EAAE,2BAA2B;QAC/B;QAAG;YACD,GAAG;YACH,GAAG;QACL;QAAG;YACD,GAAG;YACH,GAAG;QACL;QACA,sCAAsC;QACtC;YACE,GAAG;YACH,GAAG;QACL;QACA,iCAAiC;QACjC;YACE,GAAG;YACH,GAAG;QACL;QAAG;YACD,GAAG;YACH,GAAG;QACL;QACA,gEAAgE;QAChE;YACE,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QAAG;YACD,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QAAG;YACD,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QAAG;YACD,GAAG;YACH,UAAU;gBACR,QAAQ;oBACN,OAAO;gBACT;gBACA,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QAAG;YACD,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QAAG;YACD,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QAAG;YACD,GAAG;YACH,GAAG;QACL;QAAG;YACD,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QAAG;YACD,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QAAG;QACH,0DAA0D;QAE1D,sEAAsE;QACtE;YACE,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,OAAO;gBACT;YACF;QACF;QAAG;YACD,GAAG;YACH,4BAA4B;YAC5B,UAAU;gBACR,UAAU;oBACR,OAAO;gBACT;gBACA,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QACA,8BAA8B;QAC9B;YACE,GAAG;YACH,UAAU;gBACR,KAAK;oBACH,aAAa;gBACf;YACF;YACA,eAAe;gBACb,KAAK;oBACH,aAAa;gBACf;YACF;QACF;QAAG;YACD,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF;YACA,eAAe;gBACb,UAAU;oBACR,aAAa;gBACf;YACF;QACF;QACA,uBAAuB;QACvB,gFAAgF;QAChF;YACE,GAAG;YACH,GAAG;QACL;QACA,0BAA0B;QAC1B;YACE,GAAG;YACH,GAAG;QACL;QAAG;YACD,GAAG;YACH,2CAA2C;YAC3C,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF,EAAE,0BAA0B;QAC9B;QAAG;YACD,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF,EAAE,0BAA0B;QAC9B;QAAG;YACD,GAAG;YACH,UAAU;gBACR,UAAU;oBACR,aAAa;gBACf;YACF,EAAE,0BAA0B;QAC9B;QAAG;YACD,GAAG;YACH,GAAG;QACL;QACA,wCAAwC;QACxC;YACE,GAAG;YACH,iBAAiB;YACjB,UAAU;gBACR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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5603, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js"],"sourcesContent":["import { isFraction, isMatrix, isNode, isArrayNode, isConstantNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { safeNumberType } from '../../utils/number.js';\nimport { createUtil } from './simplify/util.js';\nimport { noBignumber, noFraction } from '../../utils/noop.js';\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];\nexport var createSimplifyConstant = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    mathWithTransform,\n    matrix,\n    fraction,\n    bignumber,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref;\n  var {\n    isCommutative,\n    isAssociative,\n    allChildren,\n    createMakeNodeFunction\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n\n  /**\n   * simplifyConstant() takes a mathjs expression (either a Node representing\n   * a parse tree or a string which it parses to produce a node), and replaces\n   * any subexpression of it consisting entirely of constants with the computed\n   * value of that subexpression.\n   *\n   * Syntax:\n   *\n   *     math.simplifyConstant(expr)\n   *     math.simplifyConstant(expr, options)\n   *\n   * Examples:\n   *\n   *     math.simplifyConstant('x + 4*3/6')  // Node \"x + 2\"\n   *     math.simplifyConstant('z cos(0)')   // Node \"z 1\"\n   *     math.simplifyConstant('(5.2 + 1.08)t', {exactFractions: false})  // Node \"6.28 t\"\n   *\n   * See also:\n   *\n   *     simplify, simplifyCore, resolve, derivative\n   *\n   * @param {Node | string} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with constant subexpressions evaluated\n   */\n  var simplifyConstant = typed('simplifyConstant', {\n    Node: node => _ensureNode(foldFraction(node, {})),\n    'Node, Object': function Node_Object(expr, options) {\n      return _ensureNode(foldFraction(expr, options));\n    }\n  });\n  function _removeFractions(thing) {\n    if (isFraction(thing)) {\n      return thing.valueOf();\n    }\n    if (thing instanceof Array) {\n      return thing.map(_removeFractions);\n    }\n    if (isMatrix(thing)) {\n      return matrix(_removeFractions(thing.valueOf()));\n    }\n    return thing;\n  }\n  function _eval(fnname, args, options) {\n    try {\n      return mathWithTransform[fnname].apply(null, args);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(_removeFractions);\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    bigint: function bigint(n) {\n      if (n < 0n) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n);\n    },\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    },\n    string: function string(s) {\n      return new ConstantNode(s);\n    },\n    Matrix: function Matrix(m) {\n      return new ArrayNode(m.valueOf().map(e => _toNode(e)));\n    }\n  });\n  function _ensureNode(thing) {\n    if (isNode(thing)) {\n      return thing;\n    }\n    return _toNode(thing);\n  }\n\n  // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n    return n;\n  }\n\n  // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n  var _toNumber = typed({\n    'string, Object': function string_Object(s, options) {\n      var numericType = safeNumberType(s, config);\n      if (numericType === 'BigNumber') {\n        if (bignumber === undefined) {\n          noBignumber();\n        }\n        return bignumber(s);\n      } else if (numericType === 'bigint') {\n        return BigInt(s);\n      } else if (numericType === 'Fraction') {\n        if (fraction === undefined) {\n          noFraction();\n        }\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function Fraction_Object(s, options) {\n      return s;\n    },\n    // we don't need options here\n\n    'BigNumber, Object': function BigNumber_Object(s, options) {\n      return s;\n    },\n    // we don't need options here\n\n    'number, Object': function number_Object(s, options) {\n      return _exactFraction(s, options);\n    },\n    'bigint, Object': function bigint_Object(s, options) {\n      return s;\n    },\n    'Complex, Object': function Complex_Object(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n      return _exactFraction(s.re, options);\n    },\n    'Matrix, Object': function Matrix_Object(s, options) {\n      return matrix(_exactFraction(s.valueOf()));\n    },\n    'Array, Object': function Array_Object(s, options) {\n      return s.map(_exactFraction);\n    }\n  });\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n    if (f.d === 1) {\n      return n;\n    }\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n\n  /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */\n  function _foldAccessor(obj, index, options) {\n    if (!isIndexNode(index)) {\n      // don't know what to do with that...\n      return new AccessorNode(_ensureNode(obj), _ensureNode(index));\n    }\n    if (isArrayNode(obj) || isMatrix(obj)) {\n      var remainingDims = Array.from(index.dimensions);\n      /* We will resolve constant indices one at a time, looking\n       * just in the first or second dimensions because (a) arrays\n       * of more than two dimensions are likely rare, and (b) pulling\n       * out the third or higher dimension would be pretty intricate.\n       * The price is that we miss simplifying [..3d array][x,y,1]\n       */\n      while (remainingDims.length > 0) {\n        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {\n          var first = _toNumber(remainingDims.shift().value, options);\n          if (isArrayNode(obj)) {\n            obj = obj.items[first - 1];\n          } else {\n            // matrix\n            obj = obj.valueOf()[first - 1];\n            if (obj instanceof Array) {\n              obj = matrix(obj);\n            }\n          }\n        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {\n          var second = _toNumber(remainingDims[1].value, options);\n          var tryItems = [];\n          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();\n          for (var item of fromItems) {\n            if (isArrayNode(item)) {\n              tryItems.push(item.items[second - 1]);\n            } else if (isMatrix(obj)) {\n              tryItems.push(item[second - 1]);\n            } else {\n              break;\n            }\n          }\n          if (tryItems.length === fromItems.length) {\n            if (isArrayNode(obj)) {\n              obj = new ArrayNode(tryItems);\n            } else {\n              // matrix\n              obj = matrix(tryItems);\n            }\n            remainingDims.splice(1, 1);\n          } else {\n            // extracting slice along 2nd dimension failed, give up\n            break;\n          }\n        } else {\n          // neither 1st or 2nd dimension is constant, give up\n          break;\n        }\n      }\n      if (remainingDims.length === index.dimensions.length) {\n        /* No successful constant indexing */\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      if (remainingDims.length > 0) {\n        /* Indexed some but not all dimensions */\n        index = new IndexNode(remainingDims);\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      /* All dimensions were constant, access completely resolved */\n      return obj;\n    }\n    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {\n      var key = index.dimensions[0].value;\n      if (key in obj.properties) {\n        return obj.properties[key];\n      }\n      return new ConstantNode(); // undefined\n    }\n    /* Don't know how to index this sort of obj, at least not with this index */\n    return new AccessorNode(_ensureNode(obj), index);\n  }\n\n  /*\n   * Create a binary tree from a list of Fractions and Nodes.\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\n   * @param args - list of Fractions and Nodes\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\n   * if args.length is 1, returns args[0]\n   * @return - Either a Node representing a binary expression or Fraction\n   */\n  function foldOp(fn, args, makeNode, options) {\n    var first = args.shift();\n\n    // In the following reduction, sofar always has one of the three following\n    // forms: [NODE], [CONSTANT], or [NODE, CONSTANT]\n    var reduction = args.reduce((sofar, next) => {\n      if (!isNode(next)) {\n        var last = sofar.pop();\n        if (isNode(last)) {\n          return [last, next];\n        }\n        // Two constants in a row, try to fold them into one\n        try {\n          sofar.push(_eval(fn, [last, next], options));\n          return sofar;\n        } catch (ignoreandcontinue) {\n          sofar.push(last);\n          // fall through to Node case\n        }\n      }\n\n      // Encountered a Node, or failed folding --\n      // collapse everything so far into a single tree:\n      sofar.push(_ensureNode(sofar.pop()));\n      var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);\n      return [makeNode([newtree, _ensureNode(next)])];\n    }, [first]);\n    if (reduction.length === 1) {\n      return reduction[0];\n    }\n    // Might end up with a tree and a constant at the end:\n    return makeNode([reduction[0], _toNode(reduction[1])]);\n  }\n\n  // destroys the original node and returns a folded one\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n      case 'ConstantNode':\n        switch (typeof node.value) {\n          case 'number':\n            return _toNumber(node.value, options);\n          case 'bigint':\n            return _toNumber(node.value, options);\n          case 'string':\n            return node.value;\n          default:\n            if (!isNaN(node.value)) return _toNumber(node.value, options);\n        }\n        return node;\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n          if (!operatorFunctions.includes(node.name)) {\n            var args = node.args.map(arg => foldFraction(arg, options));\n\n            // If all args are numbers\n            if (!args.some(isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontinue) {}\n            }\n\n            // Size of a matrix does not depend on entries\n            if (node.name === 'size' && args.length === 1 && isArrayNode(args[0])) {\n              var sz = [];\n              var section = args[0];\n              while (isArrayNode(section)) {\n                sz.push(section.items.length);\n                section = section.items[0];\n              }\n              return matrix(sz);\n            }\n\n            // Convert all args to nodes and construct a symbolic function call\n            return new FunctionNode(node.name, args.map(_ensureNode));\n          } else {\n            // treat as operator\n          }\n        }\n      /* falls through */\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n          var _args;\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n          if (isOperatorNode(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n            if (!isNode(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node, options.context)) {\n            _args = allChildren(node, options.context);\n            _args = _args.map(arg => foldFraction(arg, options));\n            if (isCommutative(fn, options.context)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n              for (var i = 0; i < _args.length; i++) {\n                if (!isNode(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(arg => foldFraction(arg, options));\n            res = foldOp(fn, _args, makeNode, options);\n          }\n          return res;\n        }\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n      case 'AccessorNode':\n        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);\n      case 'ArrayNode':\n        {\n          var foldItems = node.items.map(item => foldFraction(item, options));\n          if (foldItems.some(isNode)) {\n            return new ArrayNode(foldItems.map(_ensureNode));\n          }\n          /* All literals -- return a Matrix so we can operate on it */\n          return matrix(foldItems);\n        }\n      case 'IndexNode':\n        {\n          return new IndexNode(node.dimensions.map(n => simplifyConstant(n, options)));\n        }\n      case 'ObjectNode':\n        {\n          var foldProps = {};\n          for (var prop in node.properties) {\n            foldProps[prop] = simplifyConstant(node.properties[prop], options);\n          }\n          return new ObjectNode(foldProps);\n        }\n      case 'AssignmentNode':\n      /* falls through */\n      case 'BlockNode':\n      /* falls through */\n      case 'FunctionAssignmentNode':\n      /* falls through */\n      case 'RangeNode':\n      /* falls through */\n      case 'ConditionalNode':\n      /* falls through */\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n  return simplifyConstant;\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6081, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js"],"sourcesContent":["import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\nimport { getOperator } from '../../expression/operators.js';\nimport { createUtil } from './simplify/util.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['typed', 'parse', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    parse,\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  var nodeT = new ConstantNode(true);\n  var nodeF = new ConstantNode(false);\n  // test if a node will always have a boolean value (true/false)\n  // not sure if this list is complete\n  function isAlwaysBoolean(node) {\n    return isOperatorNode(node) && ['and', 'not', 'or'].includes(node.op);\n  }\n  var {\n    hasProperty,\n    isCommutative\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. To roughly summarize,\n   * it handles cases along the lines of simplifyConstant() but where\n   * knowledge of a single argument is sufficient to determine the value.\n   * In contrast, simplify() extends simplifyCore() with additional passes\n   * to provide deeper simplification (such as gathering like terms).\n   *\n   * Specifically, simplifyCore:\n   *\n   * * Converts all function calls with operator equivalents to their\n   *   operator forms.\n   * * Removes operators or function calls that are guaranteed to have no\n   *   effect (such as unary '+').\n   * * Removes double unary '-', '~', and 'not'\n   * * Eliminates addition/subtraction of 0 and multiplication/division/powers\n   *   by 1 or 0.\n   * * Converts addition of a negation into subtraction.\n   * * Eliminates logical operations with constant true or false leading\n   *   arguments.\n   * * Puts constants on the left of a product, if multiplication is\n   *   considered commutative by the options (which is the default)\n   *\n   * Syntax:\n   *\n   *     math.simplifyCore(expr)\n   *     math.simplifyCore(expr, options)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (1 - 0)')\n   *     math.simplifyCore(f)                          // Node \"2 * x\"\n   *     math.simplify('2 * 1 * x ^ (1 - 0)', [math.simplifyCore]) // Node \"2 * x\"\n   *\n   * See also:\n   *\n   *     simplify, simplifyConstant, resolve, derivative\n   *\n   * @param {Node | string} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with basic simplifications applied\n   */\n  function _simplifyCore(nodeToSimplify) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var context = options ? options.context : undefined;\n    if (hasProperty(nodeToSimplify, 'trivial', context)) {\n      // This node does nothing if it has only one argument, so if so,\n      // return that argument simplified\n      if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {\n        return _simplifyCore(nodeToSimplify.args[0], options);\n      }\n      // For other node types, we try the generic methods\n      var simpChild = false;\n      var childCount = 0;\n      nodeToSimplify.forEach(c => {\n        ++childCount;\n        if (childCount === 1) {\n          simpChild = _simplifyCore(c, options);\n        }\n      });\n      if (childCount === 1) {\n        return simpChild;\n      }\n    }\n    var node = nodeToSimplify;\n    if (isFunctionNode(node)) {\n      var op = getOperator(node.name);\n      if (op) {\n        // Replace FunctionNode with a new OperatorNode\n        if (node.args.length > 2 && hasProperty(node, 'associative', context)) {\n          // unflatten into binary operations since that's what simplifyCore handles\n          while (node.args.length > 2) {\n            var last = node.args.pop();\n            var seclast = node.args.pop();\n            node.args.push(new OperatorNode(op, node.name, [last, seclast]));\n          }\n        }\n        node = new OperatorNode(op, node.name, node.args);\n      } else {\n        return new FunctionNode(_simplifyCore(node.fn), node.args.map(n => _simplifyCore(n, options)));\n      }\n    }\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = _simplifyCore(node.args[0], options);\n      if (node.op === '~') {\n        // bitwise not\n        if (isOperatorNode(a0) && a0.isUnary() && a0.op === '~') {\n          return a0.args[0];\n        }\n      }\n      if (node.op === 'not') {\n        // logical not\n        if (isOperatorNode(a0) && a0.isUnary() && a0.op === 'not') {\n          // Has the effect of turning the argument into a boolean\n          // So can only eliminate the double negation if\n          // the inside is already boolean\n          if (isAlwaysBoolean(a0.args[0])) {\n            return a0.args[0];\n          }\n        }\n      }\n      var finish = true;\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isBinary() && a0.fn === 'subtract') {\n            node = new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n            finish = false; // continue to process the new binary node\n          }\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          }\n        }\n      }\n      if (finish) return new OperatorNode(node.op, node.fn, [a0]);\n    }\n    if (isOperatorNode(node) && node.isBinary()) {\n      var _a = _simplifyCore(node.args[0], options);\n      var a1 = _simplifyCore(node.args[1], options);\n      if (node.op === '+') {\n        if (isConstantNode(_a) && isZero(_a.value)) {\n          return a1;\n        }\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          a1 = a1.args[0];\n          node = new OperatorNode('-', 'subtract', [_a, a1]);\n        }\n      }\n      if (node.op === '-') {\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return _simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);\n        }\n        if (isConstantNode(_a) && isZero(_a.value)) {\n          return _simplifyCore(new OperatorNode('-', 'unaryMinus', [a1]));\n        }\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n      if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          }\n        }\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          }\n          if (isCommutative(node, context)) {\n            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n          }\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      }\n      if (node.op === '/') {\n        if (isConstantNode(_a) && isZero(_a.value)) {\n          return node0;\n        }\n        if (isConstantNode(a1) && equal(a1.value, 1)) {\n          return _a;\n        }\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n      if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          }\n        }\n      }\n      if (node.op === 'and') {\n        if (isConstantNode(_a)) {\n          if (_a.value) {\n            if (isAlwaysBoolean(a1)) return a1;\n            if (isConstantNode(a1)) {\n              return a1.value ? nodeT : nodeF;\n            }\n          } else {\n            return nodeF;\n          }\n        }\n        if (isConstantNode(a1)) {\n          if (a1.value) {\n            if (isAlwaysBoolean(_a)) return _a;\n          } else {\n            return nodeF;\n          }\n        }\n      }\n      if (node.op === 'or') {\n        if (isConstantNode(_a)) {\n          if (_a.value) {\n            return nodeT;\n          } else {\n            if (isAlwaysBoolean(a1)) return a1;\n          }\n        }\n        if (isConstantNode(a1)) {\n          if (a1.value) {\n            return nodeT;\n          } else {\n            if (isAlwaysBoolean(_a)) return _a;\n          }\n        }\n      }\n      return new OperatorNode(node.op, node.fn, [_a, a1]);\n    }\n    if (isOperatorNode(node)) {\n      return new OperatorNode(node.op, node.fn, node.args.map(a => _simplifyCore(a, options)));\n    }\n    if (isArrayNode(node)) {\n      return new ArrayNode(node.items.map(n => _simplifyCore(n, options)));\n    }\n    if (isAccessorNode(node)) {\n      return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));\n    }\n    if (isIndexNode(node)) {\n      return new IndexNode(node.dimensions.map(n => _simplifyCore(n, options)));\n    }\n    if (isObjectNode(node)) {\n      var newProps = {};\n      for (var prop in node.properties) {\n        newProps[prop] = _simplifyCore(node.properties[prop], options);\n      }\n      return new ObjectNode(newProps);\n    }\n    // cannot simplify\n    return node;\n  }\n  return typed(name, {\n    Node: _simplifyCore,\n    'Node,Object': _simplifyCore\n  });\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6416, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/resolve.js"],"sourcesContent":["import { createMap } from '../../utils/map.js';\nimport { isFunctionNode, isNode, isOperatorNode, isParenthesisNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'resolve';\nvar dependencies = ['typed', 'parse', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode'];\nexport var createResolve = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    parse,\n    ConstantNode,\n    FunctionNode,\n    OperatorNode,\n    ParenthesisNode\n  } = _ref;\n  /**\n   * resolve(expr, scope) replaces variable nodes with their scoped values\n   *\n   * Syntax:\n   *\n   *     math.resolve(expr, scope)\n   *\n   * Examples:\n   *\n   *     math.resolve('x + y', {x:1, y:2})           // Node '1 + 2'\n   *     math.resolve(math.parse('x+y'), {x:1, y:2}) // Node '1 + 2'\n   *     math.simplify('x+y', {x:2, y: math.parse('x+x')}).toString() // \"6\"\n   *\n   * See also:\n   *\n   *     simplify, evaluate\n   *\n   * @param {Node | Node[]} node\n   *     The expression tree (or trees) to be simplified\n   * @param {Object} scope\n   *     Scope specifying variables to be resolved\n   * @return {Node | Node[]} Returns `node` with variables recursively substituted.\n   * @throws {ReferenceError}\n   *     If there is a cyclic dependency among the variables in `scope`,\n   *     resolution is impossible and a ReferenceError is thrown.\n   */\n  function _resolve(node, scope) {\n    var within = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    // note `within`:\n    // `within` is not documented, since it is for internal cycle\n    // detection only\n    if (!scope) {\n      return node;\n    }\n    if (isSymbolNode(node)) {\n      if (within.has(node.name)) {\n        var variables = Array.from(within).join(', ');\n        throw new ReferenceError(\"recursive loop of variable definitions among {\".concat(variables, \"}\"));\n      }\n      var value = scope.get(node.name);\n      if (isNode(value)) {\n        var nextWithin = new Set(within);\n        nextWithin.add(node.name);\n        return _resolve(value, scope, nextWithin);\n      } else if (typeof value === 'number') {\n        return parse(String(value));\n      } else if (value !== undefined) {\n        return new ConstantNode(value);\n      } else {\n        return node;\n      }\n    } else if (isOperatorNode(node)) {\n      var args = node.args.map(function (arg) {\n        return _resolve(arg, scope, within);\n      });\n      return new OperatorNode(node.op, node.fn, args, node.implicit);\n    } else if (isParenthesisNode(node)) {\n      return new ParenthesisNode(_resolve(node.content, scope, within));\n    } else if (isFunctionNode(node)) {\n      var _args = node.args.map(function (arg) {\n        return _resolve(arg, scope, within);\n      });\n      return new FunctionNode(node.name, _args);\n    }\n\n    // Otherwise just recursively resolve any children (might also work\n    // for some of the above special cases)\n    return node.map(child => _resolve(child, scope, within));\n  }\n  return typed('resolve', {\n    Node: _resolve,\n    'Node, Map | null | undefined': _resolve,\n    'Node, Object': (n, scope) => _resolve(n, createMap(scope)),\n    // For arrays and matrices, we map `self` rather than `_resolve`\n    // because resolve is fairly expensive anyway, and this way\n    // we get nice error messages if one entry in the array has wrong type.\n    'Array | Matrix': typed.referToSelf(self => A => A.map(n => self(n))),\n    'Array | Matrix, null | undefined': typed.referToSelf(self => A => A.map(n => self(n))),\n    'Array, Object': typed.referTo('Array,Map', selfAM => (A, scope) => selfAM(A, createMap(scope))),\n    'Matrix, Object': typed.referTo('Matrix,Map', selfMM => (A, scope) => selfMM(A, createMap(scope))),\n    'Array | Matrix, Map': typed.referToSelf(self => (A, scope) => A.map(n => self(n, scope)))\n  });\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6523, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js"],"sourcesContent":["import { isConstantNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'symbolicEqual';\nvar dependencies = ['parse', 'simplify', 'typed', 'OperatorNode'];\nexport var createSymbolicEqual = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    parse,\n    simplify,\n    typed,\n    OperatorNode\n  } = _ref;\n  /**\n   * Attempts to determine if two expressions are symbolically equal, i.e.\n   * one is the result of valid algebraic manipulations on the other.\n   * Currently, this simply checks if the difference of the two expressions\n   * simplifies down to 0. So there are two important caveats:\n   * 1. whether two expressions are symbolically equal depends on the\n   *     manipulations allowed. Therefore, this function takes an optional\n   *     third argument, which are the options that control the behavior\n   *     as documented for the `simplify()` function.\n   * 2. it is in general intractable to find the minimal simplification of\n   *     an arbitrarily complicated expression. So while a `true` value\n   *     of `symbolicEqual` ensures that the two expressions can be manipulated\n   *     to match each other, a `false` value does not absolutely rule this out.\n   *\n   * Syntax:\n   *\n   *     math.symbolicEqual(expr1, expr2)\n   *     math.symbolicEqual(expr1, expr2, options)\n   *\n   * Examples:\n   *\n   *     math.symbolicEqual('x*y', 'y*x') // Returns true\n   *     math.symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}}) // Returns false\n   *     math.symbolicEqual('x/y', '(y*x^(-1))^(-1)') // Returns true\n   *     math.symbolicEqual('abs(x)','x') // Returns false\n   *     math.symbolicEqual('abs(x)','x', simplify.positiveContext) // Returns true\n   *\n   * See also:\n   *\n   *     simplify, evaluate\n   *\n   * @param {Node|string} expr1  The first expression to compare\n   * @param {Node|string} expr2  The second expression to compare\n   * @param {Object} [options] Optional option object, passed to simplify\n   * @returns {boolean}\n   *     Returns true if a valid manipulation making the expressions equal\n   *     is found.\n   */\n  function _symbolicEqual(e1, e2) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var diff = new OperatorNode('-', 'subtract', [e1, e2]);\n    var simplified = simplify(diff, {}, options);\n    return isConstantNode(simplified) && !simplified.value;\n  }\n  return typed(name, {\n    'Node, Node': _symbolicEqual,\n    'Node, Node, Object': _symbolicEqual\n  });\n});"],"names":[],"mappings":";;;AAAA;AACA;;;AACA,IAAI,OAAO;AACX,IAAI,eAAe;IAAC;IAAS;IAAY;IAAS;CAAe;AAC1D,IAAI,sBAAsB,aAAa,GAAE,CAAA,GAAA,2JAAA,CAAA,UAAO,AAAD,EAAE,MAAM,cAAc,CAAA;IAC1E,IAAI,EACF,KAAK,EACL,QAAQ,EACR,KAAK,EACL,YAAY,EACb,GAAG;IACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCC,GACD,SAAS,eAAe,EAAE,EAAE,EAAE;QAC5B,IAAI,UAAU,UAAU,MAAM,GAAG,KAAK,SAAS,CAAC,EAAE,KAAK,YAAY,SAAS,CAAC,EAAE,GAAG,CAAC;QACnF,IAAI,OAAO,IAAI,aAAa,KAAK,YAAY;YAAC;YAAI;SAAG;QACrD,IAAI,aAAa,SAAS,MAAM,CAAC,GAAG;QACpC,OAAO,CAAA,GAAA,sJAAA,CAAA,iBAAc,AAAD,EAAE,eAAe,CAAC,WAAW,KAAK;IACxD;IACA,OAAO,MAAM,MAAM;QACjB,cAAc;QACd,sBAAsB;IACxB;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6596, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/derivative.js"],"sourcesContent":["import { isConstantNode, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { safeNumberType } from '../../utils/number.js';\nvar name = 'derivative';\nvar dependencies = ['typed', 'config', 'parse', 'simplify', 'equal', 'isZero', 'numeric', 'ConstantNode', 'FunctionNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createDerivative = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    parse,\n    simplify,\n    equal,\n    isZero,\n    numeric,\n    ConstantNode,\n    FunctionNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  /**\n   * Takes the derivative of an expression expressed in parser Nodes.\n   * The derivative will be taken over the supplied variable in the\n   * second parameter. If there are multiple variables in the expression,\n   * it will return a partial derivative.\n   *\n   * This uses rules of differentiation which can be found here:\n   *\n   * - [Differentiation rules (Wikipedia)](https://en.wikipedia.org/wiki/Differentiation_rules)\n   *\n   * Syntax:\n   *\n   *     math.derivative(expr, variable)\n   *     math.derivative(expr, variable, options)\n   *\n   * Examples:\n   *\n   *     math.derivative('x^2', 'x')                     // Node '2 * x'\n   *     math.derivative('x^2', 'x', {simplify: false})  // Node '2 * 1 * x ^ (2 - 1)'\n   *     math.derivative('sin(2x)', 'x'))                // Node '2 * cos(2 * x)'\n   *     math.derivative('2*x', 'x').evaluate()          // number 2\n   *     math.derivative('x^2', 'x').evaluate({x: 4})    // number 8\n   *     const f = math.parse('x^2')\n   *     const x = math.parse('x')\n   *     math.derivative(f, x)                           // Node {2 * x}\n   *\n   * See also:\n   *\n   *     simplify, parse, evaluate\n   *\n   * @param  {Node | string} expr           The expression to differentiate\n   * @param  {SymbolNode | string} variable The variable over which to differentiate\n   * @param  {{simplify: boolean}} [options]\n   *                         There is one option available, `simplify`, which\n   *                         is true by default. When false, output will not\n   *                         be simplified.\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\n   */\n  function plainDerivative(expr, variable) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      simplify: true\n    };\n    var constNodes = {};\n    constTag(constNodes, expr, variable.name);\n    var res = _derivative(expr, constNodes);\n    return options.simplify ? simplify(res) : res;\n  }\n  function parseIdentifier(string) {\n    var symbol = parse(string);\n    if (!symbol.isSymbolNode) {\n      throw new TypeError('Invalid variable. ' + \"Cannot parse \".concat(JSON.stringify(string), \" into a variable in function derivative\"));\n    }\n    return symbol;\n  }\n  var derivative = typed(name, {\n    'Node, SymbolNode': plainDerivative,\n    'Node, SymbolNode, Object': plainDerivative,\n    'Node, string': (node, symbol) => plainDerivative(node, parseIdentifier(symbol)),\n    'Node, string, Object': (node, symbol, options) => plainDerivative(node, parseIdentifier(symbol), options)\n\n    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}\n    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {\n      let res = expr\n      for (let i = 0; i < order; i++) {\n        let constNodes = {}\n        constTag(constNodes, expr, variable.name)\n        res = _derivative(res, constNodes)\n      }\n      return res\n    }\n    */\n  });\n  derivative._simplify = true;\n  derivative.toTex = function (deriv) {\n    return _derivTex.apply(null, deriv.args);\n  };\n\n  // FIXME: move the toTex method of derivative to latex.js. Difficulty is that it relies on parse.\n  // NOTE: the optional \"order\" parameter here is currently unused\n  var _derivTex = typed('_derivTex', {\n    'Node, SymbolNode': function Node_SymbolNode(expr, x) {\n      if (isConstantNode(expr) && typeOf(expr.value) === 'string') {\n        return _derivTex(parse(expr.value).toString(), x.toString(), 1);\n      } else {\n        return _derivTex(expr.toTex(), x.toString(), 1);\n      }\n    },\n    'Node, ConstantNode': function Node_ConstantNode(expr, x) {\n      if (typeOf(x.value) === 'string') {\n        return _derivTex(expr, parse(x.value));\n      } else {\n        throw new Error(\"The second parameter to 'derivative' is a non-string constant\");\n      }\n    },\n    'Node, SymbolNode, ConstantNode': function Node_SymbolNode_ConstantNode(expr, x, order) {\n      return _derivTex(expr.toString(), x.name, order.value);\n    },\n    'string, string, number': function string_string_number(expr, x, order) {\n      var d;\n      if (order === 1) {\n        d = '{d\\\\over d' + x + '}';\n      } else {\n        d = '{d^{' + order + '}\\\\over d' + x + '^{' + order + '}}';\n      }\n      return d + \"\\\\left[\".concat(expr, \"\\\\right]\");\n    }\n  });\n\n  /**\n   * Does a depth-first search on the expression tree to identify what Nodes\n   * are constants (e.g. 2 + 2), and stores the ones that are constants in\n   * constNodes. Classification is done as follows:\n   *\n   *   1. ConstantNodes are constants.\n   *   2. If there exists a SymbolNode, of which we are differentiating over,\n   *      in the subtree it is not constant.\n   *\n   * @param  {Object} constNodes  Holds the nodes that are constant\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {string} varName     Variable that we are differentiating\n   * @return {boolean}  if node is constant\n   */\n  // TODO: can we rewrite constTag into a pure function?\n  var constTag = typed('constTag', {\n    'Object, ConstantNode, string': function Object_ConstantNode_string(constNodes, node) {\n      constNodes[node] = true;\n      return true;\n    },\n    'Object, SymbolNode, string': function Object_SymbolNode_string(constNodes, node, varName) {\n      // Treat other variables like constants. For reasoning, see:\n      //   https://en.wikipedia.org/wiki/Partial_derivative\n      if (node.name !== varName) {\n        constNodes[node] = true;\n        return true;\n      }\n      return false;\n    },\n    'Object, ParenthesisNode, string': function Object_ParenthesisNode_string(constNodes, node, varName) {\n      return constTag(constNodes, node.content, varName);\n    },\n    'Object, FunctionAssignmentNode, string': function Object_FunctionAssignmentNode_string(constNodes, node, varName) {\n      if (!node.params.includes(varName)) {\n        constNodes[node] = true;\n        return true;\n      }\n      return constTag(constNodes, node.expr, varName);\n    },\n    'Object, FunctionNode | OperatorNode, string': function Object_FunctionNode__OperatorNode_string(constNodes, node, varName) {\n      if (node.args.length > 0) {\n        var isConst = constTag(constNodes, node.args[0], varName);\n        for (var i = 1; i < node.args.length; ++i) {\n          isConst = constTag(constNodes, node.args[i], varName) && isConst;\n        }\n        if (isConst) {\n          constNodes[node] = true;\n          return true;\n        }\n      }\n      return false;\n    }\n  });\n\n  /**\n   * Applies differentiation rules.\n   *\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\n   * @param  {Object} constNodes  Holds the nodes that are constant\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode}    The derivative of `expr`\n   */\n  var _derivative = typed('_derivative', {\n    'ConstantNode, Object': function ConstantNode_Object(node) {\n      return createConstantNode(0);\n    },\n    'SymbolNode, Object': function SymbolNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      return createConstantNode(1);\n    },\n    'ParenthesisNode, Object': function ParenthesisNode_Object(node, constNodes) {\n      return new ParenthesisNode(_derivative(node.content, constNodes));\n    },\n    'FunctionAssignmentNode, Object': function FunctionAssignmentNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      return _derivative(node.expr, constNodes);\n    },\n    'FunctionNode, Object': function FunctionNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      var arg0 = node.args[0];\n      var arg1;\n      var div = false; // is output a fraction?\n      var negative = false; // is output negative?\n\n      var funcDerivative;\n      switch (node.name) {\n        case 'cbrt':\n          // d/dx(cbrt(x)) = 1 / (3x^(2/3))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(3), new OperatorNode('^', 'pow', [arg0, new OperatorNode('/', 'divide', [createConstantNode(2), createConstantNode(3)])])]);\n          break;\n        case 'sqrt':\n        case 'nthRoot':\n          // d/dx(sqrt(x)) = 1 / (2*sqrt(x))\n          if (node.args.length === 1) {\n            div = true;\n            funcDerivative = new OperatorNode('*', 'multiply', [createConstantNode(2), new FunctionNode('sqrt', [arg0])]);\n          } else if (node.args.length === 2) {\n            // Rearrange from nthRoot(x, a) -> x^(1/a)\n            arg1 = new OperatorNode('/', 'divide', [createConstantNode(1), node.args[1]]);\n\n            // Is a variable?\n            constNodes[arg1] = constNodes[node.args[1]];\n            return _derivative(new OperatorNode('^', 'pow', [arg0, arg1]), constNodes);\n          }\n          break;\n        case 'log10':\n          arg1 = createConstantNode(10);\n        /* fall through! */\n        case 'log':\n          if (!arg1 && node.args.length === 1) {\n            // d/dx(log(x)) = 1 / x\n            funcDerivative = arg0.clone();\n            div = true;\n          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== undefined) {\n            // d/dx(log(x, c)) = 1 / (x*ln(c))\n            funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('log', [arg1 || node.args[1]])]);\n            div = true;\n          } else if (node.args.length === 2) {\n            // d/dx(log(f(x), g(x))) = d/dx(log(f(x)) / log(g(x)))\n            return _derivative(new OperatorNode('/', 'divide', [new FunctionNode('log', [arg0]), new FunctionNode('log', [node.args[1]])]), constNodes);\n          }\n          break;\n        case 'pow':\n          if (node.args.length === 2) {\n            constNodes[arg1] = constNodes[node.args[1]];\n            // Pass to pow operator node parser\n            return _derivative(new OperatorNode('^', 'pow', [arg0, node.args[1]]), constNodes);\n          }\n          break;\n        case 'exp':\n          // d/dx(e^x) = e^x\n          funcDerivative = new FunctionNode('exp', [arg0.clone()]);\n          break;\n        case 'sin':\n          // d/dx(sin(x)) = cos(x)\n          funcDerivative = new FunctionNode('cos', [arg0.clone()]);\n          break;\n        case 'cos':\n          // d/dx(cos(x)) = -sin(x)\n          funcDerivative = new OperatorNode('-', 'unaryMinus', [new FunctionNode('sin', [arg0.clone()])]);\n          break;\n        case 'tan':\n          // d/dx(tan(x)) = sec(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sec', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'sec':\n          // d/dx(sec(x)) = sec(x)tan(x)\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tan', [arg0.clone()])]);\n          break;\n        case 'csc':\n          // d/dx(csc(x)) = -csc(x)cot(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('cot', [arg0.clone()])]);\n          break;\n        case 'cot':\n          // d/dx(cot(x)) = -csc(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csc', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'asin':\n          // d/dx(asin(x)) = 1 / sqrt(1 - x^2)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n        case 'acos':\n          // d/dx(acos(x)) = -1 / sqrt(1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])]);\n          break;\n        case 'atan':\n          // d/dx(atan(x)) = 1 / (x^2 + 1)\n          div = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n        case 'asec':\n          // d/dx(asec(x)) = 1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n        case 'acsc':\n          // d/dx(acsc(x)) = -1 / (|x|*sqrt(x^2 - 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n        case 'acot':\n          // d/dx(acot(x)) = -1 / (x^2 + 1)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);\n          break;\n        case 'sinh':\n          // d/dx(sinh(x)) = cosh(x)\n          funcDerivative = new FunctionNode('cosh', [arg0.clone()]);\n          break;\n        case 'cosh':\n          // d/dx(cosh(x)) = sinh(x)\n          funcDerivative = new FunctionNode('sinh', [arg0.clone()]);\n          break;\n        case 'tanh':\n          // d/dx(tanh(x)) = sech(x)^2\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('sech', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'sech':\n          // d/dx(sech(x)) = -sech(x)tanh(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('tanh', [arg0.clone()])]);\n          break;\n        case 'csch':\n          // d/dx(csch(x)) = -csch(x)coth(x)\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [node, new FunctionNode('coth', [arg0.clone()])]);\n          break;\n        case 'coth':\n          // d/dx(coth(x)) = -csch(x)^2\n          negative = true;\n          funcDerivative = new OperatorNode('^', 'pow', [new FunctionNode('csch', [arg0.clone()]), createConstantNode(2)]);\n          break;\n        case 'asinh':\n          // d/dx(asinh(x)) = 1 / sqrt(x^2 + 1)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n        case 'acosh':\n          // d/dx(acosh(x)) = 1 / sqrt(x^2 - 1); XXX potentially only for x >= 1 (the real spectrum)\n          div = true;\n          funcDerivative = new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);\n          break;\n        case 'atanh':\n          // d/dx(atanh(x)) = 1 / (1 - x^2)\n          div = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n        case 'asech':\n          // d/dx(asech(x)) = -1 / (x*sqrt(1 - x^2))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [arg0.clone(), new FunctionNode('sqrt', [new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])])])]);\n          break;\n        case 'acsch':\n          // d/dx(acsch(x)) = -1 / (|x|*sqrt(x^2 + 1))\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('*', 'multiply', [new FunctionNode('abs', [arg0.clone()]), new FunctionNode('sqrt', [new OperatorNode('+', 'add', [new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);\n          break;\n        case 'acoth':\n          // d/dx(acoth(x)) = -1 / (1 - x^2)\n          div = true;\n          negative = true;\n          funcDerivative = new OperatorNode('-', 'subtract', [createConstantNode(1), new OperatorNode('^', 'pow', [arg0.clone(), createConstantNode(2)])]);\n          break;\n        case 'abs':\n          // d/dx(abs(x)) = abs(x)/x\n          funcDerivative = new OperatorNode('/', 'divide', [new FunctionNode(new SymbolNode('abs'), [arg0.clone()]), arg0.clone()]);\n          break;\n        case 'gamma': // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)\n        default:\n          throw new Error('Cannot process function \"' + node.name + '\" in derivative: ' + 'the function is not supported, undefined, or the number of arguments passed to it are not supported');\n      }\n      var op, func;\n      if (div) {\n        op = '/';\n        func = 'divide';\n      } else {\n        op = '*';\n        func = 'multiply';\n      }\n\n      /* Apply chain rule to all functions:\n         F(x)  = f(g(x))\n         F'(x) = g'(x)*f'(g(x)) */\n      var chainDerivative = _derivative(arg0, constNodes);\n      if (negative) {\n        chainDerivative = new OperatorNode('-', 'unaryMinus', [chainDerivative]);\n      }\n      return new OperatorNode(op, func, [chainDerivative, funcDerivative]);\n    },\n    'OperatorNode, Object': function OperatorNode_Object(node, constNodes) {\n      if (constNodes[node] !== undefined) {\n        return createConstantNode(0);\n      }\n      if (node.op === '+') {\n        // d/dx(sum(f(x)) = sum(f'(x))\n        return new OperatorNode(node.op, node.fn, node.args.map(function (arg) {\n          return _derivative(arg, constNodes);\n        }));\n      }\n      if (node.op === '-') {\n        // d/dx(+/-f(x)) = +/-f'(x)\n        if (node.isUnary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);\n        }\n\n        // Linearity of differentiation, d/dx(f(x) +/- g(x)) = f'(x) +/- g'(x)\n        if (node.isBinary()) {\n          return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);\n        }\n      }\n      if (node.op === '*') {\n        // d/dx(c*f(x)) = c*f'(x)\n        var constantTerms = node.args.filter(function (arg) {\n          return constNodes[arg] !== undefined;\n        });\n        if (constantTerms.length > 0) {\n          var nonConstantTerms = node.args.filter(function (arg) {\n            return constNodes[arg] === undefined;\n          });\n          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode('*', 'multiply', nonConstantTerms);\n          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));\n          return new OperatorNode('*', 'multiply', newArgs);\n        }\n\n        // Product Rule, d/dx(f(x)*g(x)) = f'(x)*g(x) + f(x)*g'(x)\n        return new OperatorNode('+', 'add', node.args.map(function (argOuter) {\n          return new OperatorNode('*', 'multiply', node.args.map(function (argInner) {\n            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();\n          }));\n        }));\n      }\n      if (node.op === '/' && node.isBinary()) {\n        var arg0 = node.args[0];\n        var arg1 = node.args[1];\n\n        // d/dx(f(x) / c) = f'(x) / c\n        if (constNodes[arg1] !== undefined) {\n          return new OperatorNode('/', 'divide', [_derivative(arg0, constNodes), arg1]);\n        }\n\n        // Reciprocal Rule, d/dx(c / f(x)) = -c(f'(x)/f(x)^2)\n        if (constNodes[arg0] !== undefined) {\n          return new OperatorNode('*', 'multiply', [new OperatorNode('-', 'unaryMinus', [arg0]), new OperatorNode('/', 'divide', [_derivative(arg1, constNodes), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])])]);\n        }\n\n        // Quotient rule, d/dx(f(x) / g(x)) = (f'(x)g(x) - f(x)g'(x)) / g(x)^2\n        return new OperatorNode('/', 'divide', [new OperatorNode('-', 'subtract', [new OperatorNode('*', 'multiply', [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode('*', 'multiply', [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode('^', 'pow', [arg1.clone(), createConstantNode(2)])]);\n      }\n      if (node.op === '^' && node.isBinary()) {\n        var _arg = node.args[0];\n        var _arg2 = node.args[1];\n        if (constNodes[_arg] !== undefined) {\n          // If is secretly constant; 0^f(x) = 1 (in JS), 1^f(x) = 1\n          if (isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {\n            return createConstantNode(0);\n          }\n\n          // d/dx(c^f(x)) = c^f(x)*ln(c)*f'(x)\n          return new OperatorNode('*', 'multiply', [node, new OperatorNode('*', 'multiply', [new FunctionNode('log', [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);\n        }\n        if (constNodes[_arg2] !== undefined) {\n          if (isConstantNode(_arg2)) {\n            // If is secretly constant; f(x)^0 = 1 -> d/dx(1) = 0\n            if (isZero(_arg2.value)) {\n              return createConstantNode(0);\n            }\n            // Ignore exponent; f(x)^1 = f(x)\n            if (equal(_arg2.value, 1)) {\n              return _derivative(_arg, constNodes);\n            }\n          }\n\n          // Elementary Power Rule, d/dx(f(x)^c) = c*f'(x)*f(x)^(c-1)\n          var powMinusOne = new OperatorNode('^', 'pow', [_arg.clone(), new OperatorNode('-', 'subtract', [_arg2, createConstantNode(1)])]);\n          return new OperatorNode('*', 'multiply', [_arg2.clone(), new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), powMinusOne])]);\n        }\n\n        // Functional Power Rule, d/dx(f^g) = f^g*[f'*(g/f) + g'ln(f)]\n        return new OperatorNode('*', 'multiply', [new OperatorNode('^', 'pow', [_arg.clone(), _arg2.clone()]), new OperatorNode('+', 'add', [new OperatorNode('*', 'multiply', [_derivative(_arg, constNodes), new OperatorNode('/', 'divide', [_arg2.clone(), _arg.clone()])]), new OperatorNode('*', 'multiply', [_derivative(_arg2, constNodes), new FunctionNode('log', [_arg.clone()])])])]);\n      }\n      throw new Error('Cannot process operator \"' + node.op + '\" in derivative: ' + 'the operator is not supported, undefined, or the number of arguments passed to it are not supported');\n    }\n  });\n\n  /**\n   * Helper function to create a constant node with a specific type\n   * (number, BigNumber, Fraction)\n   * @param {number} value\n   * @param {string} [valueType]\n   * @return {ConstantNode}\n   */\n  function createConstantNode(value, valueType) {\n    return new ConstantNode(numeric(value, valueType || safeNumberType(String(value), config)));\n  }\n  return derivative;\n});"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7371, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Projects/Offline%20Excel/node_modules/mathjs/lib/esm/function/algebra/rationalize.js"],"sourcesContent":["import { isInteger } from '../../utils/number.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'rationalize';\nvar dependencies = ['config', 'typed', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'parse', 'simplifyConstant', 'simplifyCore', 'simplify', '?bignumber', '?fraction', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode', 'ParenthesisNode'];\nexport var createRationalize = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    parse,\n    simplifyConstant,\n    simplifyCore,\n    simplify,\n    fraction,\n    bignumber,\n    mathWithTransform,\n    matrix,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    SymbolNode,\n    ParenthesisNode\n  } = _ref;\n  /**\n   * Transform a rationalizable expression in a rational fraction.\n   * If rational fraction is one variable polynomial then converts\n   * the numerator and denominator in canonical form, with decreasing\n   * exponents, returning the coefficients of numerator.\n   *\n   * Syntax:\n   *\n   *     math.rationalize(expr)\n   *     math.rationalize(expr, detailed)\n   *     math.rationalize(expr, scope)\n   *     math.rationalize(expr, scope, detailed)\n   *\n   * Examples:\n   *\n   *     math.rationalize('sin(x)+y')\n   *                   //  Error: There is an unsolved function call\n   *     math.rationalize('2x/y - y/(x+1)')\n   *                   // (2*x^2-y^2+2*x)/(x*y+y)\n   *     math.rationalize('(2x+1)^6')\n   *                   // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1\n   *     math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')\n   *                   // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)\n   *     math.rationalize('x/(1-x)/(x-2)/(x-3)/(x-4) + 2x/ ( (1-2x)/(2-3x) )/ ((3-4x)/(4-5x) )') =\n   *                   // (-30*x^7+344*x^6-1506*x^5+3200*x^4-3472*x^3+1846*x^2-381*x)/\n   *                   //     (-8*x^6+90*x^5-383*x^4+780*x^3-797*x^2+390*x-72)\n   *\n   *     math.rationalize('x+x+x+y',{y:1}) // 3*x+1\n   *     math.rationalize('x+x+x+y',{})    // 3*x+y\n   *\n   *     const ret = math.rationalize('x+x+x+y',{},true)\n   *                   // ret.expression=3*x+y, ret.variables = [\"x\",\"y\"]\n   *     const ret = math.rationalize('-2+5x^2',{},true)\n   *                   // ret.expression=5*x^2-2, ret.variables = [\"x\"], ret.coefficients=[-2,0,5]\n   *\n   * See also:\n   *\n   *     simplify\n   *\n   * @param  {Node|string} expr    The expression to check if is a polynomial expression\n   * @param  {Object|boolean}      optional scope of expression or true for already evaluated rational expression at input\n   * @param  {Boolean}  detailed   optional True if return an object, false if return expression node (default)\n   *\n   * @return {Object | Node}    The rational polynomial of `expr` or an object\n   *            `{expression, numerator, denominator, variables, coefficients}`, where\n   *              `expression` is a `Node` with the node simplified expression,\n   *              `numerator` is a `Node` with the simplified numerator of expression,\n   *              `denominator` is a `Node` or `boolean` with the simplified denominator or `false` (if there is no denominator),\n   *              `variables` is an array with variable names,\n   *              and `coefficients` is an array with coefficients of numerator sorted by increased exponent\n   *           {Expression Node}  node simplified expression\n   *\n   */\n  function _rationalize(expr) {\n    var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var detailed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var setRules = rulesRationalize(); // Rules for change polynomial in near canonical form\n    var polyRet = polynomial(expr, scope, true, setRules.firstRules); // Check if expression is a rationalizable polynomial\n    var nVars = polyRet.variables.length;\n    var noExactFractions = {\n      exactFractions: false\n    };\n    var withExactFractions = {\n      exactFractions: true\n    };\n    expr = polyRet.expression;\n    if (nVars >= 1) {\n      // If expression in not a constant\n      expr = expandPower(expr); // First expand power of polynomials (cannot be made from rules!)\n      var sBefore; // Previous expression\n      var rules;\n      var eDistrDiv = true;\n      var redoInic = false;\n      // Apply the initial rules, including succ div rules:\n      expr = simplify(expr, setRules.firstRules, {}, noExactFractions);\n      var s;\n      while (true) {\n        // Alternate applying successive division rules and distr.div.rules\n        // until there are no more changes:\n        rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;\n        expr = simplify(expr, rules, {}, withExactFractions);\n        eDistrDiv = !eDistrDiv; // Swap between Distr.Div and Succ. Div. Rules\n\n        s = expr.toString();\n        if (s === sBefore) {\n          break; // No changes : end of the loop\n        }\n        redoInic = true;\n        sBefore = s;\n      }\n      if (redoInic) {\n        // Apply first rules again without succ div rules (if there are changes)\n        expr = simplify(expr, setRules.firstRulesAgain, {}, noExactFractions);\n      }\n      // Apply final rules:\n      expr = simplify(expr, setRules.finalRules, {}, noExactFractions);\n    } // NVars >= 1\n\n    var coefficients = [];\n    var retRationalize = {};\n    if (expr.type === 'OperatorNode' && expr.isBinary() && expr.op === '/') {\n      // Separate numerator from denominator\n      if (nVars === 1) {\n        expr.args[0] = polyToCanonical(expr.args[0], coefficients);\n        expr.args[1] = polyToCanonical(expr.args[1]);\n      }\n      if (detailed) {\n        retRationalize.numerator = expr.args[0];\n        retRationalize.denominator = expr.args[1];\n      }\n    } else {\n      if (nVars === 1) {\n        expr = polyToCanonical(expr, coefficients);\n      }\n      if (detailed) {\n        retRationalize.numerator = expr;\n        retRationalize.denominator = null;\n      }\n    }\n    // nVars\n\n    if (!detailed) return expr;\n    retRationalize.coefficients = coefficients;\n    retRationalize.variables = polyRet.variables;\n    retRationalize.expression = expr;\n    return retRationalize;\n  }\n  return typed(name, {\n    Node: _rationalize,\n    'Node, boolean': (expr, detailed) => _rationalize(expr, {}, detailed),\n    'Node, Object': _rationalize,\n    'Node, Object, boolean': _rationalize\n  }); // end of typed rationalize\n\n  /**\n   *  Function to simplify an expression using an optional scope and\n   *  return it if the expression is a polynomial expression, i.e.\n   *  an expression with one or more variables and the operators\n   *  +, -, *, and ^, where the exponent can only be a positive integer.\n   *\n   * Syntax:\n   *\n   *     polynomial(expr,scope,extended, rules)\n   *\n   * @param  {Node | string} expr     The expression to simplify and check if is polynomial expression\n   * @param  {object} scope           Optional scope for expression simplification\n   * @param  {boolean} extended       Optional. Default is false. When true allows divide operator.\n   * @param  {array}  rules           Optional. Default is no rule.\n   *\n   *\n   * @return {Object}\n   *            {Object} node:   node simplified expression\n   *            {Array}  variables:  variable names\n   */\n  function polynomial(expr, scope, extended, rules) {\n    var variables = [];\n    var node = simplify(expr, rules, scope, {\n      exactFractions: false\n    }); // Resolves any variables and functions with all defined parameters\n    extended = !!extended;\n    var oper = '+-*' + (extended ? '/' : '');\n    recPoly(node);\n    var retFunc = {};\n    retFunc.expression = node;\n    retFunc.variables = variables;\n    return retFunc;\n\n    // -------------------------------------------------------------------------------------------------------\n\n    /**\n     *  Function to simplify an expression using an optional scope and\n     *  return it if the expression is a polynomial expression, i.e.\n     *  an expression with one or more variables and the operators\n     *  +, -, *, and ^, where the exponent can only be a positive integer.\n     *\n     * Syntax:\n     *\n     *     recPoly(node)\n     *\n     *\n     * @param  {Node} node               The current sub tree expression in recursion\n     *\n     * @return                           nothing, throw an exception if error\n     */\n    function recPoly(node) {\n      var tp = node.type; // node type\n      if (tp === 'FunctionNode') {\n        // No function call in polynomial expression\n        throw new Error('There is an unsolved function call');\n      } else if (tp === 'OperatorNode') {\n        if (node.op === '^') {\n          // TODO: handle negative exponents like in '1/x^(-2)'\n          if (node.args[1].type !== 'ConstantNode' || !isInteger(parseFloat(node.args[1].value))) {\n            throw new Error('There is a non-integer exponent');\n          } else {\n            recPoly(node.args[0]);\n          }\n        } else {\n          if (!oper.includes(node.op)) {\n            throw new Error('Operator ' + node.op + ' invalid in polynomial expression');\n          }\n          for (var i = 0; i < node.args.length; i++) {\n            recPoly(node.args[i]);\n          }\n        } // type of operator\n      } else if (tp === 'SymbolNode') {\n        var _name = node.name; // variable name\n        var pos = variables.indexOf(_name);\n        if (pos === -1) {\n          // new variable in expression\n          variables.push(_name);\n        }\n      } else if (tp === 'ParenthesisNode') {\n        recPoly(node.content);\n      } else if (tp !== 'ConstantNode') {\n        throw new Error('type ' + tp + ' is not allowed in polynomial expression');\n      }\n    } // end of recPoly\n  } // end of polynomial\n\n  // ---------------------------------------------------------------------------------------\n  /**\n   * Return a rule set to rationalize an polynomial expression in rationalize\n   *\n   * Syntax:\n   *\n   *     rulesRationalize()\n   *\n   * @return {array}        rule set to rationalize an polynomial expression\n   */\n  function rulesRationalize() {\n    var oldRules = [simplifyCore,\n    // sCore\n    {\n      l: 'n+n',\n      r: '2*n'\n    }, {\n      l: 'n+-n',\n      r: '0'\n    }, simplifyConstant,\n    // sConstant\n    {\n      l: 'n*(n1^-1)',\n      r: 'n/n1'\n    }, {\n      l: 'n*n1^-n2',\n      r: 'n/n1^n2'\n    }, {\n      l: 'n1^-1',\n      r: '1/n1'\n    }, {\n      l: 'n*(n1/n2)',\n      r: '(n*n1)/n2'\n    }, {\n      l: '1*n',\n      r: 'n'\n    }];\n    var rulesFirst = [{\n      l: '(-n1)/(-n2)',\n      r: 'n1/n2'\n    },\n    // Unary division\n    {\n      l: '(-n1)*(-n2)',\n      r: 'n1*n2'\n    },\n    // Unary multiplication\n    {\n      l: 'n1--n2',\n      r: 'n1+n2'\n    },\n    // '--' elimination\n    {\n      l: 'n1-n2',\n      r: 'n1+(-n2)'\n    },\n    // Subtraction turn into add with un�ry minus\n    {\n      l: '(n1+n2)*n3',\n      r: '(n1*n3 + n2*n3)'\n    },\n    // Distributive 1\n    {\n      l: 'n1*(n2+n3)',\n      r: '(n1*n2+n1*n3)'\n    },\n    // Distributive 2\n    {\n      l: 'c1*n + c2*n',\n      r: '(c1+c2)*n'\n    },\n    // Joining constants\n    {\n      l: 'c1*n + n',\n      r: '(c1+1)*n'\n    },\n    // Joining constants\n    {\n      l: 'c1*n - c2*n',\n      r: '(c1-c2)*n'\n    },\n    // Joining constants\n    {\n      l: 'c1*n - n',\n      r: '(c1-1)*n'\n    },\n    // Joining constants\n    {\n      l: 'v/c',\n      r: '(1/c)*v'\n    },\n    // variable/constant (new!)\n    {\n      l: 'v/-c',\n      r: '-(1/c)*v'\n    },\n    // variable/constant (new!)\n    {\n      l: '-v*-c',\n      r: 'c*v'\n    },\n    // Inversion constant and variable 1\n    {\n      l: '-v*c',\n      r: '-c*v'\n    },\n    // Inversion constant and variable 2\n    {\n      l: 'v*-c',\n      r: '-c*v'\n    },\n    // Inversion constant and variable 3\n    {\n      l: 'v*c',\n      r: 'c*v'\n    },\n    // Inversion constant and variable 4\n    {\n      l: '-(-n1*n2)',\n      r: '(n1*n2)'\n    },\n    // Unary propagation\n    {\n      l: '-(n1*n2)',\n      r: '(-n1*n2)'\n    },\n    // Unary propagation\n    {\n      l: '-(-n1+n2)',\n      r: '(n1-n2)'\n    },\n    // Unary propagation\n    {\n      l: '-(n1+n2)',\n      r: '(-n1-n2)'\n    },\n    // Unary propagation\n    {\n      l: '(n1^n2)^n3',\n      r: '(n1^(n2*n3))'\n    },\n    // Power to Power\n    {\n      l: '-(-n1/n2)',\n      r: '(n1/n2)'\n    },\n    // Division and Unary\n    {\n      l: '-(n1/n2)',\n      r: '(-n1/n2)'\n    }]; // Divisao and Unary\n\n    var rulesDistrDiv = [{\n      l: '(n1/n2 + n3/n4)',\n      r: '((n1*n4 + n3*n2)/(n2*n4))'\n    },\n    // Sum of fractions\n    {\n      l: '(n1/n2 + n3)',\n      r: '((n1 + n3*n2)/n2)'\n    },\n    // Sum fraction with number 1\n    {\n      l: '(n1 + n2/n3)',\n      r: '((n1*n3 + n2)/n3)'\n    }]; // Sum fraction with number 1\n\n    var rulesSucDiv = [{\n      l: '(n1/(n2/n3))',\n      r: '((n1*n3)/n2)'\n    },\n    // Division simplification\n    {\n      l: '(n1/n2/n3)',\n      r: '(n1/(n2*n3))'\n    }];\n    var setRules = {}; // rules set in 4 steps.\n\n    // All rules => infinite loop\n    // setRules.allRules =oldRules.concat(rulesFirst,rulesDistrDiv,rulesSucDiv)\n\n    setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv); // First rule set\n    setRules.distrDivRules = rulesDistrDiv; // Just distr. div. rules\n    setRules.sucDivRules = rulesSucDiv; // Jus succ. div. rules\n    setRules.firstRulesAgain = oldRules.concat(rulesFirst); // Last rules set without succ. div.\n\n    // Division simplification\n\n    // Second rule set.\n    // There is no aggregate expression with parentesis, but the only variable can be scattered.\n    setRules.finalRules = [simplifyCore,\n    // simplify.rules[0]\n    {\n      l: 'n*-n',\n      r: '-n^2'\n    },\n    // Joining multiply with power 1\n    {\n      l: 'n*n',\n      r: 'n^2'\n    },\n    // Joining multiply with power 2\n    simplifyConstant,\n    // simplify.rules[14] old 3rd index in oldRules\n    {\n      l: 'n*-n^n1',\n      r: '-n^(n1+1)'\n    },\n    // Joining multiply with power 3\n    {\n      l: 'n*n^n1',\n      r: 'n^(n1+1)'\n    },\n    // Joining multiply with power 4\n    {\n      l: 'n^n1*-n^n2',\n      r: '-n^(n1+n2)'\n    },\n    // Joining multiply with power 5\n    {\n      l: 'n^n1*n^n2',\n      r: 'n^(n1+n2)'\n    },\n    // Joining multiply with power 6\n    {\n      l: 'n^n1*-n',\n      r: '-n^(n1+1)'\n    },\n    // Joining multiply with power 7\n    {\n      l: 'n^n1*n',\n      r: 'n^(n1+1)'\n    },\n    // Joining multiply with power 8\n    {\n      l: 'n^n1/-n',\n      r: '-n^(n1-1)'\n    },\n    // Joining multiply with power 8\n    {\n      l: 'n^n1/n',\n      r: 'n^(n1-1)'\n    },\n    // Joining division with power 1\n    {\n      l: 'n/-n^n1',\n      r: '-n^(1-n1)'\n    },\n    // Joining division with power 2\n    {\n      l: 'n/n^n1',\n      r: 'n^(1-n1)'\n    },\n    // Joining division with power 3\n    {\n      l: 'n^n1/-n^n2',\n      r: 'n^(n1-n2)'\n    },\n    // Joining division with power 4\n    {\n      l: 'n^n1/n^n2',\n      r: 'n^(n1-n2)'\n    },\n    // Joining division with power 5\n    {\n      l: 'n1+(-n2*n3)',\n      r: 'n1-n2*n3'\n    },\n    // Solving useless parenthesis 1\n    {\n      l: 'v*(-c)',\n      r: '-c*v'\n    },\n    // Solving useless unary 2\n    {\n      l: 'n1+-n2',\n      r: 'n1-n2'\n    },\n    // Solving +- together (new!)\n    {\n      l: 'v*c',\n      r: 'c*v'\n    },\n    // inversion constant with variable\n    {\n      l: '(n1^n2)^n3',\n      r: '(n1^(n2*n3))'\n    } // Power to Power\n    ];\n    return setRules;\n  } // End rulesRationalize\n\n  // ---------------------------------------------------------------------------------------\n  /**\n   *  Expand recursively a tree node for handling with expressions with exponents\n   *  (it's not for constants, symbols or functions with exponents)\n   *  PS: The other parameters are internal for recursion\n   *\n   * Syntax:\n   *\n   *     expandPower(node)\n   *\n   * @param  {Node} node         Current expression node\n   * @param  {node} parent       Parent current node inside the recursion\n   * @param  (int}               Parent number of chid inside the rercursion\n   *\n   * @return {node}        node expression with all powers expanded.\n   */\n  function expandPower(node, parent, indParent) {\n    var tp = node.type;\n    var internal = arguments.length > 1; // TRUE in internal calls\n\n    if (tp === 'OperatorNode' && node.isBinary()) {\n      var does = false;\n      var val;\n      if (node.op === '^') {\n        // First operator: Parenthesis or UnaryMinus\n        if ((node.args[0].type === 'ParenthesisNode' || node.args[0].type === 'OperatorNode') && node.args[1].type === 'ConstantNode') {\n          // Second operator: Constant\n          val = parseFloat(node.args[1].value);\n          does = val >= 2 && isInteger(val);\n        }\n      }\n      if (does) {\n        // Exponent >= 2\n        // Before:\n        //            operator A --> Subtree\n        // parent pow\n        //            constant\n        //\n        if (val > 2) {\n          // Exponent > 2,\n          // AFTER:  (exponent > 2)\n          //             operator A --> Subtree\n          // parent  *\n          //                 deep clone (operator A --> Subtree\n          //             pow\n          //                 constant - 1\n          //\n          var nEsqTopo = node.args[0];\n          var nDirTopo = new OperatorNode('^', 'pow', [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);\n          node = new OperatorNode('*', 'multiply', [nEsqTopo, nDirTopo]);\n        } else {\n          // Expo = 2 - no power\n          // AFTER:  (exponent =  2)\n          //             operator A --> Subtree\n          // parent   oper\n          //            deep clone (operator A --> Subtree)\n          //\n          node = new OperatorNode('*', 'multiply', [node.args[0], node.args[0].cloneDeep()]);\n        }\n        if (internal) {\n          // Change parent references in internal recursive calls\n          if (indParent === 'content') {\n            parent.content = node;\n          } else {\n            parent.args[indParent] = node;\n          }\n        }\n      } // does\n    } // binary OperatorNode\n\n    if (tp === 'ParenthesisNode') {\n      // Recursion\n      expandPower(node.content, node, 'content');\n    } else if (tp !== 'ConstantNode' && tp !== 'SymbolNode') {\n      for (var i = 0; i < node.args.length; i++) {\n        expandPower(node.args[i], node, i);\n      }\n    }\n    if (!internal) {\n      // return the root node\n      return node;\n    }\n  } // End expandPower\n\n  // ---------------------------------------------------------------------------------------\n  /**\n   * Auxilary function for rationalize\n   * Convert near canonical polynomial in one variable in a canonical polynomial\n   * with one term for each exponent in decreasing order\n   *\n   * Syntax:\n   *\n   *     polyToCanonical(node [, coefficients])\n   *\n   * @param  {Node | string} expr       The near canonical polynomial expression to convert in a a canonical polynomial expression\n   *\n   *        The string or tree expression needs to be at below syntax, with free spaces:\n   *         (  (^(-)? | [+-]? )cte (*)? var (^expo)?  | cte )+\n   *       Where 'var' is one variable with any valid name\n   *             'cte' are real numeric constants with any value. It can be omitted if equal than 1\n   *             'expo' are integers greater than 0. It can be omitted if equal than 1.\n   *\n   * @param  {array}   coefficients             Optional returns coefficients sorted by increased exponent\n   *\n   *\n   * @return {node}        new node tree with one variable polynomial or string error.\n   */\n  function polyToCanonical(node, coefficients) {\n    if (coefficients === undefined) {\n      coefficients = [];\n    } // coefficients.\n\n    coefficients[0] = 0; // index is the exponent\n    var o = {};\n    o.cte = 1;\n    o.oper = '+';\n\n    // fire: mark with * or ^ when finds * or ^ down tree, reset to \"\" with + and -.\n    //       It is used to deduce the exponent: 1 for *, 0 for \"\".\n    o.fire = '';\n    var maxExpo = 0; // maximum exponent\n    var varname = ''; // variable name\n\n    recurPol(node, null, o);\n    maxExpo = coefficients.length - 1;\n    var first = true;\n    var no;\n    for (var i = maxExpo; i >= 0; i--) {\n      if (coefficients[i] === 0) continue;\n      var n1 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));\n      var op = coefficients[i] < 0 ? '-' : '+';\n      if (i > 0) {\n        // Is not a constant without variable\n        var n2 = new SymbolNode(varname);\n        if (i > 1) {\n          var n3 = new ConstantNode(i);\n          n2 = new OperatorNode('^', 'pow', [n2, n3]);\n        }\n        if (coefficients[i] === -1 && first) {\n          n1 = new OperatorNode('-', 'unaryMinus', [n2]);\n        } else if (Math.abs(coefficients[i]) === 1) {\n          n1 = n2;\n        } else {\n          n1 = new OperatorNode('*', 'multiply', [n1, n2]);\n        }\n      }\n      if (first) {\n        no = n1;\n      } else if (op === '+') {\n        no = new OperatorNode('+', 'add', [no, n1]);\n      } else {\n        no = new OperatorNode('-', 'subtract', [no, n1]);\n      }\n      first = false;\n    } // for\n\n    if (first) {\n      return new ConstantNode(0);\n    } else {\n      return no;\n    }\n\n    /**\n     * Recursive auxilary function inside polyToCanonical for\n     * converting expression in canonical form\n     *\n     * Syntax:\n     *\n     *     recurPol(node, noPai, obj)\n     *\n     * @param  {Node} node        The current subpolynomial expression\n     * @param  {Node | Null}  noPai   The current parent node\n     * @param  {object}    obj        Object with many internal flags\n     *\n     * @return {}                    No return. If error, throws an exception\n     */\n    function recurPol(node, noPai, o) {\n      var tp = node.type;\n      if (tp === 'FunctionNode') {\n        // ***** FunctionName *****\n        // No function call in polynomial expression\n        throw new Error('There is an unsolved function call');\n      } else if (tp === 'OperatorNode') {\n        // ***** OperatorName *****\n        if (!'+-*^'.includes(node.op)) throw new Error('Operator ' + node.op + ' invalid');\n        if (noPai !== null) {\n          // -(unary),^  : children of *,+,-\n          if ((node.fn === 'unaryMinus' || node.fn === 'pow') && noPai.fn !== 'add' && noPai.fn !== 'subtract' && noPai.fn !== 'multiply') {\n            throw new Error('Invalid ' + node.op + ' placing');\n          }\n\n          // -,+,* : children of +,-\n          if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'multiply') && noPai.fn !== 'add' && noPai.fn !== 'subtract') {\n            throw new Error('Invalid ' + node.op + ' placing');\n          }\n\n          // -,+ : first child\n          if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'unaryMinus') && o.noFil !== 0) {\n            throw new Error('Invalid ' + node.op + ' placing');\n          }\n        } // Has parent\n\n        // Firers: ^,*       Old:   ^,&,-(unary): firers\n        if (node.op === '^' || node.op === '*') {\n          o.fire = node.op;\n        }\n        for (var _i = 0; _i < node.args.length; _i++) {\n          // +,-: reset fire\n          if (node.fn === 'unaryMinus') o.oper = '-';\n          if (node.op === '+' || node.fn === 'subtract') {\n            o.fire = '';\n            o.cte = 1; // default if there is no constant\n            o.oper = _i === 0 ? '+' : node.op;\n          }\n          o.noFil = _i; // number of son\n          recurPol(node.args[_i], node, o);\n        } // for in children\n      } else if (tp === 'SymbolNode') {\n        // ***** SymbolName *****\n        if (node.name !== varname && varname !== '') {\n          throw new Error('There is more than one variable');\n        }\n        varname = node.name;\n        if (noPai === null) {\n          coefficients[1] = 1;\n          return;\n        }\n\n        // ^: Symbol is First child\n        if (noPai.op === '^' && o.noFil !== 0) {\n          throw new Error('In power the variable should be the first parameter');\n        }\n\n        // *: Symbol is Second child\n        if (noPai.op === '*' && o.noFil !== 1) {\n          throw new Error('In multiply the variable should be the second parameter');\n        }\n\n        // Symbol: firers '',* => it means there is no exponent above, so it's 1 (cte * var)\n        if (o.fire === '' || o.fire === '*') {\n          if (maxExpo < 1) coefficients[1] = 0;\n          coefficients[1] += o.cte * (o.oper === '+' ? 1 : -1);\n          maxExpo = Math.max(1, maxExpo);\n        }\n      } else if (tp === 'ConstantNode') {\n        var valor = parseFloat(node.value);\n        if (noPai === null) {\n          coefficients[0] = valor;\n          return;\n        }\n        if (noPai.op === '^') {\n          // cte: second  child of power\n          if (o.noFil !== 1) throw new Error('Constant cannot be powered');\n          if (!isInteger(valor) || valor <= 0) {\n            throw new Error('Non-integer exponent is not allowed');\n          }\n          for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) coefficients[_i2] = 0;\n          if (valor > maxExpo) coefficients[valor] = 0;\n          coefficients[valor] += o.cte * (o.oper === '+' ? 1 : -1);\n          maxExpo = Math.max(valor, maxExpo);\n          return;\n        }\n        o.cte = valor;\n\n        // Cte: firer '' => There is no exponent and no multiplication, so the exponent is 0.\n        if (o.fire === '') {\n          coefficients[0] += o.cte * (o.oper === '+' ? 1 : -1);\n        }\n      } else {\n        throw new Error('Type ' + tp + ' is not allowed');\n      }\n    } // End of recurPol\n  } // End of polyToCanonical\n});"],"names":[],"mappings":"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AAM,UAAU,KAAK;YACjC;QACF,EAAE,iBAAiB;IACrB,EAAE,oBAAoB;IAEtB,0FAA0F;IAC1F;;;;;;;;GAQC,GACD,SAAS;QACP,IAAI,WAAW;YAAC;YAChB,QAAQ;YACR;gBACE,GAAG;gBACH,GAAG;YACL;YAAG;gBACD,GAAG;gBACH,GAAG;YACL;YAAG;YACH,YAAY;YACZ;gBACE,GAAG;gBACH,GAAG;YACL;YAAG;gBACD,GAAG;gBACH,GAAG;YACL;YAAG;gBACD,GAAG;gBACH,GAAG;YACL;YAAG;gBACD,GAAG;gBACH,GAAG;YACL;YAAG;gBACD,GAAG;gBACH,GAAG;YACL;SAAE;QACF,IAAI,aAAa;YAAC;gBAChB,GAAG;gBACH,GAAG;YACL;YACA,iBAAiB;YACjB;gBACE,GAAG;gBACH,GAAG;YACL;YACA,uBAAuB;YACvB;gBACE,GAAG;gBACH,GAAG;YACL;YACA,mBAAmB;YACnB;gBACE,GAAG;gBACH,GAAG;YACL;YACA,6CAA6C;YAC7C;gBACE,GAAG;gBACH,GAAG;YACL;YACA,iBAAiB;YACjB;gBACE,GAAG;gBACH,GAAG;YACL;YACA,iBAAiB;YACjB;gBACE,GAAG;gBACH,GAAG;YACL;YACA,oBAAoB;YACpB;gBACE,GAAG;gBACH,GAAG;YACL;YACA,oBAAoB;YACpB;gBACE,GAAG;gBACH,GAAG;YACL;YACA,oBAAoB;YACpB;gBACE,GAAG;gBACH,GAAG;YACL;YACA,oBAAoB;YACpB;gBACE,GAAG;gBACH,GAAG;YACL;YACA,2BAA2B;YAC3B;gBACE,GAAG;gBACH,GAAG;YACL;YACA,2BAA2B;YAC3B;gBACE,GAAG;gBACH,GAAG;YACL;YACA,oCAAoC;YACpC;gBACE,GAAG;gBACH,GAAG;YACL;YACA,oCAAoC;YACpC;gBACE,GAAG;gBACH,GAAG;YACL;YACA,oCAAoC;YACpC;gBACE,GAAG;gBACH,GAAG;YACL;YACA,oCAAoC;YACpC;gBACE,GAAG;gBACH,GAAG;YACL;YACA,oBAAoB;YACpB;gBACE,GAAG;gBACH,GAAG;YACL;YACA,oBAAoB;YACp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","ignoreList":[0],"debugId":null}}]
}